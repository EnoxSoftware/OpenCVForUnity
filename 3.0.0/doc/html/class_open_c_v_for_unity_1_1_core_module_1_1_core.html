<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenCV for Unity: OpenCVForUnity.CoreModule.Core Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenCV for Unity
   &#160;<span id="projectnumber">2.4.0</span>
   </div>
   <div id="projectbrief">Enox Software / Please refer to OpenCV official document ( http://docs.opencv.org/4.3.0/index.html ) for the details of the argument of the method.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_open_c_v_for_unity.html">OpenCVForUnity</a></li><li class="navelem"><a class="el" href="namespace_open_c_v_for_unity_1_1_core_module.html">CoreModule</a></li><li class="navelem"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html">Core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_open_c_v_for_unity_1_1_core_module_1_1_core-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenCVForUnity.CoreModule.Core Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core_1_1_min_max_loc_result.html">MinMaxLocResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5f0ad71fe7fe4203a49e0cd1c112ec88"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a5f0ad71fe7fe4203a49e0cd1c112ec88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1164b01aaba2483b75019a2a0f50603f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1164b01aaba2483b75019a2a0f50603f">mean</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src)</td></tr>
<tr class="separator:a1164b01aaba2483b75019a2a0f50603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8eae21526efeeafe675a409d1e4f8dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af8eae21526efeeafe675a409d1e4f8dc">sumElems</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src)</td></tr>
<tr class="separator:af8eae21526efeeafe675a409d1e4f8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bfc810ed4ff57d8e8fd7127286deda"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae3bfc810ed4ff57d8e8fd7127286deda">trace</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mtx)</td></tr>
<tr class="separator:ae3bfc810ed4ff57d8e8fd7127286deda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e647297cfa4400751bef5c4b7a3b667"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8e647297cfa4400751bef5c4b7a3b667">getBuildInformation</a> ()</td></tr>
<tr class="separator:a8e647297cfa4400751bef5c4b7a3b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca29ca6e9e12fe85100f45805c978953"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aca29ca6e9e12fe85100f45805c978953">getHardwareFeatureName</a> (int feature)</td></tr>
<tr class="separator:aca29ca6e9e12fe85100f45805c978953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c49a3a93e01f2aac900ace2282cf5eb"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6c49a3a93e01f2aac900ace2282cf5eb">getVersionString</a> ()</td></tr>
<tr class="separator:a6c49a3a93e01f2aac900ace2282cf5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e8e5dddf8606367830e7d14fcc33cb"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a73e8e5dddf8606367830e7d14fcc33cb">getIppVersion</a> ()</td></tr>
<tr class="separator:a73e8e5dddf8606367830e7d14fcc33cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13396309f2ee7f3a77604d00637b81e2"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a13396309f2ee7f3a77604d00637b81e2">findFile</a> (string relative_path, bool required, bool silentMode)</td></tr>
<tr class="separator:a13396309f2ee7f3a77604d00637b81e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ec2b469d2c7103a9e2fdf688b4ef0"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae61ec2b469d2c7103a9e2fdf688b4ef0">findFile</a> (string relative_path, bool required)</td></tr>
<tr class="separator:ae61ec2b469d2c7103a9e2fdf688b4ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04930fe4185f18142b589788513d60a4"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a04930fe4185f18142b589788513d60a4">findFile</a> (string relative_path)</td></tr>
<tr class="separator:a04930fe4185f18142b589788513d60a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae312cb93a3e5cd8f1a91dbd4d24032a3"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae312cb93a3e5cd8f1a91dbd4d24032a3">findFileOrKeep</a> (string relative_path, bool silentMode)</td></tr>
<tr class="separator:ae312cb93a3e5cd8f1a91dbd4d24032a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346163bcd998955e69e9277de194fe9c"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a346163bcd998955e69e9277de194fe9c">findFileOrKeep</a> (string relative_path)</td></tr>
<tr class="separator:a346163bcd998955e69e9277de194fe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ad8c5fc4897f2fa64931303ac044d7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac6ad8c5fc4897f2fa64931303ac044d7">checkRange</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, bool quiet, double minVal, double maxVal)</td></tr>
<tr class="separator:ac6ad8c5fc4897f2fa64931303ac044d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7ef1abcd7a4bfbdd2c5e528a5a813d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f7ef1abcd7a4bfbdd2c5e528a5a813d">checkRange</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, bool quiet, double minVal)</td></tr>
<tr class="separator:a5f7ef1abcd7a4bfbdd2c5e528a5a813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362d57b7056f4aa502e54ad1bd4c7a7e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a362d57b7056f4aa502e54ad1bd4c7a7e">checkRange</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, bool quiet)</td></tr>
<tr class="separator:a362d57b7056f4aa502e54ad1bd4c7a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f105a090f2dee77258563865e185b61"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9f105a090f2dee77258563865e185b61">checkRange</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="separator:a9f105a090f2dee77258563865e185b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7fd8bf7dca9c230636f43c4e638cc4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0b7fd8bf7dca9c230636f43c4e638cc4">eigen</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvalues, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors)</td></tr>
<tr class="separator:a0b7fd8bf7dca9c230636f43c4e638cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f30b1bff51a114c9cc7f188d0b3f79"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a27f30b1bff51a114c9cc7f188d0b3f79">eigen</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvalues)</td></tr>
<tr class="separator:a27f30b1bff51a114c9cc7f188d0b3f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1ad161c9e65802e5da32b538218888"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1d1ad161c9e65802e5da32b538218888">solve</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:a1d1ad161c9e65802e5da32b538218888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9bc4028443ce6c9e8ce137d8289504"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8e9bc4028443ce6c9e8ce137d8289504">solve</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a8e9bc4028443ce6c9e8ce137d8289504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dc7bfdd36424687625176d6883a2d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad9dc7bfdd36424687625176d6883a2d8">useIPP</a> ()</td></tr>
<tr class="separator:ad9dc7bfdd36424687625176d6883a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27941040c435fae64832b5e22bdbdf6b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a27941040c435fae64832b5e22bdbdf6b">useIPP_NotExact</a> ()</td></tr>
<tr class="separator:a27941040c435fae64832b5e22bdbdf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3d1d1e6056d684d93abef86e753818"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aeb3d1d1e6056d684d93abef86e753818">Mahalanobis</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> v1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> v2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> icovar)</td></tr>
<tr class="separator:aeb3d1d1e6056d684d93abef86e753818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f1d595e05155f3a617c93d63a8b499"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af0f1d595e05155f3a617c93d63a8b499">PSNR</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, double R)</td></tr>
<tr class="separator:af0f1d595e05155f3a617c93d63a8b499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979c224c69e41feba8ef7044fb7850bc"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a979c224c69e41feba8ef7044fb7850bc">PSNR</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2)</td></tr>
<tr class="separator:a979c224c69e41feba8ef7044fb7850bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0ce157a707e0b564fe648d587384cc"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aed0ce157a707e0b564fe648d587384cc">determinant</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mtx)</td></tr>
<tr class="separator:aed0ce157a707e0b564fe648d587384cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8ef99721a08457355011e970a1c4c1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5d8ef99721a08457355011e970a1c4c1">getTickFrequency</a> ()</td></tr>
<tr class="separator:a5d8ef99721a08457355011e970a1c4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d0a5a69b0b5b9e78a46e5028a52a26"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a24d0a5a69b0b5b9e78a46e5028a52a26">invert</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:a24d0a5a69b0b5b9e78a46e5028a52a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb14236ffbede2b4931aa67e78e925b8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acb14236ffbede2b4931aa67e78e925b8">invert</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:acb14236ffbede2b4931aa67e78e925b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54d4488d95f8ef823bab115c2ec0db6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa54d4488d95f8ef823bab115c2ec0db6">kmeans</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, int K, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> bestLabels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a> criteria, int attempts, int flags, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> centers)</td></tr>
<tr class="separator:aa54d4488d95f8ef823bab115c2ec0db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86290ef2c416ff00281b94d79014d5e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae86290ef2c416ff00281b94d79014d5e">kmeans</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, int K, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> bestLabels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a> criteria, int attempts, int flags)</td></tr>
<tr class="separator:ae86290ef2c416ff00281b94d79014d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81a2df0a3d87ba2f825cb2b2455294e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae81a2df0a3d87ba2f825cb2b2455294e">norm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, int normType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:ae81a2df0a3d87ba2f825cb2b2455294e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685fe6d481dc54a93309a5ead50df724"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a685fe6d481dc54a93309a5ead50df724">norm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, int normType)</td></tr>
<tr class="separator:a685fe6d481dc54a93309a5ead50df724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9281563c5a9e1a03c05cfe6a5a0c82c8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9281563c5a9e1a03c05cfe6a5a0c82c8">norm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2)</td></tr>
<tr class="separator:a9281563c5a9e1a03c05cfe6a5a0c82c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf26dfc459ee5f93f684bed9dc2f0a9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a3bf26dfc459ee5f93f684bed9dc2f0a9">norm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, int normType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a3bf26dfc459ee5f93f684bed9dc2f0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae520c3a230b3881ff13c2d2149354dd4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae520c3a230b3881ff13c2d2149354dd4">norm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, int normType)</td></tr>
<tr class="separator:ae520c3a230b3881ff13c2d2149354dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7867ef1188bdceb5a37de2949f269cf5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7867ef1188bdceb5a37de2949f269cf5">norm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1)</td></tr>
<tr class="separator:a7867ef1188bdceb5a37de2949f269cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d8f951f5f4da0b894fa48cc336d2e6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a66d8f951f5f4da0b894fa48cc336d2e6">solvePoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> coeffs, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roots, int maxIters)</td></tr>
<tr class="separator:a66d8f951f5f4da0b894fa48cc336d2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1d4b6a69514aafb994a0102e263298"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adc1d4b6a69514aafb994a0102e263298">solvePoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> coeffs, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roots)</td></tr>
<tr class="separator:adc1d4b6a69514aafb994a0102e263298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22f2d9250b079e1fe89ae6c2ea02511"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af22f2d9250b079e1fe89ae6c2ea02511">cubeRoot</a> (float val)</td></tr>
<tr class="separator:af22f2d9250b079e1fe89ae6c2ea02511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431aa65df203a0950d631f6b93253251"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a431aa65df203a0950d631f6b93253251">fastAtan2</a> (float y, float x)</td></tr>
<tr class="separator:a431aa65df203a0950d631f6b93253251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa419e3c9fb18a0ce0a891d3170e01b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6aa419e3c9fb18a0ce0a891d3170e01b">borderInterpolate</a> (int p, int len, int borderType)</td></tr>
<tr class="separator:a6aa419e3c9fb18a0ce0a891d3170e01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed19616c452764595ecd358d9409a30"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8ed19616c452764595ecd358d9409a30">countNonZero</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src)</td></tr>
<tr class="separator:a8ed19616c452764595ecd358d9409a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada858e987ec8db0a379ae7d346865b1d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ada858e987ec8db0a379ae7d346865b1d">getNumThreads</a> ()</td></tr>
<tr class="separator:ada858e987ec8db0a379ae7d346865b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f0ee81456a015c0aa2828d4fcfd48"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a865f0ee81456a015c0aa2828d4fcfd48">getNumberOfCPUs</a> ()</td></tr>
<tr class="separator:a865f0ee81456a015c0aa2828d4fcfd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba395b2232635e6ba829f645871bd06f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aba395b2232635e6ba829f645871bd06f">getOptimalDFTSize</a> (int vecsize)</td></tr>
<tr class="separator:aba395b2232635e6ba829f645871bd06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037aadbcc65aab3f55921a6792fd23b0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a037aadbcc65aab3f55921a6792fd23b0">getThreadNum</a> ()</td></tr>
<tr class="separator:a037aadbcc65aab3f55921a6792fd23b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faf7f6ff30aea195991d93be71a2d28"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5faf7f6ff30aea195991d93be71a2d28">getVersionMajor</a> ()</td></tr>
<tr class="separator:a5faf7f6ff30aea195991d93be71a2d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7092c590029ef971efa2eb0dc7aa3e30"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7092c590029ef971efa2eb0dc7aa3e30">getVersionMinor</a> ()</td></tr>
<tr class="separator:a7092c590029ef971efa2eb0dc7aa3e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dccaf5ee65496b0af0e66ac896a7ee"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a38dccaf5ee65496b0af0e66ac896a7ee">getVersionRevision</a> ()</td></tr>
<tr class="separator:a38dccaf5ee65496b0af0e66ac896a7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf5073f128bac97be5edf68a4a16dec"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adaf5073f128bac97be5edf68a4a16dec">solveCubic</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> coeffs, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roots)</td></tr>
<tr class="separator:adaf5073f128bac97be5edf68a4a16dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8613cb7c4cc85f2ba736f9efc769b6c1"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8613cb7c4cc85f2ba736f9efc769b6c1">getCPUTickCount</a> ()</td></tr>
<tr class="separator:a8613cb7c4cc85f2ba736f9efc769b6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208f302ff9b1a6fe2621eadfe6027664"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a208f302ff9b1a6fe2621eadfe6027664">getTickCount</a> ()</td></tr>
<tr class="separator:a208f302ff9b1a6fe2621eadfe6027664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4e9fc59bb107b140cf139db4c6d823"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5d4e9fc59bb107b140cf139db4c6d823">getCPUFeaturesLine</a> ()</td></tr>
<tr class="separator:a5d4e9fc59bb107b140cf139db4c6d823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8383ebe3bcc91813b06c3a5f90395e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0c8383ebe3bcc91813b06c3a5f90395e">LUT</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lut, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a0c8383ebe3bcc91813b06c3a5f90395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7703d5fc634f9729ff14ecb2391657d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7703d5fc634f9729ff14ecb2391657d8">PCABackProject</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> result)</td></tr>
<tr class="separator:a7703d5fc634f9729ff14ecb2391657d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ab6785c337f0f6191141ca202a3be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf2ab6785c337f0f6191141ca202a3be">PCACompute2</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvalues, double retainedVariance)</td></tr>
<tr class="separator:adf2ab6785c337f0f6191141ca202a3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6003198cec970cdfabde698a5a3b1209"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6003198cec970cdfabde698a5a3b1209">PCACompute2</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvalues, int maxComponents)</td></tr>
<tr class="separator:a6003198cec970cdfabde698a5a3b1209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc849aa6f04b413be7faefbbe3987497"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acc849aa6f04b413be7faefbbe3987497">PCACompute2</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvalues)</td></tr>
<tr class="separator:acc849aa6f04b413be7faefbbe3987497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684eaf52058395dbccb59ee237dedb56"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a684eaf52058395dbccb59ee237dedb56">PCACompute</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors, double retainedVariance)</td></tr>
<tr class="separator:a684eaf52058395dbccb59ee237dedb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2fd927fb4be8445413935cbcf08ae8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7f2fd927fb4be8445413935cbcf08ae8">PCACompute</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors, int maxComponents)</td></tr>
<tr class="separator:a7f2fd927fb4be8445413935cbcf08ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6649a63ea7c46f068c3d86f8dc573d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#abb6649a63ea7c46f068c3d86f8dc573d">PCACompute</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors)</td></tr>
<tr class="separator:abb6649a63ea7c46f068c3d86f8dc573d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3140e53c41ee1949d0b4859be377cabd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a3140e53c41ee1949d0b4859be377cabd">PCAProject</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> data, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> result)</td></tr>
<tr class="separator:a3140e53c41ee1949d0b4859be377cabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab943b0770e86fe2386f9d44f6b848606"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab943b0770e86fe2386f9d44f6b848606">SVBackSubst</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> w, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> u, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> vt, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> rhs, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ab943b0770e86fe2386f9d44f6b848606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac50816b6cee0e1152f75ba37a7df027"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aac50816b6cee0e1152f75ba37a7df027">SVDecomp</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> w, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> u, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> vt, int flags)</td></tr>
<tr class="separator:aac50816b6cee0e1152f75ba37a7df027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a8267cd259995775e0e5547371ca33"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53a8267cd259995775e0e5547371ca33">SVDecomp</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> w, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> u, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> vt)</td></tr>
<tr class="separator:a53a8267cd259995775e0e5547371ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8772157d70a4569a0af64ed641819dcd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8772157d70a4569a0af64ed641819dcd">absdiff</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a8772157d70a4569a0af64ed641819dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4dedc6e51c989d3fb1af7083239e25"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aca4dedc6e51c989d3fb1af7083239e25">absdiff</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:aca4dedc6e51c989d3fb1af7083239e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb84c30ae0850e136da2668255978958"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acb84c30ae0850e136da2668255978958">add</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int dtype)</td></tr>
<tr class="separator:acb84c30ae0850e136da2668255978958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f0d00ed2e9c8fbd359b696c6562530"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae8f0d00ed2e9c8fbd359b696c6562530">add</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:ae8f0d00ed2e9c8fbd359b696c6562530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e09cec72e7de408fcbf8c03d234358"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a46e09cec72e7de408fcbf8c03d234358">add</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a46e09cec72e7de408fcbf8c03d234358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907cc6fca9b0985285555319c1268872"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a907cc6fca9b0985285555319c1268872">add</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int dtype)</td></tr>
<tr class="separator:a907cc6fca9b0985285555319c1268872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171698cecdb4b0d75eb92d3e1a46dc5c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a171698cecdb4b0d75eb92d3e1a46dc5c">add</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a171698cecdb4b0d75eb92d3e1a46dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464f532e295d84dfba84aab3e8d1600a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a464f532e295d84dfba84aab3e8d1600a">add</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a464f532e295d84dfba84aab3e8d1600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24112e235aa55c377bff9129ea365875"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a24112e235aa55c377bff9129ea365875">addWeighted</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, double alpha, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, double beta, double gamma, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int dtype)</td></tr>
<tr class="separator:a24112e235aa55c377bff9129ea365875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9970941c8dd3a91a19fb71c650ef424"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af9970941c8dd3a91a19fb71c650ef424">addWeighted</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, double alpha, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, double beta, double gamma, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:af9970941c8dd3a91a19fb71c650ef424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d17b8b64777812a0c343ed50ab76379"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4d17b8b64777812a0c343ed50ab76379">batchDistance</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dist, int dtype, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> nidx, int normType, int K, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int update, bool crosscheck)</td></tr>
<tr class="separator:a4d17b8b64777812a0c343ed50ab76379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848801f38e3bc9ca99d462e4cf985556"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a848801f38e3bc9ca99d462e4cf985556">batchDistance</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dist, int dtype, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> nidx, int normType, int K, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int update)</td></tr>
<tr class="separator:a848801f38e3bc9ca99d462e4cf985556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fca93c1f3e8adcf047e7a923ccf365d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7fca93c1f3e8adcf047e7a923ccf365d">batchDistance</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dist, int dtype, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> nidx, int normType, int K, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a7fca93c1f3e8adcf047e7a923ccf365d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213378a4d3f6650c264a53a42ffe5a80"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a213378a4d3f6650c264a53a42ffe5a80">batchDistance</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dist, int dtype, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> nidx, int normType, int K)</td></tr>
<tr class="separator:a213378a4d3f6650c264a53a42ffe5a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b224c5ecb8e3213283f01e9926c8117"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9b224c5ecb8e3213283f01e9926c8117">batchDistance</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dist, int dtype, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> nidx, int normType)</td></tr>
<tr class="separator:a9b224c5ecb8e3213283f01e9926c8117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75e8158f12b844ada2d78021e1e3384"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab75e8158f12b844ada2d78021e1e3384">batchDistance</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dist, int dtype, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> nidx)</td></tr>
<tr class="separator:ab75e8158f12b844ada2d78021e1e3384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4fe32250e9a646f60a6eed57d5c3eb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#afb4fe32250e9a646f60a6eed57d5c3eb">bitwise_and</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:afb4fe32250e9a646f60a6eed57d5c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e46e854142100571779100fcbe9a78"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a66e46e854142100571779100fcbe9a78">bitwise_and</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a66e46e854142100571779100fcbe9a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb488f17edfd0e2ec9dbf0324a87cbc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#abb488f17edfd0e2ec9dbf0324a87cbc3">bitwise_not</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:abb488f17edfd0e2ec9dbf0324a87cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a0e3912aac1f874370eb9b2fd26b22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad2a0e3912aac1f874370eb9b2fd26b22">bitwise_not</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ad2a0e3912aac1f874370eb9b2fd26b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cf61e15c074b955150392753b501b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a71cf61e15c074b955150392753b501b7">bitwise_or</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a71cf61e15c074b955150392753b501b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b7e74e15789fbfa3a88a2fa77a33b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a37b7e74e15789fbfa3a88a2fa77a33b9">bitwise_or</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a37b7e74e15789fbfa3a88a2fa77a33b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fbea037a592d0a26095ad6148ee6d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa8fbea037a592d0a26095ad6148ee6d4">bitwise_xor</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:aa8fbea037a592d0a26095ad6148ee6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc746329eab28f3c6e428dae7fbb48a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8bc746329eab28f3c6e428dae7fbb48a">bitwise_xor</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a8bc746329eab28f3c6e428dae7fbb48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89874626e1f5ee355645d0ac862d2d00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a89874626e1f5ee355645d0ac862d2d00">calcCovarMatrix</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> samples, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> covar, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, int flags, int ctype)</td></tr>
<tr class="separator:a89874626e1f5ee355645d0ac862d2d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92baaacd8ccacde0b85dc7fcdaca1f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acb92baaacd8ccacde0b85dc7fcdaca1f">calcCovarMatrix</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> samples, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> covar, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, int flags)</td></tr>
<tr class="separator:acb92baaacd8ccacde0b85dc7fcdaca1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452013d3be5200c4c6cbb902bf1474b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a452013d3be5200c4c6cbb902bf1474b9">cartToPolar</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> x, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> y, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ade1a02da217526c9612861eb46789b47">magnitude</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> angle, bool angleInDegrees)</td></tr>
<tr class="separator:a452013d3be5200c4c6cbb902bf1474b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e521af9d8f7fb8791f14d1a7f2f9ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a04e521af9d8f7fb8791f14d1a7f2f9ff">cartToPolar</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> x, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> y, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ade1a02da217526c9612861eb46789b47">magnitude</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> angle)</td></tr>
<tr class="separator:a04e521af9d8f7fb8791f14d1a7f2f9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b5b4761e2510828070520b5056506b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a09b5b4761e2510828070520b5056506b">compare</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int cmpop)</td></tr>
<tr class="separator:a09b5b4761e2510828070520b5056506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f618d3e76c35d5b34958a61418c377e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1f618d3e76c35d5b34958a61418c377e">compare</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int cmpop)</td></tr>
<tr class="separator:a1f618d3e76c35d5b34958a61418c377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e265bc55b98613ec01f6b3dc11db5a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53e265bc55b98613ec01f6b3dc11db5a">completeSymm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, bool lowerToUpper)</td></tr>
<tr class="separator:a53e265bc55b98613ec01f6b3dc11db5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7959cb8151de232a89d152ddba77d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aeb7959cb8151de232a89d152ddba77d7">completeSymm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="separator:aeb7959cb8151de232a89d152ddba77d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfeb129b82c198d7524674207ed0a5c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4bfeb129b82c198d7524674207ed0a5c">convertFp16</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a4bfeb129b82c198d7524674207ed0a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ab918b6468b4c2a04bb6e7bfe876f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a3b7ab918b6468b4c2a04bb6e7bfe876f">convertScaleAbs</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha, double beta)</td></tr>
<tr class="separator:a3b7ab918b6468b4c2a04bb6e7bfe876f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82619660103a42d83225d4c879f565c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad82619660103a42d83225d4c879f565c">convertScaleAbs</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha)</td></tr>
<tr class="separator:ad82619660103a42d83225d4c879f565c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b204dbf02fcc9bbc67ba46c6dd9b15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae2b204dbf02fcc9bbc67ba46c6dd9b15">convertScaleAbs</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ae2b204dbf02fcc9bbc67ba46c6dd9b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb68ff84346925f03e34a18af4bc9a99"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acb68ff84346925f03e34a18af4bc9a99">copyMakeBorder</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int top, int bottom, int left, int right, int borderType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> value)</td></tr>
<tr class="separator:acb68ff84346925f03e34a18af4bc9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb8ce70678829b90d31b42b4e5ff42f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aafb8ce70678829b90d31b42b4e5ff42f">copyMakeBorder</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int top, int bottom, int left, int right, int borderType)</td></tr>
<tr class="separator:aafb8ce70678829b90d31b42b4e5ff42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1333f5071adbeb874d1ca1fa7620a24f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1333f5071adbeb874d1ca1fa7620a24f">copyTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a1333f5071adbeb874d1ca1fa7620a24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda6069b688b78db68f7ec6292dad9c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adda6069b688b78db68f7ec6292dad9c7">dct</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:adda6069b688b78db68f7ec6292dad9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7808ef62732d31e4261c71bdb06455"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5d7808ef62732d31e4261c71bdb06455">dct</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a5d7808ef62732d31e4261c71bdb06455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcd74cea1d4886ce01621d4dec38b6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1dcd74cea1d4886ce01621d4dec38b6f">dft</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags, int nonzeroRows)</td></tr>
<tr class="separator:a1dcd74cea1d4886ce01621d4dec38b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857fd910d5e4bcafaef82a9ccb5db019"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a857fd910d5e4bcafaef82a9ccb5db019">dft</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:a857fd910d5e4bcafaef82a9ccb5db019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ae8b1b309200f8a94c2e9f1bc9e1cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab5ae8b1b309200f8a94c2e9f1bc9e1cd">dft</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ab5ae8b1b309200f8a94c2e9f1bc9e1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ba80bc70b7936509e314382ed918c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac3ba80bc70b7936509e314382ed918c6">divide</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale, int dtype)</td></tr>
<tr class="separator:ac3ba80bc70b7936509e314382ed918c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ee09e91f417aa03a4a87b93d72cd1a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a02ee09e91f417aa03a4a87b93d72cd1a">divide</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale)</td></tr>
<tr class="separator:a02ee09e91f417aa03a4a87b93d72cd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d9cdb371525f36057abdafdd609c54"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac7d9cdb371525f36057abdafdd609c54">divide</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ac7d9cdb371525f36057abdafdd609c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfcd950f1a48eb0622703a99f792590"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6dfcd950f1a48eb0622703a99f792590">divide</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale, int dtype)</td></tr>
<tr class="separator:a6dfcd950f1a48eb0622703a99f792590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7990e13b763247fac3f2d05c54a5b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8e7990e13b763247fac3f2d05c54a5b2">divide</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale)</td></tr>
<tr class="separator:a8e7990e13b763247fac3f2d05c54a5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf205e44d433d920981d3c8d28ab1c9d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf205e44d433d920981d3c8d28ab1c9d">divide</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:adf205e44d433d920981d3c8d28ab1c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9603766e3901ad0da898cf75f7815ac6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9603766e3901ad0da898cf75f7815ac6">divide</a> (double scale, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int dtype)</td></tr>
<tr class="separator:a9603766e3901ad0da898cf75f7815ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c04001516fbaf9d1e95e0c59fbb7098"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8c04001516fbaf9d1e95e0c59fbb7098">divide</a> (double scale, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a8c04001516fbaf9d1e95e0c59fbb7098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3219b28c1a318c81bf4dba24f658c3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6d3219b28c1a318c81bf4dba24f658c3">eigenNonSymmetric</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvalues, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> eigenvectors)</td></tr>
<tr class="separator:a6d3219b28c1a318c81bf4dba24f658c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31b0f8b9cb1536e021092c9f09017a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa31b0f8b9cb1536e021092c9f09017a5">exp</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:aa31b0f8b9cb1536e021092c9f09017a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce16fd41376338d52f61128387b4c4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1ce16fd41376338d52f61128387b4c4c">extractChannel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int coi)</td></tr>
<tr class="separator:a1ce16fd41376338d52f61128387b4c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ae5e37ff5de75a389da2ca0bb30fff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a32ae5e37ff5de75a389da2ca0bb30fff">findNonZero</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> idx)</td></tr>
<tr class="separator:a32ae5e37ff5de75a389da2ca0bb30fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06719211e27bdb5c67c454ea28b16f8b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a06719211e27bdb5c67c454ea28b16f8b">flip</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flipCode)</td></tr>
<tr class="separator:a06719211e27bdb5c67c454ea28b16f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92c515d8a2d29f05d74081472b937f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab92c515d8a2d29f05d74081472b937f7">gemm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, double alpha, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src3, double beta, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:ab92c515d8a2d29f05d74081472b937f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a014f27240f77a34e6d2d9e90b7019d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8a014f27240f77a34e6d2d9e90b7019d">gemm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, double alpha, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src3, double beta, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a8a014f27240f77a34e6d2d9e90b7019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e94aeb54835fea90fa1b5ee6798836"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a92e94aeb54835fea90fa1b5ee6798836">hconcat</a> (List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a92e94aeb54835fea90fa1b5ee6798836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf24e275fe80d5100877eb544f11b7d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adbf24e275fe80d5100877eb544f11b7d">idct</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:adbf24e275fe80d5100877eb544f11b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f31feeb094b72f265f818ec63f819e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a92f31feeb094b72f265f818ec63f819e">idct</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a92f31feeb094b72f265f818ec63f819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76715522aef23c3f9a6f20cc26763fbd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a76715522aef23c3f9a6f20cc26763fbd">idft</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags, int nonzeroRows)</td></tr>
<tr class="separator:a76715522aef23c3f9a6f20cc26763fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6051d6f6762ea8f039736f24b652cc45"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6051d6f6762ea8f039736f24b652cc45">idft</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:a6051d6f6762ea8f039736f24b652cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abb52ac82bcba1b893953c5baad4be3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9abb52ac82bcba1b893953c5baad4be3">idft</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a9abb52ac82bcba1b893953c5baad4be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e6beb9f2729162f910dd65e2553d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a881e6beb9f2729162f910dd65e2553d0">inRange</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> lowerb, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> upperb, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a881e6beb9f2729162f910dd65e2553d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9f638028cbb739d65b615f0ef7d400"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6b9f638028cbb739d65b615f0ef7d400">insertChannel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int coi)</td></tr>
<tr class="separator:a6b9f638028cbb739d65b615f0ef7d400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c76e31c90bd954a1f1219b45a080564"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9c76e31c90bd954a1f1219b45a080564">log</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a9c76e31c90bd954a1f1219b45a080564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1a02da217526c9612861eb46789b47"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ade1a02da217526c9612861eb46789b47">magnitude</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> x, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> y, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> magnitude)</td></tr>
<tr class="separator:ade1a02da217526c9612861eb46789b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1336ed734805b0c48ef0b12a5309ba9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa1336ed734805b0c48ef0b12a5309ba9">max</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:aa1336ed734805b0c48ef0b12a5309ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380811a8627ee54507839cf4da54734b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a380811a8627ee54507839cf4da54734b">max</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a380811a8627ee54507839cf4da54734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf6760a6e549cbe00db6c6a812ca0d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#afcf6760a6e549cbe00db6c6a812ca0d2">meanStdDev</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a> stddev, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:afcf6760a6e549cbe00db6c6a812ca0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3d6b5417eb7606f96a038f26685c70"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2b3d6b5417eb7606f96a038f26685c70">meanStdDev</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a> stddev)</td></tr>
<tr class="separator:a2b3d6b5417eb7606f96a038f26685c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaec204a321eff54db03f6e0e8fb019"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acdaec204a321eff54db03f6e0e8fb019">merge</a> (List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; mv, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:acdaec204a321eff54db03f6e0e8fb019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e45599d4ec446296d8a21a820fa10b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a35e45599d4ec446296d8a21a820fa10b">min</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a35e45599d4ec446296d8a21a820fa10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca90c8da22eabcad628cfdf1d2b7213"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4ca90c8da22eabcad628cfdf1d2b7213">min</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a4ca90c8da22eabcad628cfdf1d2b7213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab20dda8ab0b7c696f24a023acec9633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aab20dda8ab0b7c696f24a023acec9633">mixChannels</a> (List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; src, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> fromTo)</td></tr>
<tr class="separator:aab20dda8ab0b7c696f24a023acec9633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5714f19d1cbee3f5222d1ad5cfac9c11"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5714f19d1cbee3f5222d1ad5cfac9c11">mulSpectrums</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> c, int flags, bool conjB)</td></tr>
<tr class="separator:a5714f19d1cbee3f5222d1ad5cfac9c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab997b9a46a2c74bfd91e0e4ac157c0df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab997b9a46a2c74bfd91e0e4ac157c0df">mulSpectrums</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> c, int flags)</td></tr>
<tr class="separator:ab997b9a46a2c74bfd91e0e4ac157c0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90717e930baaeea7cc2aba0afbd72de7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a90717e930baaeea7cc2aba0afbd72de7">mulTransposed</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, bool aTa, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> delta, double scale, int dtype)</td></tr>
<tr class="separator:a90717e930baaeea7cc2aba0afbd72de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc6993f35356ec2d78df92674ced2fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aacc6993f35356ec2d78df92674ced2fe">mulTransposed</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, bool aTa, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> delta, double scale)</td></tr>
<tr class="separator:aacc6993f35356ec2d78df92674ced2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ab9142ca92ee4dcf896095b4933b8d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53ab9142ca92ee4dcf896095b4933b8d">mulTransposed</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, bool aTa, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> delta)</td></tr>
<tr class="separator:a53ab9142ca92ee4dcf896095b4933b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d59e704f2c17ee2d5bed51ec165eea3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5d59e704f2c17ee2d5bed51ec165eea3">mulTransposed</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, bool aTa)</td></tr>
<tr class="separator:a5d59e704f2c17ee2d5bed51ec165eea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e05566c60eecf6f42961a76bf86e7ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0e05566c60eecf6f42961a76bf86e7ec">multiply</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale, int dtype)</td></tr>
<tr class="separator:a0e05566c60eecf6f42961a76bf86e7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5011f045493b48e7233dead0c2c6cc9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5011f045493b48e7233dead0c2c6cc9f">multiply</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale)</td></tr>
<tr class="separator:a5011f045493b48e7233dead0c2c6cc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87451b21ef4049e95478954a61e95ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad87451b21ef4049e95478954a61e95ff">multiply</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ad87451b21ef4049e95478954a61e95ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268ce4190e2c24305724e19c378f07e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a268ce4190e2c24305724e19c378f07e8">multiply</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale, int dtype)</td></tr>
<tr class="separator:a268ce4190e2c24305724e19c378f07e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc5baa3e60baa1baaeeb42600aa8a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a04dc5baa3e60baa1baaeeb42600aa8a0">multiply</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double scale)</td></tr>
<tr class="separator:a04dc5baa3e60baa1baaeeb42600aa8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaf1521286d0e1cbd174aed9c56d90e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adeaf1521286d0e1cbd174aed9c56d90e">multiply</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:adeaf1521286d0e1cbd174aed9c56d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19b75b7e7925326f558bbdecdf7537f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af19b75b7e7925326f558bbdecdf7537f">normalize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha, double beta, int norm_type, int dtype, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:af19b75b7e7925326f558bbdecdf7537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fd11cdb823851d118090099fc8a53c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa3fd11cdb823851d118090099fc8a53c">normalize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha, double beta, int norm_type, int dtype)</td></tr>
<tr class="separator:aa3fd11cdb823851d118090099fc8a53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be4215c7b5181e90d5b0701bcbca19a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2be4215c7b5181e90d5b0701bcbca19a">normalize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha, double beta, int norm_type)</td></tr>
<tr class="separator:a2be4215c7b5181e90d5b0701bcbca19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c037b64e2653596c77851097f31d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad43c037b64e2653596c77851097f31d5">normalize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha, double beta)</td></tr>
<tr class="separator:ad43c037b64e2653596c77851097f31d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4233122f27ebefa148d7fc9c93d76af8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4233122f27ebefa148d7fc9c93d76af8">normalize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha)</td></tr>
<tr class="separator:a4233122f27ebefa148d7fc9c93d76af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc3cf19d614754f9c8245b98fa44ecd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4cc3cf19d614754f9c8245b98fa44ecd">normalize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a4cc3cf19d614754f9c8245b98fa44ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6159442437f889f168248da55a5356cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6159442437f889f168248da55a5356cb">patchNaNs</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, double val)</td></tr>
<tr class="separator:a6159442437f889f168248da55a5356cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8c8d3be495fcb57e3e9289a23d0a78"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4f8c8d3be495fcb57e3e9289a23d0a78">patchNaNs</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="separator:a4f8c8d3be495fcb57e3e9289a23d0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea962c2e506b4c90e2a9b068ca30125f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aea962c2e506b4c90e2a9b068ca30125f">perspectiveTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="separator:aea962c2e506b4c90e2a9b068ca30125f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78f3f073856ed4f96d12f2053055b48"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa78f3f073856ed4f96d12f2053055b48">phase</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> x, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> y, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> angle, bool angleInDegrees)</td></tr>
<tr class="separator:aa78f3f073856ed4f96d12f2053055b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f35e75c9428f78569c6b6f20300220b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9f35e75c9428f78569c6b6f20300220b">phase</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> x, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> y, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> angle)</td></tr>
<tr class="separator:a9f35e75c9428f78569c6b6f20300220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c517d61b3aa460dac7847512483c4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a38c517d61b3aa460dac7847512483c4d">polarToCart</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ade1a02da217526c9612861eb46789b47">magnitude</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> angle, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> x, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> y, bool angleInDegrees)</td></tr>
<tr class="separator:a38c517d61b3aa460dac7847512483c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c65bd4040f9c8a8c975b11dcc126125"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9c65bd4040f9c8a8c975b11dcc126125">polarToCart</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ade1a02da217526c9612861eb46789b47">magnitude</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> angle, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> x, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> y)</td></tr>
<tr class="separator:a9c65bd4040f9c8a8c975b11dcc126125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaff667376988a457d21993b511f0763"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acaff667376988a457d21993b511f0763">pow</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, double power, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:acaff667376988a457d21993b511f0763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726398cf4782f2168146bfb60e4d84c3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a726398cf4782f2168146bfb60e4d84c3">randShuffle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double iterFactor)</td></tr>
<tr class="separator:a726398cf4782f2168146bfb60e4d84c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1216a0014e796dd1105dd52e7e7d02b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad1216a0014e796dd1105dd52e7e7d02b">randShuffle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ad1216a0014e796dd1105dd52e7e7d02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dab1ed5c31ee30b2492e3c8d903ce80"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7dab1ed5c31ee30b2492e3c8d903ce80">randn</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f0ad71fe7fe4203a49e0cd1c112ec88">mean</a>, double stddev)</td></tr>
<tr class="separator:a7dab1ed5c31ee30b2492e3c8d903ce80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb61cab7f3564055720e2fd36b8166a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aeb61cab7f3564055720e2fd36b8166a9">randu</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double low, double high)</td></tr>
<tr class="separator:aeb61cab7f3564055720e2fd36b8166a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169446607306d71f35adcff40aa4d6e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a169446607306d71f35adcff40aa4d6e5">reduce</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int dim, int rtype, int dtype)</td></tr>
<tr class="separator:a169446607306d71f35adcff40aa4d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2d63e6f924527e1221a703580ebe89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f2d63e6f924527e1221a703580ebe89">reduce</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int dim, int rtype)</td></tr>
<tr class="separator:a5f2d63e6f924527e1221a703580ebe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2993f18e5e50db04b97d861424b21470"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2993f18e5e50db04b97d861424b21470">repeat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, int ny, int nx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a2993f18e5e50db04b97d861424b21470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11b0f392585a665722be8e1e7e428c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8d11b0f392585a665722be8e1e7e428c">rotate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int rotateCode)</td></tr>
<tr class="separator:a8d11b0f392585a665722be8e1e7e428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5d50c46362bc44274febf1fcf1db19"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7a5d50c46362bc44274febf1fcf1db19">scaleAdd</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, double alpha, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a7a5d50c46362bc44274febf1fcf1db19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb83e7d23b61e776578dd545d794b1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a35cb83e7d23b61e776578dd545d794b1">setErrorVerbosity</a> (bool verbose)</td></tr>
<tr class="separator:a35cb83e7d23b61e776578dd545d794b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa02eb14f8f99fa8f7ce85e73022bdf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5fa02eb14f8f99fa8f7ce85e73022bdf">setIdentity</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mtx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="separator:a5fa02eb14f8f99fa8f7ce85e73022bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b5f6c3e6d4a78ca6d453553c59c8d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae2b5f6c3e6d4a78ca6d453553c59c8d0">setIdentity</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mtx)</td></tr>
<tr class="separator:ae2b5f6c3e6d4a78ca6d453553c59c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295910b348927d95cc2f66decc26a55c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a295910b348927d95cc2f66decc26a55c">setNumThreads</a> (int nthreads)</td></tr>
<tr class="separator:a295910b348927d95cc2f66decc26a55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1011e9b0100647833f5511ba334a4b16"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1011e9b0100647833f5511ba334a4b16">setRNGSeed</a> (int seed)</td></tr>
<tr class="separator:a1011e9b0100647833f5511ba334a4b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53df35d84adae45464f6416fe84ff361"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53df35d84adae45464f6416fe84ff361">sort</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:a53df35d84adae45464f6416fe84ff361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353f5e466e20f583f70e478ac1c0953a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a353f5e466e20f583f70e478ac1c0953a">sortIdx</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int flags)</td></tr>
<tr class="separator:a353f5e466e20f583f70e478ac1c0953a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1251b355138163682c3cefbf31874f85"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1251b355138163682c3cefbf31874f85">split</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; mv)</td></tr>
<tr class="separator:a1251b355138163682c3cefbf31874f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49792c1d55133782d6344dfa1f7c0558"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a49792c1d55133782d6344dfa1f7c0558">sqrt</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a49792c1d55133782d6344dfa1f7c0558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e67fdff0b02fb6cc6ec245fddcd9e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af7e67fdff0b02fb6cc6ec245fddcd9e8">subtract</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int dtype)</td></tr>
<tr class="separator:af7e67fdff0b02fb6cc6ec245fddcd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176f5ecab5a2550e3554661b19071c65"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a176f5ecab5a2550e3554661b19071c65">subtract</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a176f5ecab5a2550e3554661b19071c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e93c3e36a4040338e5989d923ce429a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5e93c3e36a4040338e5989d923ce429a">subtract</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a5e93c3e36a4040338e5989d923ce429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61e57769c8d4e25f9da4801c893e436"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab61e57769c8d4e25f9da4801c893e436">subtract</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int dtype)</td></tr>
<tr class="separator:ab61e57769c8d4e25f9da4801c893e436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb7c0329f41b7de2f28812c6243f57"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#affdb7c0329f41b7de2f28812c6243f57">subtract</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:affdb7c0329f41b7de2f28812c6243f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c6ba57417b73e7371fa38be56582d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a27c6ba57417b73e7371fa38be56582d7">subtract</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a27c6ba57417b73e7371fa38be56582d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c33f0fb5deafc1457cf9a1cb1568a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad8c33f0fb5deafc1457cf9a1cb1568a6">transform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="separator:ad8c33f0fb5deafc1457cf9a1cb1568a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc608b5531dce3ded593b1ca0a2836f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1bc608b5531dce3ded593b1ca0a2836f">transpose</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a1bc608b5531dce3ded593b1ca0a2836f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435b1a999402987596e62ae4fbf46fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6435b1a999402987596e62ae4fbf46fb">vconcat</a> (List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a6435b1a999402987596e62ae4fbf46fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78eb7c0fecb9161c6cbda78db6239169"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a78eb7c0fecb9161c6cbda78db6239169">setUseIPP</a> (bool flag)</td></tr>
<tr class="separator:a78eb7c0fecb9161c6cbda78db6239169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab844271d8ea4cb2efb07ff8b67ec349b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab844271d8ea4cb2efb07ff8b67ec349b">setUseIPP_NotExact</a> (bool flag)</td></tr>
<tr class="separator:ab844271d8ea4cb2efb07ff8b67ec349b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1623398b4f1a7c4990823fb02e7f1d62"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1623398b4f1a7c4990823fb02e7f1d62">addSamplesDataSearchPath</a> (string path)</td></tr>
<tr class="separator:a1623398b4f1a7c4990823fb02e7f1d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e3269bf977bd4ca665470c099a4c1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa1e3269bf977bd4ca665470c099a4c1e">addSamplesDataSearchSubDirectory</a> (string subdir)</td></tr>
<tr class="separator:aa1e3269bf977bd4ca665470c099a4c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a77513b42c6d3d8f9a68b32bf019fab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core_1_1_min_max_loc_result.html">MinMaxLocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2a77513b42c6d3d8f9a68b32bf019fab">minMaxLoc</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a2a77513b42c6d3d8f9a68b32bf019fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffbb5210d7b89d572bf95c20feb5a00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core_1_1_min_max_loc_result.html">MinMaxLocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4ffbb5210d7b89d572bf95c20feb5a00">minMaxLoc</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src)</td></tr>
<tr class="separator:a4ffbb5210d7b89d572bf95c20feb5a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7ec7592fac11c3ea1b049aaf93e9884f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7ec7592fac11c3ea1b049aaf93e9884f">SORT_EVERY_ROW</a> = 0</td></tr>
<tr class="separator:a7ec7592fac11c3ea1b049aaf93e9884f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8630fd16ab30ecf391e00a2a0d031b8d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8630fd16ab30ecf391e00a2a0d031b8d">SORT_EVERY_COLUMN</a> = 1</td></tr>
<tr class="separator:a8630fd16ab30ecf391e00a2a0d031b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ed7dd121188517e2372d0f45bbf085"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a13ed7dd121188517e2372d0f45bbf085">SORT_ASCENDING</a> = 0</td></tr>
<tr class="separator:a13ed7dd121188517e2372d0f45bbf085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae148d538488e0df4e884b6918c432327"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae148d538488e0df4e884b6918c432327">SORT_DESCENDING</a> = 16</td></tr>
<tr class="separator:ae148d538488e0df4e884b6918c432327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626f3ff74658f54136b963f214561667"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a626f3ff74658f54136b963f214561667">SVD_MODIFY_A</a> = 1</td></tr>
<tr class="separator:a626f3ff74658f54136b963f214561667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc266343b375968677fd23b2d140844"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#affc266343b375968677fd23b2d140844">SVD_NO_UV</a> = 2</td></tr>
<tr class="separator:affc266343b375968677fd23b2d140844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bccee19c21bf2e813c4409c0819e33"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a97bccee19c21bf2e813c4409c0819e33">SVD_FULL_UV</a> = 4</td></tr>
<tr class="separator:a97bccee19c21bf2e813c4409c0819e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e0eb67c3dab3873e3739b857612b86"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af7e0eb67c3dab3873e3739b857612b86">FILLED</a> = -1</td></tr>
<tr class="separator:af7e0eb67c3dab3873e3739b857612b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e1a540a681ff0c8b9c47aef279a60f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af2e1a540a681ff0c8b9c47aef279a60f">REDUCE_SUM</a> = 0</td></tr>
<tr class="separator:af2e1a540a681ff0c8b9c47aef279a60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e2005ddc6cfe8308a55a1252a5d55f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a09e2005ddc6cfe8308a55a1252a5d55f">REDUCE_AVG</a> = 1</td></tr>
<tr class="separator:a09e2005ddc6cfe8308a55a1252a5d55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fa60b83c36239a2dd4465a191532e7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a03fa60b83c36239a2dd4465a191532e7">REDUCE_MAX</a> = 2</td></tr>
<tr class="separator:a03fa60b83c36239a2dd4465a191532e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a075bfcc77682c67dcef57d7e40219c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0a075bfcc77682c67dcef57d7e40219c">REDUCE_MIN</a> = 3</td></tr>
<tr class="separator:a0a075bfcc77682c67dcef57d7e40219c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d972605929c29c07d245b061ba8fc78"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1d972605929c29c07d245b061ba8fc78">RNG_UNIFORM</a> = 0</td></tr>
<tr class="separator:a1d972605929c29c07d245b061ba8fc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f00949eaf56c0c04b39476e70bb25"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa64f00949eaf56c0c04b39476e70bb25">RNG_NORMAL</a> = 1</td></tr>
<tr class="separator:aa64f00949eaf56c0c04b39476e70bb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aeab3b925c6c40cf475fb39f7a8332e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5aeab3b925c6c40cf475fb39f7a8332e">PCA_DATA_AS_ROW</a> = 0</td></tr>
<tr class="separator:a5aeab3b925c6c40cf475fb39f7a8332e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3238daae8dab95190422e60bbd80222"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab3238daae8dab95190422e60bbd80222">PCA_DATA_AS_COL</a> = 1</td></tr>
<tr class="separator:ab3238daae8dab95190422e60bbd80222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7fddae89e8ffa0c268ab8ec29d757a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#add7fddae89e8ffa0c268ab8ec29d757a">PCA_USE_AVG</a> = 2</td></tr>
<tr class="separator:add7fddae89e8ffa0c268ab8ec29d757a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f93feabe44e4c2e62fc33daddb3e057"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> = 1</td></tr>
<tr class="separator:a8f93feabe44e4c2e62fc33daddb3e057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b6cafe67cb86f13fa99b3557761dc0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac5b6cafe67cb86f13fa99b3557761dc0">DFT_SCALE</a> = 2</td></tr>
<tr class="separator:ac5b6cafe67cb86f13fa99b3557761dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1d8d366d4b6a6a6ed8d2f60f95b8ee"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> = 4</td></tr>
<tr class="separator:adf1d8d366d4b6a6a6ed8d2f60f95b8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0910f497f735b83cbf02f40d8cbede98"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0910f497f735b83cbf02f40d8cbede98">DFT_COMPLEX_OUTPUT</a> = 16</td></tr>
<tr class="separator:a0910f497f735b83cbf02f40d8cbede98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afda64a7880e084d74eeb7d9ec520f5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5afda64a7880e084d74eeb7d9ec520f5">DFT_REAL_OUTPUT</a> = 32</td></tr>
<tr class="separator:a5afda64a7880e084d74eeb7d9ec520f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f190257e535e93b9e5d889d2a28897"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a45f190257e535e93b9e5d889d2a28897">DFT_COMPLEX_INPUT</a> = 64</td></tr>
<tr class="separator:a45f190257e535e93b9e5d889d2a28897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af8231d95e29adf18d44f8548fa24fa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9af8231d95e29adf18d44f8548fa24fa">DCT_INVERSE</a> = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a></td></tr>
<tr class="separator:a9af8231d95e29adf18d44f8548fa24fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cc5f0d908ec03cfa6215697d0b1ec5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a32cc5f0d908ec03cfa6215697d0b1ec5">DCT_ROWS</a> = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a></td></tr>
<tr class="separator:a32cc5f0d908ec03cfa6215697d0b1ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48da3791baeba76631263cc4735a5e2b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a48da3791baeba76631263cc4735a5e2b">Formatter_FMT_DEFAULT</a> = 0</td></tr>
<tr class="separator:a48da3791baeba76631263cc4735a5e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4f7c7ceaae8ef2298a5fe25d7abffd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8e4f7c7ceaae8ef2298a5fe25d7abffd">Formatter_FMT_MATLAB</a> = 1</td></tr>
<tr class="separator:a8e4f7c7ceaae8ef2298a5fe25d7abffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c92305f00527d5106fda4c4f58d743"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab2c92305f00527d5106fda4c4f58d743">Formatter_FMT_CSV</a> = 2</td></tr>
<tr class="separator:ab2c92305f00527d5106fda4c4f58d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0619036a1120a1e7a1ec51383d7a0ae5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0619036a1120a1e7a1ec51383d7a0ae5">Formatter_FMT_PYTHON</a> = 3</td></tr>
<tr class="separator:a0619036a1120a1e7a1ec51383d7a0ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c060b710e81d3a0dad34c2d6e5ab87"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab2c060b710e81d3a0dad34c2d6e5ab87">Formatter_FMT_NUMPY</a> = 4</td></tr>
<tr class="separator:ab2c060b710e81d3a0dad34c2d6e5ab87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929d06b5dc9dcd84fdf8789bd9027fae"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a929d06b5dc9dcd84fdf8789bd9027fae">Formatter_FMT_C</a> = 5</td></tr>
<tr class="separator:a929d06b5dc9dcd84fdf8789bd9027fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb35ab9b39df7c7938ae175ed2f8fa9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aafb35ab9b39df7c7938ae175ed2f8fa9">CMP_EQ</a> = 0</td></tr>
<tr class="separator:aafb35ab9b39df7c7938ae175ed2f8fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9553cd6444cd66b59239770008ba43"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7d9553cd6444cd66b59239770008ba43">CMP_GT</a> = 1</td></tr>
<tr class="separator:a7d9553cd6444cd66b59239770008ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcb799793788c85804511ba6666cefc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5fcb799793788c85804511ba6666cefc">CMP_GE</a> = 2</td></tr>
<tr class="separator:a5fcb799793788c85804511ba6666cefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2251b639494a07f88c553729a049ba"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4a2251b639494a07f88c553729a049ba">CMP_LT</a> = 3</td></tr>
<tr class="separator:a4a2251b639494a07f88c553729a049ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4595416c90061a9f3e8e8578609d346"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af4595416c90061a9f3e8e8578609d346">CMP_LE</a> = 4</td></tr>
<tr class="separator:af4595416c90061a9f3e8e8578609d346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb06e1dc203a84cc7fb959f25aa988c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aacb06e1dc203a84cc7fb959f25aa988c">CMP_NE</a> = 5</td></tr>
<tr class="separator:aacb06e1dc203a84cc7fb959f25aa988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700587c589e753b9b04bb2340ff4beac"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a700587c589e753b9b04bb2340ff4beac">BORDER_CONSTANT</a> = 0</td></tr>
<tr class="separator:a700587c589e753b9b04bb2340ff4beac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c183b655c10a86153ed017119e2bc9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a66c183b655c10a86153ed017119e2bc9">BORDER_REPLICATE</a> = 1</td></tr>
<tr class="separator:a66c183b655c10a86153ed017119e2bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d3cd361e61ac45a1c8f6a3f092022"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4b0d3cd361e61ac45a1c8f6a3f092022">BORDER_REFLECT</a> = 2</td></tr>
<tr class="separator:a4b0d3cd361e61ac45a1c8f6a3f092022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f61c3ce2dcf35434deee2be7a618db"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a84f61c3ce2dcf35434deee2be7a618db">BORDER_WRAP</a> = 3</td></tr>
<tr class="separator:a84f61c3ce2dcf35434deee2be7a618db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af68df90fc0017e1f292c65675ed688"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7af68df90fc0017e1f292c65675ed688">BORDER_REFLECT_101</a> = 4</td></tr>
<tr class="separator:a7af68df90fc0017e1f292c65675ed688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd0751a0136965d3caf57bfc43620e7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#afdd0751a0136965d3caf57bfc43620e7">BORDER_TRANSPARENT</a> = 5</td></tr>
<tr class="separator:afdd0751a0136965d3caf57bfc43620e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975e23c5e514e17326bc7a774c5762e7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a975e23c5e514e17326bc7a774c5762e7">BORDER_REFLECT101</a> = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7af68df90fc0017e1f292c65675ed688">BORDER_REFLECT_101</a></td></tr>
<tr class="separator:a975e23c5e514e17326bc7a774c5762e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a0c1c9c55be780c286221c91fa576f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af1a0c1c9c55be780c286221c91fa576f">BORDER_DEFAULT</a> = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7af68df90fc0017e1f292c65675ed688">BORDER_REFLECT_101</a></td></tr>
<tr class="separator:af1a0c1c9c55be780c286221c91fa576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaeecb4a62c6a427156d108e5926613"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aeaaeecb4a62c6a427156d108e5926613">BORDER_ISOLATED</a> = 16</td></tr>
<tr class="separator:aeaaeecb4a62c6a427156d108e5926613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80360b5754885776ef19e32a15ed7ec7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a80360b5754885776ef19e32a15ed7ec7">KMEANS_RANDOM_CENTERS</a> = 0</td></tr>
<tr class="separator:a80360b5754885776ef19e32a15ed7ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4117f740a37ee5e1476fd0ff0f62f5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aac4117f740a37ee5e1476fd0ff0f62f5">KMEANS_PP_CENTERS</a> = 2</td></tr>
<tr class="separator:aac4117f740a37ee5e1476fd0ff0f62f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb62ffc3700ae98bfb7c59b458ac8d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#affcb62ffc3700ae98bfb7c59b458ac8d">KMEANS_USE_INITIAL_LABELS</a> = 1</td></tr>
<tr class="separator:affcb62ffc3700ae98bfb7c59b458ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ebffb0f7b74f08d56f4effecd5fb97"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a87ebffb0f7b74f08d56f4effecd5fb97">StsOk</a> = 0</td></tr>
<tr class="separator:a87ebffb0f7b74f08d56f4effecd5fb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1c59badfb6808ab3d06592898ca37c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2a1c59badfb6808ab3d06592898ca37c">StsBackTrace</a> = -1</td></tr>
<tr class="separator:a2a1c59badfb6808ab3d06592898ca37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5f1abe2bee5aeaffce39b59092a99a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6e5f1abe2bee5aeaffce39b59092a99a">StsError</a> = -2</td></tr>
<tr class="separator:a6e5f1abe2bee5aeaffce39b59092a99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a59dbe205ad41a82f1dff92b9d781b0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a3a59dbe205ad41a82f1dff92b9d781b0">StsInternal</a> = -3</td></tr>
<tr class="separator:a3a59dbe205ad41a82f1dff92b9d781b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00b551945fc774ee77bc0a2a94ff77e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af00b551945fc774ee77bc0a2a94ff77e">StsNoMem</a> = -4</td></tr>
<tr class="separator:af00b551945fc774ee77bc0a2a94ff77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308005b761a4c33e8ef586efdbb07856"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a308005b761a4c33e8ef586efdbb07856">StsBadArg</a> = -5</td></tr>
<tr class="separator:a308005b761a4c33e8ef586efdbb07856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bae582bfa8df142ec143cd4bcc7af0a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7bae582bfa8df142ec143cd4bcc7af0a">StsBadFunc</a> = -6</td></tr>
<tr class="separator:a7bae582bfa8df142ec143cd4bcc7af0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f8f03d395287b9b8982b2ae4f68f8f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac7f8f03d395287b9b8982b2ae4f68f8f">StsNoConv</a> = -7</td></tr>
<tr class="separator:ac7f8f03d395287b9b8982b2ae4f68f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725085189b4e99d3277f7046479cb224"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a725085189b4e99d3277f7046479cb224">StsAutoTrace</a> = -8</td></tr>
<tr class="separator:a725085189b4e99d3277f7046479cb224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f416370667b50f0c3d090f10546ecc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af8f416370667b50f0c3d090f10546ecc">HeaderIsNull</a> = -9</td></tr>
<tr class="separator:af8f416370667b50f0c3d090f10546ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e863e84298ac8fe5cafbcf415b009"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a227e863e84298ac8fe5cafbcf415b009">BadImageSize</a> = -10</td></tr>
<tr class="separator:a227e863e84298ac8fe5cafbcf415b009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a63abaa22a9966c0d62a6d4290b9ca"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a82a63abaa22a9966c0d62a6d4290b9ca">BadOffset</a> = -11</td></tr>
<tr class="separator:a82a63abaa22a9966c0d62a6d4290b9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af545caa33eefb19f2fd9e9b1dba095fd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af545caa33eefb19f2fd9e9b1dba095fd">BadDataPtr</a> = -12</td></tr>
<tr class="separator:af545caa33eefb19f2fd9e9b1dba095fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe7cd59bc06420ee1199f68b94be785"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4fe7cd59bc06420ee1199f68b94be785">BadStep</a> = -13</td></tr>
<tr class="separator:a4fe7cd59bc06420ee1199f68b94be785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39e270b5929ebbc1968e63415d1edb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2f39e270b5929ebbc1968e63415d1edb">BadModelOrChSeq</a> = -14</td></tr>
<tr class="separator:a2f39e270b5929ebbc1968e63415d1edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac9f8df16a97fde65b91094d221f4b6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acac9f8df16a97fde65b91094d221f4b6">BadNumChannels</a> = -15</td></tr>
<tr class="separator:acac9f8df16a97fde65b91094d221f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59befab9a1534e2819c26495d8126596"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a59befab9a1534e2819c26495d8126596">BadNumChannel1U</a> = -16</td></tr>
<tr class="separator:a59befab9a1534e2819c26495d8126596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad344f40e4af2a06dcf625eeb207153a5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad344f40e4af2a06dcf625eeb207153a5">BadDepth</a> = -17</td></tr>
<tr class="separator:ad344f40e4af2a06dcf625eeb207153a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e699fdef4a45e2095486f9abf73438b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1e699fdef4a45e2095486f9abf73438b">BadAlphaChannel</a> = -18</td></tr>
<tr class="separator:a1e699fdef4a45e2095486f9abf73438b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8dd1f9927c6b14ee8d94b70d30c267"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aad8dd1f9927c6b14ee8d94b70d30c267">BadOrder</a> = -19</td></tr>
<tr class="separator:aad8dd1f9927c6b14ee8d94b70d30c267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0a330a3a094c2c7ef361d0f5fda083"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adc0a330a3a094c2c7ef361d0f5fda083">BadOrigin</a> = -20</td></tr>
<tr class="separator:adc0a330a3a094c2c7ef361d0f5fda083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d0df8a6af75ffe78758fabec27ede0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a23d0df8a6af75ffe78758fabec27ede0">BadAlign</a> = -21</td></tr>
<tr class="separator:a23d0df8a6af75ffe78758fabec27ede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b021e176d5c085bc2f9c5ce2782f4c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab5b021e176d5c085bc2f9c5ce2782f4c">BadCallBack</a> = -22</td></tr>
<tr class="separator:ab5b021e176d5c085bc2f9c5ce2782f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4099ba25e4452e771368f1c5794a85"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acd4099ba25e4452e771368f1c5794a85">BadTileSize</a> = -23</td></tr>
<tr class="separator:acd4099ba25e4452e771368f1c5794a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e832cb36c7e2b33ede4edfa8f8cff7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a38e832cb36c7e2b33ede4edfa8f8cff7">BadCOI</a> = -24</td></tr>
<tr class="separator:a38e832cb36c7e2b33ede4edfa8f8cff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a1eadb1868f63168be0958ecb7c035"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a78a1eadb1868f63168be0958ecb7c035">BadROISize</a> = -25</td></tr>
<tr class="separator:a78a1eadb1868f63168be0958ecb7c035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f60655f81f73453705d6c7005a3630e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5f60655f81f73453705d6c7005a3630e">MaskIsTiled</a> = -26</td></tr>
<tr class="separator:a5f60655f81f73453705d6c7005a3630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaef2c5c0c6752a73545331647b4a1d0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#afaef2c5c0c6752a73545331647b4a1d0">StsNullPtr</a> = -27</td></tr>
<tr class="separator:afaef2c5c0c6752a73545331647b4a1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45db4d7bb37573483849be45aae65027"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a45db4d7bb37573483849be45aae65027">StsVecLengthErr</a> = -28</td></tr>
<tr class="separator:a45db4d7bb37573483849be45aae65027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ccc15d81698805573bd4ce22249ac5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af7ccc15d81698805573bd4ce22249ac5">StsFilterStructContentErr</a> = -29</td></tr>
<tr class="separator:af7ccc15d81698805573bd4ce22249ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1169b77abadeab66cd27270e29819088"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1169b77abadeab66cd27270e29819088">StsKernelStructContentErr</a> = -30</td></tr>
<tr class="separator:a1169b77abadeab66cd27270e29819088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc8efce1d3f0fa221c9e252e54aa7f8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a3cc8efce1d3f0fa221c9e252e54aa7f8">StsFilterOffsetErr</a> = -31</td></tr>
<tr class="separator:a3cc8efce1d3f0fa221c9e252e54aa7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2762151ab18194ce60933d1fc9622866"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2762151ab18194ce60933d1fc9622866">StsBadSize</a> = -201</td></tr>
<tr class="separator:a2762151ab18194ce60933d1fc9622866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e84ef1c6f20121c116b4d52222b145d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4e84ef1c6f20121c116b4d52222b145d">StsDivByZero</a> = -202</td></tr>
<tr class="separator:a4e84ef1c6f20121c116b4d52222b145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebdc1721334a2a0a6e515a09fe44bfd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2ebdc1721334a2a0a6e515a09fe44bfd">StsInplaceNotSupported</a> = -203</td></tr>
<tr class="separator:a2ebdc1721334a2a0a6e515a09fe44bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c50059821dedbbaeb6fc4237958134"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a24c50059821dedbbaeb6fc4237958134">StsObjectNotFound</a> = -204</td></tr>
<tr class="separator:a24c50059821dedbbaeb6fc4237958134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6b164f5bd5bec666da74487b026da"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adac6b164f5bd5bec666da74487b026da">StsUnmatchedFormats</a> = -205</td></tr>
<tr class="separator:adac6b164f5bd5bec666da74487b026da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6ed35a1599c98ddf7b49432761fc35"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5a6ed35a1599c98ddf7b49432761fc35">StsBadFlag</a> = -206</td></tr>
<tr class="separator:a5a6ed35a1599c98ddf7b49432761fc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2453475597c5d96fca7570acf7efff"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7d2453475597c5d96fca7570acf7efff">StsBadPoint</a> = -207</td></tr>
<tr class="separator:a7d2453475597c5d96fca7570acf7efff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a9a9c25694b3d8b9b448a42a384c02"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ab8a9a9c25694b3d8b9b448a42a384c02">StsBadMask</a> = -208</td></tr>
<tr class="separator:ab8a9a9c25694b3d8b9b448a42a384c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7646dae49467f3c245e3ee9f1743627"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af7646dae49467f3c245e3ee9f1743627">StsUnmatchedSizes</a> = -209</td></tr>
<tr class="separator:af7646dae49467f3c245e3ee9f1743627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e98b3efe48cfd5617c2445b9a2c10d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae0e98b3efe48cfd5617c2445b9a2c10d">StsUnsupportedFormat</a> = -210</td></tr>
<tr class="separator:ae0e98b3efe48cfd5617c2445b9a2c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa5cb32856846531c49ea21dcfa3c27"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a2aa5cb32856846531c49ea21dcfa3c27">StsOutOfRange</a> = -211</td></tr>
<tr class="separator:a2aa5cb32856846531c49ea21dcfa3c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102404cc7a51267bc98cd01e014f0839"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a102404cc7a51267bc98cd01e014f0839">StsParseError</a> = -212</td></tr>
<tr class="separator:a102404cc7a51267bc98cd01e014f0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eef32d20fd01223cdf21369b147826"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a31eef32d20fd01223cdf21369b147826">StsNotImplemented</a> = -213</td></tr>
<tr class="separator:a31eef32d20fd01223cdf21369b147826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e17e0d1d4165b613607d2499e8c761"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a64e17e0d1d4165b613607d2499e8c761">StsBadMemBlock</a> = -214</td></tr>
<tr class="separator:a64e17e0d1d4165b613607d2499e8c761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade2dfd134bf7c78fba3484e46385180"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aade2dfd134bf7c78fba3484e46385180">StsAssert</a> = -215</td></tr>
<tr class="separator:aade2dfd134bf7c78fba3484e46385180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87daf0064bff70dba58e53b53c27c04c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a87daf0064bff70dba58e53b53c27c04c">GpuNotSupported</a> = -216</td></tr>
<tr class="separator:a87daf0064bff70dba58e53b53c27c04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae63e9c65e9be5f1752487f627d4134"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0ae63e9c65e9be5f1752487f627d4134">GpuApiCallError</a> = -217</td></tr>
<tr class="separator:a0ae63e9c65e9be5f1752487f627d4134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68185da56861e861b720ff4bf0bce610"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a68185da56861e861b720ff4bf0bce610">OpenGlNotSupported</a> = -218</td></tr>
<tr class="separator:a68185da56861e861b720ff4bf0bce610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1782518177fa5ba7c09858d7d985eaf"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad1782518177fa5ba7c09858d7d985eaf">OpenGlApiCallError</a> = -219</td></tr>
<tr class="separator:ad1782518177fa5ba7c09858d7d985eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184f83567cc447e5362c20513b06927c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a184f83567cc447e5362c20513b06927c">OpenCLApiCallError</a> = -220</td></tr>
<tr class="separator:a184f83567cc447e5362c20513b06927c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce3a5edd35ed5cb39215ffc21602572"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6ce3a5edd35ed5cb39215ffc21602572">OpenCLDoubleNotSupported</a> = -221</td></tr>
<tr class="separator:a6ce3a5edd35ed5cb39215ffc21602572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a10885db215b6c26053969e9e0d25f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a91a10885db215b6c26053969e9e0d25f">OpenCLInitError</a> = -222</td></tr>
<tr class="separator:a91a10885db215b6c26053969e9e0d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79707bfb5813ac9d32eb66d2f8bfe41d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a79707bfb5813ac9d32eb66d2f8bfe41d">OpenCLNoAMDBlasFft</a> = -223</td></tr>
<tr class="separator:a79707bfb5813ac9d32eb66d2f8bfe41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac314069d421dc66045e72df3188bac51"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac314069d421dc66045e72df3188bac51">Param_INT</a> = 0</td></tr>
<tr class="separator:ac314069d421dc66045e72df3188bac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5926bdb4546b4e79e18bbccc5ab9207"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad5926bdb4546b4e79e18bbccc5ab9207">Param_BOOLEAN</a> = 1</td></tr>
<tr class="separator:ad5926bdb4546b4e79e18bbccc5ab9207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b828006eb4044dfa476774c0b8386e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a91b828006eb4044dfa476774c0b8386e">Param_REAL</a> = 2</td></tr>
<tr class="separator:a91b828006eb4044dfa476774c0b8386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fda03fcbb2af9c682b20614f3a20eb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a58fda03fcbb2af9c682b20614f3a20eb">Param_STRING</a> = 3</td></tr>
<tr class="separator:a58fda03fcbb2af9c682b20614f3a20eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2f40423c1703fe1fa71578549cfd46"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1a2f40423c1703fe1fa71578549cfd46">Param_MAT</a> = 4</td></tr>
<tr class="separator:a1a2f40423c1703fe1fa71578549cfd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bcc772cc68426525e1706e83ff2849"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a19bcc772cc68426525e1706e83ff2849">Param_MAT_VECTOR</a> = 5</td></tr>
<tr class="separator:a19bcc772cc68426525e1706e83ff2849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72246e8f544e345565ade9ac02e0823b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a72246e8f544e345565ade9ac02e0823b">Param_ALGORITHM</a> = 6</td></tr>
<tr class="separator:a72246e8f544e345565ade9ac02e0823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ad996cfe1b0143b58853c402ba98cf"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a12ad996cfe1b0143b58853c402ba98cf">Param_FLOAT</a> = 7</td></tr>
<tr class="separator:a12ad996cfe1b0143b58853c402ba98cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7873b9bb39cee0a9e25181a5831180"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acb7873b9bb39cee0a9e25181a5831180">Param_UNSIGNED_INT</a> = 8</td></tr>
<tr class="separator:acb7873b9bb39cee0a9e25181a5831180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bdb5f4e3b7f905e9db8d564e58c473"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a10bdb5f4e3b7f905e9db8d564e58c473">Param_UINT64</a> = 9</td></tr>
<tr class="separator:a10bdb5f4e3b7f905e9db8d564e58c473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bfb58c5091c296da87882a8ab7d5d0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a86bfb58c5091c296da87882a8ab7d5d0">Param_UCHAR</a> = 11</td></tr>
<tr class="separator:a86bfb58c5091c296da87882a8ab7d5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d264976869ab39443cc405688501a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9f6d264976869ab39443cc405688501a">Param_SCALAR</a> = 12</td></tr>
<tr class="separator:a9f6d264976869ab39443cc405688501a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca470ec0f6eec0aa32d5928878ce2d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a20ca470ec0f6eec0aa32d5928878ce2d">ROTATE_90_CLOCKWISE</a> = 0</td></tr>
<tr class="separator:a20ca470ec0f6eec0aa32d5928878ce2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19210e6d16815fe030e13f2f659b1e4b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a19210e6d16815fe030e13f2f659b1e4b">ROTATE_180</a> = 1</td></tr>
<tr class="separator:a19210e6d16815fe030e13f2f659b1e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725f2e773d906cfaf59b89297043a81e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a725f2e773d906cfaf59b89297043a81e">ROTATE_90_COUNTERCLOCKWISE</a> = 2</td></tr>
<tr class="separator:a725f2e773d906cfaf59b89297043a81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c84658333b1ac0ab22f1a83b316101d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8c84658333b1ac0ab22f1a83b316101d">NORM_INF</a> = 1</td></tr>
<tr class="separator:a8c84658333b1ac0ab22f1a83b316101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3135a85b8f7b3aed4fe65faf0e3855"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1a3135a85b8f7b3aed4fe65faf0e3855">NORM_L1</a> = 2</td></tr>
<tr class="separator:a1a3135a85b8f7b3aed4fe65faf0e3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2efcd606f3e551028491c4e4a68ef65"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad2efcd606f3e551028491c4e4a68ef65">NORM_L2</a> = 4</td></tr>
<tr class="separator:ad2efcd606f3e551028491c4e4a68ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6cb1b92ac96d437261561c4678feec"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a4d6cb1b92ac96d437261561c4678feec">NORM_L2SQR</a> = 5</td></tr>
<tr class="separator:a4d6cb1b92ac96d437261561c4678feec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60edae42a10d409c7bab8ec57f86a4d3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a60edae42a10d409c7bab8ec57f86a4d3">NORM_HAMMING</a> = 6</td></tr>
<tr class="separator:a60edae42a10d409c7bab8ec57f86a4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aad50a69f4a185f346a0f424b09c7f0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1aad50a69f4a185f346a0f424b09c7f0">NORM_HAMMING2</a> = 7</td></tr>
<tr class="separator:a1aad50a69f4a185f346a0f424b09c7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856046e45aea104486f595799757587c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a856046e45aea104486f595799757587c">NORM_TYPE_MASK</a> = 7</td></tr>
<tr class="separator:a856046e45aea104486f595799757587c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68354597e77350023f108276ae8f73e6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a68354597e77350023f108276ae8f73e6">NORM_RELATIVE</a> = 8</td></tr>
<tr class="separator:a68354597e77350023f108276ae8f73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8a50eed4210b018d2de2be2a2fc15"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1ab8a50eed4210b018d2de2be2a2fc15">NORM_MINMAX</a> = 32</td></tr>
<tr class="separator:a1ab8a50eed4210b018d2de2be2a2fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d04f03637669210aa721c1c395b586"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a95d04f03637669210aa721c1c395b586">COVAR_SCRAMBLED</a> = 0</td></tr>
<tr class="separator:a95d04f03637669210aa721c1c395b586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366a792fb02b7b4b34e86d360e3a00a0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a366a792fb02b7b4b34e86d360e3a00a0">COVAR_NORMAL</a> = 1</td></tr>
<tr class="separator:a366a792fb02b7b4b34e86d360e3a00a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263460aedbf841c64f7deadda74ab73b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a263460aedbf841c64f7deadda74ab73b">COVAR_USE_AVG</a> = 2</td></tr>
<tr class="separator:a263460aedbf841c64f7deadda74ab73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd7ef3bfc9ed9b902cdc57dad3e12c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad4cd7ef3bfc9ed9b902cdc57dad3e12c">COVAR_SCALE</a> = 4</td></tr>
<tr class="separator:ad4cd7ef3bfc9ed9b902cdc57dad3e12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34381817f95caf807b3d3ec4c0de008e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a34381817f95caf807b3d3ec4c0de008e">COVAR_ROWS</a> = 8</td></tr>
<tr class="separator:a34381817f95caf807b3d3ec4c0de008e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e0c7b926e5c8bf66afbd397713b093"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a32e0c7b926e5c8bf66afbd397713b093">COVAR_COLS</a> = 16</td></tr>
<tr class="separator:a32e0c7b926e5c8bf66afbd397713b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63de797ce590a1fd08b2a84a9af1c1b7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a63de797ce590a1fd08b2a84a9af1c1b7">DECOMP_LU</a> = 0</td></tr>
<tr class="separator:a63de797ce590a1fd08b2a84a9af1c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a16e6c8d4785ce2d627fcdae6aed83"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae8a16e6c8d4785ce2d627fcdae6aed83">DECOMP_SVD</a> = 1</td></tr>
<tr class="separator:ae8a16e6c8d4785ce2d627fcdae6aed83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cae8d8b4ac62063a788d8480949c51"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af3cae8d8b4ac62063a788d8480949c51">DECOMP_EIG</a> = 2</td></tr>
<tr class="separator:af3cae8d8b4ac62063a788d8480949c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f88f83a383fc769f459b8c7f7f4191"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53f88f83a383fc769f459b8c7f7f4191">DECOMP_CHOLESKY</a> = 3</td></tr>
<tr class="separator:a53f88f83a383fc769f459b8c7f7f4191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17bb61ddd8e1322016a91a9138f2d7e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae17bb61ddd8e1322016a91a9138f2d7e">DECOMP_QR</a> = 4</td></tr>
<tr class="separator:ae17bb61ddd8e1322016a91a9138f2d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430c9780821bb4cf861c919343c7d694"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a430c9780821bb4cf861c919343c7d694">DECOMP_NORMAL</a> = 16</td></tr>
<tr class="separator:a430c9780821bb4cf861c919343c7d694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052de9efb4bd2341abc5cfe493502b9e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a052de9efb4bd2341abc5cfe493502b9e">GEMM_1_T</a> = 1</td></tr>
<tr class="separator:a052de9efb4bd2341abc5cfe493502b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f892f16a85d857c8dfad9d2295541a9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6f892f16a85d857c8dfad9d2295541a9">GEMM_2_T</a> = 2</td></tr>
<tr class="separator:a6f892f16a85d857c8dfad9d2295541a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46e109d4b4e5645e297ede64eac368"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#acb46e109d4b4e5645e297ede64eac368">GEMM_3_T</a> = 4</td></tr>
<tr class="separator:acb46e109d4b4e5645e297ede64eac368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa1521db94d6b2363e09cf19f4b4ad1db"><td class="memItemLeft" align="right" valign="top">static readonly string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aa1521db94d6b2363e09cf19f4b4ad1db">VERSION</a> = getVersion()</td></tr>
<tr class="separator:aa1521db94d6b2363e09cf19f4b4ad1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b008794d77156d1de8d51088cf7ec72"><td class="memItemLeft" align="right" valign="top">static readonly string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0b008794d77156d1de8d51088cf7ec72">NATIVE_LIBRARY_NAME</a> = getNativeLibraryName()</td></tr>
<tr class="separator:a0b008794d77156d1de8d51088cf7ec72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbe6467510a016cebb4d5b7e2931ce6"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a6cbe6467510a016cebb4d5b7e2931ce6">VERSION_MAJOR</a> = getVersionMajorJ()</td></tr>
<tr class="separator:a6cbe6467510a016cebb4d5b7e2931ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5762a3a4848b435a55fbe44e57f830"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#abd5762a3a4848b435a55fbe44e57f830">VERSION_MINOR</a> = getVersionMinorJ()</td></tr>
<tr class="separator:abd5762a3a4848b435a55fbe44e57f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eaa0d0f0bf1e9ae6aa2d9355c44e1f"><td class="memItemLeft" align="right" valign="top">static readonly int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac4eaa0d0f0bf1e9ae6aa2d9355c44e1f">VERSION_REVISION</a> = getVersionRevisionJ()</td></tr>
<tr class="separator:ac4eaa0d0f0bf1e9ae6aa2d9355c44e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85feb234beabc20a52fb41cf7e4ad0eb"><td class="memItemLeft" align="right" valign="top">static readonly string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a85feb234beabc20a52fb41cf7e4ad0eb">VERSION_STATUS</a> = getVersionStatusJ()</td></tr>
<tr class="separator:a85feb234beabc20a52fb41cf7e4ad0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8772157d70a4569a0af64ed641819dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8772157d70a4569a0af64ed641819dcd">&#9670;&nbsp;</a></span>absdiff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.absdiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element absolute difference between two arrays or between an array and a scalar.</p>
<p>The function cv::absdiff calculates: Absolute difference between two arrays when they have the same size and type: (\texttt{dst}(I) = \texttt{saturate} (| \texttt{src1}(I) - \texttt{src2}(I)|)) Absolute difference between an array and a scalar when the second array is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has as many elements as the number of channels in {code src1}: (\texttt{dst}(I) = \texttt{saturate} (| \texttt{src1}(I) - \texttt{src2} |)) Absolute difference between a scalar and an array when the first array is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has as many elements as the number of channels in {code src2}: (\texttt{dst}(I) = \texttt{saturate} (| \texttt{src1} - \texttt{src2}(I) |)) where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. <b>Note:</b> Saturation is not applied when the arrays have the depth CV_32S. You may even get a negative value in the case of overflow. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and type as input arrays. SEE: cv::abs(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;) </p>

</div>
</div>
<a id="aca4dedc6e51c989d3fb1af7083239e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4dedc6e51c989d3fb1af7083239e25">&#9670;&nbsp;</a></span>absdiff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.absdiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb84c30ae0850e136da2668255978958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb84c30ae0850e136da2668255978958">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element sum of two arrays or an array and a scalar.</p>
<p>The function add calculates: </p><ul>
<li>
Sum of two arrays when both input arrays have the same size and the same number of channels: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) + \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Sum of an array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) + \texttt{src2} ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Sum of a scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1} + \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0) where {code I} is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.  </li>
</ul>
<p>The first function in the list above can be replaced with matrix expressions: <code> dst = src1 + src2; dst += src1; // equivalent to add(dst, src1, dst); </code> The input arrays and the output array can all have the same or different depths. For example, you can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit floating-point array. Depth of the output array is determined by the dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case, the output array will have the same depth as the input array, be it src1, src2 or both. <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and number of channels as the input array(s); the depth is defined by dtype or src1/src2. param mask optional operation mask - 8-bit single channel array, that specifies elements of the output array to be changed. param dtype optional depth of the output array (see the discussion below). SEE: subtract, addWeighted, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="ae8f0d00ed2e9c8fbd359b696c6562530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f0d00ed2e9c8fbd359b696c6562530">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element sum of two arrays or an array and a scalar.</p>
<p>The function add calculates: </p><ul>
<li>
Sum of two arrays when both input arrays have the same size and the same number of channels: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) + \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Sum of an array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) + \texttt{src2} ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Sum of a scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1} + \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0) where {code I} is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.  </li>
</ul>
<p>The first function in the list above can be replaced with matrix expressions: <code> dst = src1 + src2; dst += src1; // equivalent to add(dst, src1, dst); </code> The input arrays and the output array can all have the same or different depths. For example, you can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit floating-point array. Depth of the output array is determined by the dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case, the output array will have the same depth as the input array, be it src1, src2 or both. <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and number of channels as the input array(s); the depth is defined by dtype or src1/src2. param mask optional operation mask - 8-bit single channel array, that specifies elements of the output array to be changed. SEE: subtract, addWeighted, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a46e09cec72e7de408fcbf8c03d234358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e09cec72e7de408fcbf8c03d234358">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element sum of two arrays or an array and a scalar.</p>
<p>The function add calculates: </p><ul>
<li>
Sum of two arrays when both input arrays have the same size and the same number of channels: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) + \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Sum of an array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) + \texttt{src2} ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Sum of a scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1} + \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0) where {code I} is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.  </li>
</ul>
<p>The first function in the list above can be replaced with matrix expressions: <code> dst = src1 + src2; dst += src1; // equivalent to add(dst, src1, dst); </code> The input arrays and the output array can all have the same or different depths. For example, you can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit floating-point array. Depth of the output array is determined by the dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case, the output array will have the same depth as the input array, be it src1, src2 or both. <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and number of channels as the input array(s); the depth is defined by dtype or src1/src2. output array to be changed. SEE: subtract, addWeighted, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a907cc6fca9b0985285555319c1268872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907cc6fca9b0985285555319c1268872">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a171698cecdb4b0d75eb92d3e1a46dc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171698cecdb4b0d75eb92d3e1a46dc5c">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a464f532e295d84dfba84aab3e8d1600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464f532e295d84dfba84aab3e8d1600a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1623398b4f1a7c4990823fb02e7f1d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1623398b4f1a7c4990823fb02e7f1d62">&#9670;&nbsp;</a></span>addSamplesDataSearchPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.addSamplesDataSearchPath </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override search data path by adding new search location</p>
<p>Use this only to override default behavior Passed paths are used in LIFO order.</p>
<p>param path Path to used samples data </p>

</div>
</div>
<a id="aa1e3269bf977bd4ca665470c099a4c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e3269bf977bd4ca665470c099a4c1e">&#9670;&nbsp;</a></span>addSamplesDataSearchSubDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.addSamplesDataSearchSubDirectory </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>subdir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append samples search data sub directory</p>
<p>General usage is to add OpenCV modules name ({code &lt;opencv_contrib&gt;/modules/&lt;name&gt;/samples/data} -&gt; {code &lt;name&gt;/samples/data} + {code modules/&lt;name&gt;/samples/data}). Passed subdirectories are used in LIFO order.</p>
<p>param subdir samples data sub directory </p>

</div>
</div>
<a id="a24112e235aa55c377bff9129ea365875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24112e235aa55c377bff9129ea365875">&#9670;&nbsp;</a></span>addWeighted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.addWeighted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the weighted sum of two arrays.</p>
<p>The function addWeighted calculates the weighted sum of two arrays as follows: (\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} + \texttt{src2} (I)* \texttt{beta} + \texttt{gamma} )) where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The function can be replaced with a matrix expression: <code> dst = src1*alpha + src2*beta + gamma; </code> <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param alpha weight of the first array elements. param src2 second input array of the same size and channel number as src1. param beta weight of the second array elements. param gamma scalar added to each sum. param dst output array that has the same size and number of channels as the input arrays. param dtype optional depth of the output array; when both input arrays have the same depth, dtype can be set to -1, which will be equivalent to src1.depth(). SEE: add, subtract, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="af9970941c8dd3a91a19fb71c650ef424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9970941c8dd3a91a19fb71c650ef424">&#9670;&nbsp;</a></span>addWeighted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.addWeighted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the weighted sum of two arrays.</p>
<p>The function addWeighted calculates the weighted sum of two arrays as follows: (\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} + \texttt{src2} (I)* \texttt{beta} + \texttt{gamma} )) where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The function can be replaced with a matrix expression: <code> dst = src1*alpha + src2*beta + gamma; </code> <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param alpha weight of the first array elements. param src2 second input array of the same size and channel number as src1. param beta weight of the second array elements. param gamma scalar added to each sum. param dst output array that has the same size and number of channels as the input arrays. can be set to -1, which will be equivalent to src1.depth(). SEE: add, subtract, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a4d17b8b64777812a0c343ed50ab76379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d17b8b64777812a0c343ed50ab76379">&#9670;&nbsp;</a></span>batchDistance() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.batchDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>crosscheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>naive nearest neighbor finder</p>
<p>see <a href="http://en.wikipedia.org/wiki/Nearest_neighbor_search">http://en.wikipedia.org/wiki/Nearest_neighbor_search</a> TODO: document param src1 automatically generated param src2 automatically generated param dist automatically generated param dtype automatically generated param nidx automatically generated param normType automatically generated param K automatically generated param mask automatically generated param update automatically generated param crosscheck automatically generated </p>

</div>
</div>
<a id="a848801f38e3bc9ca99d462e4cf985556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848801f38e3bc9ca99d462e4cf985556">&#9670;&nbsp;</a></span>batchDistance() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.batchDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>naive nearest neighbor finder</p>
<p>see <a href="http://en.wikipedia.org/wiki/Nearest_neighbor_search">http://en.wikipedia.org/wiki/Nearest_neighbor_search</a> TODO: document param src1 automatically generated param src2 automatically generated param dist automatically generated param dtype automatically generated param nidx automatically generated param normType automatically generated param K automatically generated param mask automatically generated param update automatically generated </p>

</div>
</div>
<a id="a7fca93c1f3e8adcf047e7a923ccf365d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fca93c1f3e8adcf047e7a923ccf365d">&#9670;&nbsp;</a></span>batchDistance() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.batchDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>naive nearest neighbor finder</p>
<p>see <a href="http://en.wikipedia.org/wiki/Nearest_neighbor_search">http://en.wikipedia.org/wiki/Nearest_neighbor_search</a> TODO: document param src1 automatically generated param src2 automatically generated param dist automatically generated param dtype automatically generated param nidx automatically generated param normType automatically generated param K automatically generated param mask automatically generated </p>

</div>
</div>
<a id="a213378a4d3f6650c264a53a42ffe5a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213378a4d3f6650c264a53a42ffe5a80">&#9670;&nbsp;</a></span>batchDistance() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.batchDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>naive nearest neighbor finder</p>
<p>see <a href="http://en.wikipedia.org/wiki/Nearest_neighbor_search">http://en.wikipedia.org/wiki/Nearest_neighbor_search</a> TODO: document param src1 automatically generated param src2 automatically generated param dist automatically generated param dtype automatically generated param nidx automatically generated param normType automatically generated param K automatically generated </p>

</div>
</div>
<a id="a9b224c5ecb8e3213283f01e9926c8117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b224c5ecb8e3213283f01e9926c8117">&#9670;&nbsp;</a></span>batchDistance() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.batchDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>naive nearest neighbor finder</p>
<p>see <a href="http://en.wikipedia.org/wiki/Nearest_neighbor_search">http://en.wikipedia.org/wiki/Nearest_neighbor_search</a> TODO: document param src1 automatically generated param src2 automatically generated param dist automatically generated param dtype automatically generated param nidx automatically generated param normType automatically generated </p>

</div>
</div>
<a id="ab75e8158f12b844ada2d78021e1e3384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75e8158f12b844ada2d78021e1e3384">&#9670;&nbsp;</a></span>batchDistance() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.batchDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>nidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>naive nearest neighbor finder</p>
<p>see <a href="http://en.wikipedia.org/wiki/Nearest_neighbor_search">http://en.wikipedia.org/wiki/Nearest_neighbor_search</a> TODO: document param src1 automatically generated param src2 automatically generated param dist automatically generated param dtype automatically generated param nidx automatically generated </p>

</div>
</div>
<a id="afb4fe32250e9a646f60a6eed57d5c3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4fe32250e9a646f60a6eed57d5c3eb">&#9670;&nbsp;</a></span>bitwise_and() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes bitwise conjunction of the two arrays (dst = src1 &amp; src2) Calculates the per-element bit-wise conjunction of two arrays or an array and a scalar.</p>
<p>The function cv::bitwise_and calculates the per-element bit-wise logical conjunction for: Two arrays when src1 and src2 have the same size: (\texttt{dst} (I) = \texttt{src1} (I) \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) An array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst} (I) = \texttt{src1} (I) \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0) A scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst} (I) = \texttt{src1} \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and type as the input arrays. param mask optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="a66e46e854142100571779100fcbe9a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e46e854142100571779100fcbe9a78">&#9670;&nbsp;</a></span>bitwise_and() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes bitwise conjunction of the two arrays (dst = src1 &amp; src2) Calculates the per-element bit-wise conjunction of two arrays or an array and a scalar.</p>
<p>The function cv::bitwise_and calculates the per-element bit-wise logical conjunction for: Two arrays when src1 and src2 have the same size: (\texttt{dst} (I) = \texttt{src1} (I) \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) An array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst} (I) = \texttt{src1} (I) \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0) A scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst} (I) = \texttt{src1} \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and type as the input arrays. specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="abb488f17edfd0e2ec9dbf0324a87cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb488f17edfd0e2ec9dbf0324a87cbc3">&#9670;&nbsp;</a></span>bitwise_not() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts every bit of an array.</p>
<p>The function cv::bitwise_not calculates per-element bit-wise inversion of the input array: (\texttt{dst} (I) = \neg \texttt{src} (I)) In case of a floating-point input array, its machine-specific bit representation (usually IEEE754-compliant) is used for the operation. In case of multi-channel arrays, each channel is processed independently. param src input array. param dst output array that has the same size and type as the input array. param mask optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="ad2a0e3912aac1f874370eb9b2fd26b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a0e3912aac1f874370eb9b2fd26b22">&#9670;&nbsp;</a></span>bitwise_not() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts every bit of an array.</p>
<p>The function cv::bitwise_not calculates per-element bit-wise inversion of the input array: (\texttt{dst} (I) = \neg \texttt{src} (I)) In case of a floating-point input array, its machine-specific bit representation (usually IEEE754-compliant) is used for the operation. In case of multi-channel arrays, each channel is processed independently. param src input array. param dst output array that has the same size and type as the input array. specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="a71cf61e15c074b955150392753b501b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cf61e15c074b955150392753b501b7">&#9670;&nbsp;</a></span>bitwise_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element bit-wise disjunction of two arrays or an array and a scalar.</p>
<p>The function cv::bitwise_or calculates the per-element bit-wise logical disjunction for: Two arrays when src1 and src2 have the same size: (\texttt{dst} (I) = \texttt{src1} (I) \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) An array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst} (I) = \texttt{src1} (I) \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0) A scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst} (I) = \texttt{src1} \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and type as the input arrays. param mask optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="a37b7e74e15789fbfa3a88a2fa77a33b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b7e74e15789fbfa3a88a2fa77a33b9">&#9670;&nbsp;</a></span>bitwise_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element bit-wise disjunction of two arrays or an array and a scalar.</p>
<p>The function cv::bitwise_or calculates the per-element bit-wise logical disjunction for: Two arrays when src1 and src2 have the same size: (\texttt{dst} (I) = \texttt{src1} (I) \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) An array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst} (I) = \texttt{src1} (I) \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0) A scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst} (I) = \texttt{src1} \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and type as the input arrays. specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="aa8fbea037a592d0a26095ad6148ee6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fbea037a592d0a26095ad6148ee6d4">&#9670;&nbsp;</a></span>bitwise_xor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element bit-wise "exclusive or" operation on two arrays or an array and a scalar.</p>
<p>The function cv::bitwise_xor calculates the per-element bit-wise logical "exclusive-or" operation for: Two arrays when src1 and src2 have the same size: (\texttt{dst} (I) = \texttt{src1} (I) \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) An array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst} (I) = \texttt{src1} (I) \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0) A scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst} (I) = \texttt{src1} \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the 2nd and 3rd cases above, the scalar is first converted to the array type. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and type as the input arrays. param mask optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="a8bc746329eab28f3c6e428dae7fbb48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc746329eab28f3c6e428dae7fbb48a">&#9670;&nbsp;</a></span>bitwise_xor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.bitwise_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element bit-wise "exclusive or" operation on two arrays or an array and a scalar.</p>
<p>The function cv::bitwise_xor calculates the per-element bit-wise logical "exclusive-or" operation for: Two arrays when src1 and src2 have the same size: (\texttt{dst} (I) = \texttt{src1} (I) \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) An array and a scalar when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst} (I) = \texttt{src1} (I) \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0) A scalar and an array when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst} (I) = \texttt{src1} \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0) In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the 2nd and 3rd cases above, the scalar is first converted to the array type. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array that has the same size and type as the input arrays. specifies elements of the output array to be changed. </p>

</div>
</div>
<a id="a6aa419e3c9fb18a0ce0a891d3170e01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa419e3c9fb18a0ce0a891d3170e01b">&#9670;&nbsp;</a></span>borderInterpolate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.borderInterpolate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the source location of an extrapolated pixel.</p>
<p>The function computes and returns the coordinate of a donor pixel corresponding to the specified extrapolated pixel when using the specified extrapolation border mode. For example, if you use cv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and want to compute value of the "virtual" pixel <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>(-5, 100) in a floating-point image img , it looks like: <code> float val = img.at&lt;float&gt;(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101), borderInterpolate(-5, img.cols, cv::BORDER_WRAP)); </code> Normally, the function is not called directly. It is used inside filtering functions and also in copyMakeBorder. param p 0-based coordinate of the extrapolated pixel along one of the axes, likely &lt;0 or &gt;= len param len Length of the array along the corresponding axis. param borderType Border type, one of the #BorderTypes, except for <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#afdd0751a0136965d3caf57bfc43620e7">BORDER_TRANSPARENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aeaaeecb4a62c6a427156d108e5926613">BORDER_ISOLATED</a> . When borderType==<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a700587c589e753b9b04bb2340ff4beac">BORDER_CONSTANT</a> , the function always returns -1, regardless of p and len.</p>
<p>SEE: copyMakeBorder return automatically generated </p>

</div>
</div>
<a id="a89874626e1f5ee355645d0ac862d2d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89874626e1f5ee355645d0ac862d2d00">&#9670;&nbsp;</a></span>calcCovarMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.calcCovarMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>covar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ctype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Note:</b> use <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a34381817f95caf807b3d3ec4c0de008e">COVAR_ROWS</a> or <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a32e0c7b926e5c8bf66afbd397713b093">COVAR_COLS</a> flag param samples samples stored as rows/columns of a single matrix. param covar output covariance matrix of the type ctype and square size. param mean input or output (depending on the flags) array as the average value of the input vectors. param flags operation flags as a combination of #CovarFlags param ctype type of the matrixl; it equals 'CV_64F' by default. </p>

</div>
</div>
<a id="acb92baaacd8ccacde0b85dc7fcdaca1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb92baaacd8ccacde0b85dc7fcdaca1f">&#9670;&nbsp;</a></span>calcCovarMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.calcCovarMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>covar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Note:</b> use <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a34381817f95caf807b3d3ec4c0de008e">COVAR_ROWS</a> or <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a32e0c7b926e5c8bf66afbd397713b093">COVAR_COLS</a> flag param samples samples stored as rows/columns of a single matrix. param covar output covariance matrix of the type ctype and square size. param mean input or output (depending on the flags) array as the average value of the input vectors. param flags operation flags as a combination of #CovarFlags </p>

</div>
</div>
<a id="a452013d3be5200c4c6cbb902bf1474b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452013d3be5200c4c6cbb902bf1474b9">&#9670;&nbsp;</a></span>cartToPolar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.cartToPolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>angleInDegrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the magnitude and angle of 2D vectors.</p>
<p>The function cv::cartToPolar calculates either the magnitude, angle, or both for every 2D vector (x(I),y(I)): (\begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array})</p>
<p>The angles are calculated with accuracy about 0.3 degrees. For the point (0,0), the angle is set to 0. param x array of x-coordinates; this must be a single-precision or double-precision floating-point array. param y array of y-coordinates, that must have the same size and same type as x. param magnitude output array of magnitudes of the same size and type as x. param angle output array of angles that has the same size and type as x; the angles are measured in radians (from 0 to 2*Pi) or in degrees (0 to 360 degrees). param angleInDegrees a flag, indicating whether the angles are measured in radians (which is by default), or in degrees. SEE: Sobel, Scharr </p>

</div>
</div>
<a id="a04e521af9d8f7fb8791f14d1a7f2f9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e521af9d8f7fb8791f14d1a7f2f9ff">&#9670;&nbsp;</a></span>cartToPolar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.cartToPolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the magnitude and angle of 2D vectors.</p>
<p>The function cv::cartToPolar calculates either the magnitude, angle, or both for every 2D vector (x(I),y(I)): (\begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array})</p>
<p>The angles are calculated with accuracy about 0.3 degrees. For the point (0,0), the angle is set to 0. param x array of x-coordinates; this must be a single-precision or double-precision floating-point array. param y array of y-coordinates, that must have the same size and same type as x. param magnitude output array of magnitudes of the same size and type as x. param angle output array of angles that has the same size and type as x; the angles are measured in radians (from 0 to 2*Pi) or in degrees (0 to 360 degrees). in radians (which is by default), or in degrees. SEE: Sobel, Scharr </p>

</div>
</div>
<a id="ac6ad8c5fc4897f2fa64931303ac044d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ad8c5fc4897f2fa64931303ac044d7">&#9670;&nbsp;</a></span>checkRange() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.checkRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quiet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks every element of an input array for invalid values.</p>
<p>The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt; </p><ul>
<li>
DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and maxVal. In case of multi-channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the function either returns false (when quiet=true) or throws an exception. param a input array. param quiet a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception. elements. param minVal inclusive lower boundary of valid values range. param maxVal exclusive upper boundary of valid values range.  </li>
</ul>
<p>return automatically generated </p>

</div>
</div>
<a id="a5f7ef1abcd7a4bfbdd2c5e528a5a813d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7ef1abcd7a4bfbdd2c5e528a5a813d">&#9670;&nbsp;</a></span>checkRange() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.checkRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quiet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks every element of an input array for invalid values.</p>
<p>The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt; </p><ul>
<li>
DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and maxVal. In case of multi-channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the function either returns false (when quiet=true) or throws an exception. param a input array. param quiet a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception. elements. param minVal inclusive lower boundary of valid values range.  </li>
</ul>
<p>return automatically generated </p>

</div>
</div>
<a id="a362d57b7056f4aa502e54ad1bd4c7a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362d57b7056f4aa502e54ad1bd4c7a7e">&#9670;&nbsp;</a></span>checkRange() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.checkRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quiet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks every element of an input array for invalid values.</p>
<p>The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt; </p><ul>
<li>
DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and maxVal. In case of multi-channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the function either returns false (when quiet=true) or throws an exception. param a input array. param quiet a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception. elements.  </li>
</ul>
<p>return automatically generated </p>

</div>
</div>
<a id="a9f105a090f2dee77258563865e185b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f105a090f2dee77258563865e185b61">&#9670;&nbsp;</a></span>checkRange() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.checkRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks every element of an input array for invalid values.</p>
<p>The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt; </p><ul>
<li>
DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and maxVal. In case of multi-channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the function either returns false (when quiet=true) or throws an exception. param a input array. are out of range or they throw an exception. elements.  </li>
</ul>
<p>return automatically generated </p>

</div>
</div>
<a id="a09b5b4761e2510828070520b5056506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b5b4761e2510828070520b5056506b">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the per-element comparison of two arrays or an array and scalar value.</p>
<p>The function compares: Elements of two arrays when src1 and src2 have the same size: (\texttt{dst} (I) = \texttt{src1} (I) \,\texttt{cmpop}\, \texttt{src2} (I)) Elements of src1 with a scalar src2 when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has a single element: (\texttt{dst} (I) = \texttt{src1}(I) \,\texttt{cmpop}\, \texttt{src2}) src1 with elements of src2 when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has a single element: (\texttt{dst} (I) = \texttt{src1} \,\texttt{cmpop}\, \texttt{src2} (I)) When the comparison result is true, the corresponding element of output array is set to 255. The comparison operations can be replaced with the equivalent matrix expressions: <code> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst1 = src1 &gt;= src2; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst2 = src1 &lt; 8; ... </code> param src1 first input array or a scalar; when it is an array, it must have a single channel. param src2 second input array or a scalar; when it is an array, it must have a single channel. param dst output array of type ref CV_8U that has the same size and the same number of channels as the input arrays. param cmpop a flag, that specifies correspondence between the arrays (cv::CmpTypes) SEE: checkRange, min, max, threshold </p>

</div>
</div>
<a id="a1f618d3e76c35d5b34958a61418c377e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f618d3e76c35d5b34958a61418c377e">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53e265bc55b98613ec01f6b3dc11db5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e265bc55b98613ec01f6b3dc11db5a">&#9670;&nbsp;</a></span>completeSymm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.completeSymm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerToUpper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the lower or the upper half of a square matrix to its another half.</p>
<p>The function cv::completeSymm copies the lower or the upper half of a square matrix to its another half. The matrix diagonal remains unchanged: </p><ul>
<li>
(\texttt{m}_{ij}=\texttt{m}_{ji}) for (i &gt; j) if lowerToUpper=false  </li>
<li>
(\texttt{m}_{ij}=\texttt{m}_{ji}) for (i &lt; j) if lowerToUpper=true  </li>
</ul>
<p>param m input-output floating-point square matrix. param lowerToUpper operation flag; if true, the lower half is copied to the upper half. Otherwise, the upper half is copied to the lower half. SEE: flip, transpose </p>

</div>
</div>
<a id="aeb7959cb8151de232a89d152ddba77d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7959cb8151de232a89d152ddba77d7">&#9670;&nbsp;</a></span>completeSymm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.completeSymm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the lower or the upper half of a square matrix to its another half.</p>
<p>The function cv::completeSymm copies the lower or the upper half of a square matrix to its another half. The matrix diagonal remains unchanged: </p><ul>
<li>
(\texttt{m}_{ij}=\texttt{m}_{ji}) for (i &gt; j) if lowerToUpper=false  </li>
<li>
(\texttt{m}_{ij}=\texttt{m}_{ji}) for (i &lt; j) if lowerToUpper=true  </li>
</ul>
<p>param m input-output floating-point square matrix. the upper half. Otherwise, the upper half is copied to the lower half. SEE: flip, transpose </p>

</div>
</div>
<a id="a4bfeb129b82c198d7524674207ed0a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfeb129b82c198d7524674207ed0a5c">&#9670;&nbsp;</a></span>convertFp16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.convertFp16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an array to half precision floating number.</p>
<p>This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data. There are two use modes (src -&gt; dst): CV_32F -&gt; CV_16S and CV_16S -&gt; CV_32F. The input array has to have type of CV_32F or CV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error. The format of half precision floating point is defined in IEEE 754-2008.</p>
<p>param src input array. param dst output array. </p>

</div>
</div>
<a id="a3b7ab918b6468b4c2a04bb6e7bfe876f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7ab918b6468b4c2a04bb6e7bfe876f">&#9670;&nbsp;</a></span>convertScaleAbs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.convertScaleAbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scales, calculates absolute values, and converts the result to 8-bit.</p>
<p>On each element of the input array, the function convertScaleAbs performs three operations sequentially: scaling, taking an absolute value, conversion to an unsigned 8-bit type: (\texttt{dst} (I)= \texttt{saturate_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} + \texttt{beta} |)) In case of multi-channel arrays, the function processes each channel independently. When the output is not 8-bit, the operation can be emulated by calling the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> method (or by using matrix expressions) and then by calculating an absolute value of the result. For example: <code> Mat_&lt;float&gt; A(30,30); randu(A, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(-100), Scalar(100)); Mat_&lt;float&gt; B = A*5 + 3; B = abs(B); // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job, // but it will allocate a temporary matrix </code> param src input array. param dst output array. param alpha optional scale factor. param beta optional delta added to the scaled values. SEE: <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, cv::abs(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;) </p>

</div>
</div>
<a id="ad82619660103a42d83225d4c879f565c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82619660103a42d83225d4c879f565c">&#9670;&nbsp;</a></span>convertScaleAbs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.convertScaleAbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scales, calculates absolute values, and converts the result to 8-bit.</p>
<p>On each element of the input array, the function convertScaleAbs performs three operations sequentially: scaling, taking an absolute value, conversion to an unsigned 8-bit type: (\texttt{dst} (I)= \texttt{saturate_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} + \texttt{beta} |)) In case of multi-channel arrays, the function processes each channel independently. When the output is not 8-bit, the operation can be emulated by calling the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> method (or by using matrix expressions) and then by calculating an absolute value of the result. For example: <code> Mat_&lt;float&gt; A(30,30); randu(A, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(-100), Scalar(100)); Mat_&lt;float&gt; B = A*5 + 3; B = abs(B); // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job, // but it will allocate a temporary matrix </code> param src input array. param dst output array. param alpha optional scale factor. SEE: <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, cv::abs(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;) </p>

</div>
</div>
<a id="ae2b204dbf02fcc9bbc67ba46c6dd9b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b204dbf02fcc9bbc67ba46c6dd9b15">&#9670;&nbsp;</a></span>convertScaleAbs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.convertScaleAbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scales, calculates absolute values, and converts the result to 8-bit.</p>
<p>On each element of the input array, the function convertScaleAbs performs three operations sequentially: scaling, taking an absolute value, conversion to an unsigned 8-bit type: (\texttt{dst} (I)= \texttt{saturate_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} + \texttt{beta} |)) In case of multi-channel arrays, the function processes each channel independently. When the output is not 8-bit, the operation can be emulated by calling the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> method (or by using matrix expressions) and then by calculating an absolute value of the result. For example: <code> Mat_&lt;float&gt; A(30,30); randu(A, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(-100), Scalar(100)); Mat_&lt;float&gt; B = A*5 + 3; B = abs(B); // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job, // but it will allocate a temporary matrix </code> param src input array. param dst output array. SEE: <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, cv::abs(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;) </p>

</div>
</div>
<a id="acb68ff84346925f03e34a18af4bc9a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb68ff84346925f03e34a18af4bc9a99">&#9670;&nbsp;</a></span>copyMakeBorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.copyMakeBorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forms a border around an image.</p>
<p>The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but what other more complex functions, including your own, may do to simplify image boundary handling.</p>
<p>The function supports the mode when src is already in the middle of dst . In this case, the function does not copy src itself but simply constructs the border, for example:</p>
<p><code> // let border be the same in all directions int border=2; // constructs a larger image to fit both the image and the border <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth()); // select the middle part of it w/o copying data <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> gray(gray_canvas, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(border, border, rgb.cols, rgb.rows)); // convert image from RGB to grayscale cvtColor(rgb, gray, COLOR_RGB2GRAY); // form a border in-place copyMakeBorder(gray, gray_buf, border, border, border, border, BORDER_REPLICATE); // now do some custom filtering ... ... </code> <b>Note:</b> When the source image is a part (ROI) of a bigger image, the function will try to use the pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as if src was not a ROI, use borderType | <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aeaaeecb4a62c6a427156d108e5926613">BORDER_ISOLATED</a>.</p>
<p>param src Source image. param dst Destination image of the same type as src and the size <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(src.cols+left+right, src.rows+top+bottom) . param top the top pixels param bottom the bottom pixels param left the left pixels param right Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs to be built. param borderType Border type. See borderInterpolate for details. param value Border value if borderType==BORDER_CONSTANT .</p>
<p>SEE: borderInterpolate </p>

</div>
</div>
<a id="aafb8ce70678829b90d31b42b4e5ff42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb8ce70678829b90d31b42b4e5ff42f">&#9670;&nbsp;</a></span>copyMakeBorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.copyMakeBorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forms a border around an image.</p>
<p>The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but what other more complex functions, including your own, may do to simplify image boundary handling.</p>
<p>The function supports the mode when src is already in the middle of dst . In this case, the function does not copy src itself but simply constructs the border, for example:</p>
<p><code> // let border be the same in all directions int border=2; // constructs a larger image to fit both the image and the border <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth()); // select the middle part of it w/o copying data <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> gray(gray_canvas, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(border, border, rgb.cols, rgb.rows)); // convert image from RGB to grayscale cvtColor(rgb, gray, COLOR_RGB2GRAY); // form a border in-place copyMakeBorder(gray, gray_buf, border, border, border, border, BORDER_REPLICATE); // now do some custom filtering ... ... </code> <b>Note:</b> When the source image is a part (ROI) of a bigger image, the function will try to use the pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as if src was not a ROI, use borderType | <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#aeaaeecb4a62c6a427156d108e5926613">BORDER_ISOLATED</a>.</p>
<p>param src Source image. param dst Destination image of the same type as src and the size <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(src.cols+left+right, src.rows+top+bottom) . param top the top pixels param bottom the bottom pixels param left the left pixels param right Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs to be built. param borderType Border type. See borderInterpolate for details.</p>
<p>SEE: borderInterpolate </p>

</div>
</div>
<a id="a1333f5071adbeb874d1ca1fa7620a24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1333f5071adbeb874d1ca1fa7620a24f">&#9670;&nbsp;</a></span>copyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience (python) Copies the matrix to another one. When the operation mask is specified, if the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ab18f5d2799293f7fe5219451eb9ac7f1">Mat::create</a> call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data. param src source matrix. param dst Destination matrix. If it does not have a proper size or type before the operation, it is reallocated. param mask Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. </p>

</div>
</div>
<a id="a8ed19616c452764595ecd358d9409a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed19616c452764595ecd358d9409a30">&#9670;&nbsp;</a></span>countNonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.countNonZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts non-zero array elements.</p>
<p>The function returns the number of non-zero elements in src : (\sum _{I: \; \texttt{src} (I) \ne0 } 1) param src single-channel array. SEE: mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix return automatically generated </p>

</div>
</div>
<a id="af22f2d9250b079e1fe89ae6c2ea02511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22f2d9250b079e1fe89ae6c2ea02511">&#9670;&nbsp;</a></span>cubeRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float OpenCVForUnity.CoreModule.Core.cubeRoot </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the cube root of an argument.</p>
<p>The function cubeRoot computes (\sqrt[3]{\texttt{val}}). Negative arguments are handled correctly. NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for single-precision data. param val A function argument. return automatically generated </p>

</div>
</div>
<a id="adda6069b688b78db68f7ec6292dad9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda6069b688b78db68f7ec6292dad9c7">&#9670;&nbsp;</a></span>dct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.dct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a forward or inverse discrete Cosine transform of 1D or 2D array.</p>
<p>The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D floating-point array: </p><ul>
<li>
Forward Cosine transform of a 1D vector of N elements: (Y = C^{(N)} \cdot X) where (C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )) and (\alpha_0=1), (\alpha_j=2) for <em>j &gt; 0</em>.  </li>
<li>
Inverse Cosine transform of a 1D vector of N elements: (X = \left (C^{(N)} \right )^{-1} \cdot Y = \left (C^{(N)} \right )^T \cdot Y) (since (C^{(N)}) is an orthogonal matrix, (C^{(N)} \cdot \left(C^{(N)}\right)^T = I) )  </li>
<li>
Forward 2D Cosine transform of M x N matrix: (Y = C^{(N)} \cdot X \cdot \left (C^{(N)} \right )^T)  </li>
<li>
Inverse 2D Cosine transform of M x N matrix: (X = \left (C^{(N)} \right )^T \cdot X \cdot C^{(N)})  </li>
</ul>
<p>The function chooses the mode of operation by looking at the flags and size of the input array: </p><ul>
<li>
If (flags &amp; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9af8231d95e29adf18d44f8548fa24fa">DCT_INVERSE</a>) == 0 , the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform.  </li>
<li>
If (flags &amp; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a32cc5f0d908ec03cfa6215697d0b1ec5">DCT_ROWS</a>) != 0 , the function performs a 1D transform of each row.  </li>
<li>
If the array is a single column or a single row, the function performs a 1D transform.  </li>
<li>
If none of the above is true, the function performs a 2D transform.  </li>
</ul>
<p><b>Note:</b> Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you can pad the array when necessary. Also, the function performance depends very much, and not monotonically, on the array size (see getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT of a vector of size N/2 . Thus, the optimal DCT size N1 &gt;= N can be calculated as: <code> size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); } N1 = getOptimalDCTSize(N); </code> param src input floating-point array. param dst output array of the same size and type as src . param flags transformation flags as a combination of cv::DftFlags (DCT_*) SEE: dft , getOptimalDFTSize , idct </p>

</div>
</div>
<a id="a5d7808ef62732d31e4261c71bdb06455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7808ef62732d31e4261c71bdb06455">&#9670;&nbsp;</a></span>dct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.dct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a forward or inverse discrete Cosine transform of 1D or 2D array.</p>
<p>The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D floating-point array: </p><ul>
<li>
Forward Cosine transform of a 1D vector of N elements: (Y = C^{(N)} \cdot X) where (C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )) and (\alpha_0=1), (\alpha_j=2) for <em>j &gt; 0</em>.  </li>
<li>
Inverse Cosine transform of a 1D vector of N elements: (X = \left (C^{(N)} \right )^{-1} \cdot Y = \left (C^{(N)} \right )^T \cdot Y) (since (C^{(N)}) is an orthogonal matrix, (C^{(N)} \cdot \left(C^{(N)}\right)^T = I) )  </li>
<li>
Forward 2D Cosine transform of M x N matrix: (Y = C^{(N)} \cdot X \cdot \left (C^{(N)} \right )^T)  </li>
<li>
Inverse 2D Cosine transform of M x N matrix: (X = \left (C^{(N)} \right )^T \cdot X \cdot C^{(N)})  </li>
</ul>
<p>The function chooses the mode of operation by looking at the flags and size of the input array: </p><ul>
<li>
If (flags &amp; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a9af8231d95e29adf18d44f8548fa24fa">DCT_INVERSE</a>) == 0 , the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform.  </li>
<li>
If (flags &amp; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a32cc5f0d908ec03cfa6215697d0b1ec5">DCT_ROWS</a>) != 0 , the function performs a 1D transform of each row.  </li>
<li>
If the array is a single column or a single row, the function performs a 1D transform.  </li>
<li>
If none of the above is true, the function performs a 2D transform.  </li>
</ul>
<p><b>Note:</b> Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you can pad the array when necessary. Also, the function performance depends very much, and not monotonically, on the array size (see getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT of a vector of size N/2 . Thus, the optimal DCT size N1 &gt;= N can be calculated as: <code> size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); } N1 = getOptimalDCTSize(N); </code> param src input floating-point array. param dst output array of the same size and type as src . SEE: dft , getOptimalDFTSize , idct </p>

</div>
</div>
<a id="aed0ce157a707e0b564fe648d587384cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0ce157a707e0b564fe648d587384cc">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.determinant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the determinant of a square floating-point matrix.</p>
<p>The function cv::determinant calculates and returns the determinant of the specified matrix. For small matrices ( mtx.cols=mtx.rows&lt;=3 ), the direct method is used. For larger matrices, the function uses LU factorization with partial pivoting.</p>
<p>For symmetric positively-determined matrices, it is also possible to use eigen decomposition to calculate the determinant. param mtx input matrix that must have CV_32FC1 or CV_64FC1 type and square size. SEE: trace, invert, solve, eigen, REF: MatrixExpressions return automatically generated </p>

</div>
</div>
<a id="a1dcd74cea1d4886ce01621d4dec38b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcd74cea1d4886ce01621d4dec38b6f">&#9670;&nbsp;</a></span>dft() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.dft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nonzeroRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</p>
<p>The function cv::dft performs one of the following: </p><ul>
<li>
Forward the Fourier transform of a 1D vector of N elements: (Y = F^{(N)} \cdot X,) where (F^{(N)}_{jk}=\exp(-2\pi i j k/N)) and (i=\sqrt{-1})  </li>
<li>
Inverse the Fourier transform of a 1D vector of N elements: (\begin{array}{l} X'= \left (F^{(N)} \right )^{-1} \cdot Y = \left (F^{(N)} \right )^* \cdot y \ X = (1/N) \cdot X, \end{array}) where (F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T)  </li>
<li>
Forward the 2D Fourier transform of a M x N matrix: (Y = F^{(M)} \cdot X \cdot F^{(N)})  </li>
<li>
Inverse the 2D Fourier transform of a M x N matrix: (\begin{array}{l} X'= \left (F^{(M)} \right )^* \cdot Y \cdot \left (F^{(N)} \right )^* \ X = \frac{1}{M \cdot N} \cdot X' \end{array})  </li>
</ul>
<p>In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called <em>CCS</em> (complex-conjugate-symmetrical). It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D <em>CCS</em> spectrum looks: (\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp; \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2} \ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp; \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2} \ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp; \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2} \ \hdotsfor{9} \ Re Y_{M/2-1,0} &amp; Re Y_{M-3,1} &amp; Im Y_{M-3,1} &amp; \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2} \ Im Y_{M/2-1,0} &amp; Re Y_{M-2,1} &amp; Im Y_{M-2,1} &amp; \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2} \ Re Y_{M/2,0} &amp; Re Y_{M-1,1} &amp; Im Y_{M-1,1} &amp; \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix})</p>
<p>In case of 1D transform of a real vector, the output looks like the first row of the matrix above.</p>
<p>So, the function chooses an operation mode depending on the flags and size of the input array: </p><ul>
<li>
If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> is set. Otherwise, it performs a 2D transform.  </li>
<li>
If the input array is real and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is not set, the function performs a forward 1D or 2D transform: <ul>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0910f497f735b83cbf02f40d8cbede98">DFT_COMPLEX_OUTPUT</a> is set, the output is a complex matrix of the same size as input.  </li>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0910f497f735b83cbf02f40d8cbede98">DFT_COMPLEX_OUTPUT</a> is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> flag), each row of the output matrix looks like the first row of the matrix above.  </li>
</ul>
</li>
<li>
If the input array is complex and either <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> or <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5afda64a7880e084d74eeb7d9ec520f5">DFT_REAL_OUTPUT</a> are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags DFT_INVERSE and DFT_ROWS.  </li>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is set and the input array is real, or it is complex but <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5afda64a7880e084d74eeb7d9ec520f5">DFT_REAL_OUTPUT</a> is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a>.  </li>
</ul>
<p>If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac5b6cafe67cb86f13fa99b3557761dc0">DFT_SCALE</a> is set, the scaling is done after the transformation.</p>
<p>Unlike dct , the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize method.</p>
<p>The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays: <code> void convolveDFT(InputArray A, InputArray B, OutputArray C) { // reallocate the output array if needed C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type()); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dftSize; // calculate the size of DFT transform dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1); dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);</code></p>
<p><code> // allocate temporary buffers and initialize them with 0's <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tempA(dftSize, A.type(), Scalar::all(0)); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tempB(dftSize, B.type(), Scalar::all(0));</code></p>
<p><code> // copy A and B to the top-left corners of tempA and tempB, respectively <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roiA(tempA, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0,0,A.cols,A.rows)); A.copyTo(roiA); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roiB(tempB, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0,0,B.cols,B.rows)); B.copyTo(roiB);</code></p>
<p><code> // now transform the padded A &amp; B in-place; // use "nonzeroRows" hint for faster processing dft(tempA, tempA, 0, A.rows); dft(tempB, tempB, 0, B.rows);</code></p>
<p><code> // multiply the spectrums; // the function handles packed spectrum representations well mulSpectrums(tempA, tempB, tempA);</code></p>
<p><code> // transform the product back from the frequency domain. // Even though all the result rows will be non-zero, // you need only the first C.rows of them, and thus you // pass nonzeroRows == C.rows dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);</code></p>
<p><code> // now copy the result back to C. tempA(<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0, 0, C.cols, C.rows)).copyTo(C);</code></p>
<p><code> // all the temporary buffers will be deallocated automatically } </code> To optimize this sample, consider the following approaches: </p><ul>
<li>
Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols) rightmost columns of the matrices.  </li>
<li>
This DFT-based convolution does not have to be applied to the whole big arrays, especially if B is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array C into multiple tiles. For each tile, estimate which parts of A and B are required to calculate convolution in this tile. If the tiles in C are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle.  </li>
<li>
If different tiles in C can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded.  </li>
</ul>
<p>All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-correlation, not convolution, so you need to "flip" the second convolution operand B vertically and horizontally using flip . <b>Note:</b> </p><ul>
<li>
An example using the discrete fourier transform can be found at opencv_source_code/samples/cpp/dft.cpp  </li>
<li>
(Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv_source/samples/python/deconvolution.py  </li>
<li>
(Python) An example rearranging the quadrants of a Fourier image can be found at opencv_source/samples/python/dft.py param src input array that could be real or complex. param dst output array whose size and type depends on the flags . param flags transformation flags, representing a combination of the #DftFlags param nonzeroRows when the parameter is not zero, the function assumes that only the first nonzeroRows rows of the input array (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is not set) or only the first nonzeroRows of the output array (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is set) contain non-zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-correlation or convolution using DFT. SEE: dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar , magnitude , phase  </li>
</ul>

</div>
</div>
<a id="a857fd910d5e4bcafaef82a9ccb5db019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857fd910d5e4bcafaef82a9ccb5db019">&#9670;&nbsp;</a></span>dft() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.dft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</p>
<p>The function cv::dft performs one of the following: </p><ul>
<li>
Forward the Fourier transform of a 1D vector of N elements: (Y = F^{(N)} \cdot X,) where (F^{(N)}_{jk}=\exp(-2\pi i j k/N)) and (i=\sqrt{-1})  </li>
<li>
Inverse the Fourier transform of a 1D vector of N elements: (\begin{array}{l} X'= \left (F^{(N)} \right )^{-1} \cdot Y = \left (F^{(N)} \right )^* \cdot y \ X = (1/N) \cdot X, \end{array}) where (F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T)  </li>
<li>
Forward the 2D Fourier transform of a M x N matrix: (Y = F^{(M)} \cdot X \cdot F^{(N)})  </li>
<li>
Inverse the 2D Fourier transform of a M x N matrix: (\begin{array}{l} X'= \left (F^{(M)} \right )^* \cdot Y \cdot \left (F^{(N)} \right )^* \ X = \frac{1}{M \cdot N} \cdot X' \end{array})  </li>
</ul>
<p>In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called <em>CCS</em> (complex-conjugate-symmetrical). It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D <em>CCS</em> spectrum looks: (\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp; \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2} \ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp; \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2} \ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp; \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2} \ \hdotsfor{9} \ Re Y_{M/2-1,0} &amp; Re Y_{M-3,1} &amp; Im Y_{M-3,1} &amp; \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2} \ Im Y_{M/2-1,0} &amp; Re Y_{M-2,1} &amp; Im Y_{M-2,1} &amp; \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2} \ Re Y_{M/2,0} &amp; Re Y_{M-1,1} &amp; Im Y_{M-1,1} &amp; \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix})</p>
<p>In case of 1D transform of a real vector, the output looks like the first row of the matrix above.</p>
<p>So, the function chooses an operation mode depending on the flags and size of the input array: </p><ul>
<li>
If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> is set. Otherwise, it performs a 2D transform.  </li>
<li>
If the input array is real and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is not set, the function performs a forward 1D or 2D transform: <ul>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0910f497f735b83cbf02f40d8cbede98">DFT_COMPLEX_OUTPUT</a> is set, the output is a complex matrix of the same size as input.  </li>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0910f497f735b83cbf02f40d8cbede98">DFT_COMPLEX_OUTPUT</a> is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> flag), each row of the output matrix looks like the first row of the matrix above.  </li>
</ul>
</li>
<li>
If the input array is complex and either <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> or <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5afda64a7880e084d74eeb7d9ec520f5">DFT_REAL_OUTPUT</a> are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags DFT_INVERSE and DFT_ROWS.  </li>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is set and the input array is real, or it is complex but <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5afda64a7880e084d74eeb7d9ec520f5">DFT_REAL_OUTPUT</a> is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a>.  </li>
</ul>
<p>If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac5b6cafe67cb86f13fa99b3557761dc0">DFT_SCALE</a> is set, the scaling is done after the transformation.</p>
<p>Unlike dct , the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize method.</p>
<p>The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays: <code> void convolveDFT(InputArray A, InputArray B, OutputArray C) { // reallocate the output array if needed C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type()); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dftSize; // calculate the size of DFT transform dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1); dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);</code></p>
<p><code> // allocate temporary buffers and initialize them with 0's <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tempA(dftSize, A.type(), Scalar::all(0)); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tempB(dftSize, B.type(), Scalar::all(0));</code></p>
<p><code> // copy A and B to the top-left corners of tempA and tempB, respectively <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roiA(tempA, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0,0,A.cols,A.rows)); A.copyTo(roiA); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roiB(tempB, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0,0,B.cols,B.rows)); B.copyTo(roiB);</code></p>
<p><code> // now transform the padded A &amp; B in-place; // use "nonzeroRows" hint for faster processing dft(tempA, tempA, 0, A.rows); dft(tempB, tempB, 0, B.rows);</code></p>
<p><code> // multiply the spectrums; // the function handles packed spectrum representations well mulSpectrums(tempA, tempB, tempA);</code></p>
<p><code> // transform the product back from the frequency domain. // Even though all the result rows will be non-zero, // you need only the first C.rows of them, and thus you // pass nonzeroRows == C.rows dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);</code></p>
<p><code> // now copy the result back to C. tempA(<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0, 0, C.cols, C.rows)).copyTo(C);</code></p>
<p><code> // all the temporary buffers will be deallocated automatically } </code> To optimize this sample, consider the following approaches: </p><ul>
<li>
Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols) rightmost columns of the matrices.  </li>
<li>
This DFT-based convolution does not have to be applied to the whole big arrays, especially if B is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array C into multiple tiles. For each tile, estimate which parts of A and B are required to calculate convolution in this tile. If the tiles in C are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle.  </li>
<li>
If different tiles in C can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded.  </li>
</ul>
<p>All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-correlation, not convolution, so you need to "flip" the second convolution operand B vertically and horizontally using flip . <b>Note:</b> </p><ul>
<li>
An example using the discrete fourier transform can be found at opencv_source_code/samples/cpp/dft.cpp  </li>
<li>
(Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv_source/samples/python/deconvolution.py  </li>
<li>
(Python) An example rearranging the quadrants of a Fourier image can be found at opencv_source/samples/python/dft.py param src input array that could be real or complex. param dst output array whose size and type depends on the flags . param flags transformation flags, representing a combination of the #DftFlags nonzeroRows rows of the input array (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is not set) or only the first nonzeroRows of the output array (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is set) contain non-zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-correlation or convolution using DFT. SEE: dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar , magnitude , phase  </li>
</ul>

</div>
</div>
<a id="ab5ae8b1b309200f8a94c2e9f1bc9e1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ae8b1b309200f8a94c2e9f1bc9e1cd">&#9670;&nbsp;</a></span>dft() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.dft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</p>
<p>The function cv::dft performs one of the following: </p><ul>
<li>
Forward the Fourier transform of a 1D vector of N elements: (Y = F^{(N)} \cdot X,) where (F^{(N)}_{jk}=\exp(-2\pi i j k/N)) and (i=\sqrt{-1})  </li>
<li>
Inverse the Fourier transform of a 1D vector of N elements: (\begin{array}{l} X'= \left (F^{(N)} \right )^{-1} \cdot Y = \left (F^{(N)} \right )^* \cdot y \ X = (1/N) \cdot X, \end{array}) where (F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T)  </li>
<li>
Forward the 2D Fourier transform of a M x N matrix: (Y = F^{(M)} \cdot X \cdot F^{(N)})  </li>
<li>
Inverse the 2D Fourier transform of a M x N matrix: (\begin{array}{l} X'= \left (F^{(M)} \right )^* \cdot Y \cdot \left (F^{(N)} \right )^* \ X = \frac{1}{M \cdot N} \cdot X' \end{array})  </li>
</ul>
<p>In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called <em>CCS</em> (complex-conjugate-symmetrical). It was borrowed from IPL (Intel* Image Processing Library). Here is how 2D <em>CCS</em> spectrum looks: (\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp; \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2} \ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp; \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2} \ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp; \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2} \ \hdotsfor{9} \ Re Y_{M/2-1,0} &amp; Re Y_{M-3,1} &amp; Im Y_{M-3,1} &amp; \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2} \ Im Y_{M/2-1,0} &amp; Re Y_{M-2,1} &amp; Im Y_{M-2,1} &amp; \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2} \ Re Y_{M/2,0} &amp; Re Y_{M-1,1} &amp; Im Y_{M-1,1} &amp; \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix})</p>
<p>In case of 1D transform of a real vector, the output looks like the first row of the matrix above.</p>
<p>So, the function chooses an operation mode depending on the flags and size of the input array: </p><ul>
<li>
If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> is set. Otherwise, it performs a 2D transform.  </li>
<li>
If the input array is real and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is not set, the function performs a forward 1D or 2D transform: <ul>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0910f497f735b83cbf02f40d8cbede98">DFT_COMPLEX_OUTPUT</a> is set, the output is a complex matrix of the same size as input.  </li>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0910f497f735b83cbf02f40d8cbede98">DFT_COMPLEX_OUTPUT</a> is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a> flag), each row of the output matrix looks like the first row of the matrix above.  </li>
</ul>
</li>
<li>
If the input array is complex and either <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> or <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5afda64a7880e084d74eeb7d9ec520f5">DFT_REAL_OUTPUT</a> are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags DFT_INVERSE and DFT_ROWS.  </li>
<li>
When <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is set and the input array is real, or it is complex but <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a5afda64a7880e084d74eeb7d9ec520f5">DFT_REAL_OUTPUT</a> is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a>.  </li>
</ul>
<p>If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac5b6cafe67cb86f13fa99b3557761dc0">DFT_SCALE</a> is set, the scaling is done after the transformation.</p>
<p>Unlike dct , the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize method.</p>
<p>The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays: <code> void convolveDFT(InputArray A, InputArray B, OutputArray C) { // reallocate the output array if needed C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type()); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dftSize; // calculate the size of DFT transform dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1); dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);</code></p>
<p><code> // allocate temporary buffers and initialize them with 0's <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tempA(dftSize, A.type(), Scalar::all(0)); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tempB(dftSize, B.type(), Scalar::all(0));</code></p>
<p><code> // copy A and B to the top-left corners of tempA and tempB, respectively <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roiA(tempA, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0,0,A.cols,A.rows)); A.copyTo(roiA); <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> roiB(tempB, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0,0,B.cols,B.rows)); B.copyTo(roiB);</code></p>
<p><code> // now transform the padded A &amp; B in-place; // use "nonzeroRows" hint for faster processing dft(tempA, tempA, 0, A.rows); dft(tempB, tempB, 0, B.rows);</code></p>
<p><code> // multiply the spectrums; // the function handles packed spectrum representations well mulSpectrums(tempA, tempB, tempA);</code></p>
<p><code> // transform the product back from the frequency domain. // Even though all the result rows will be non-zero, // you need only the first C.rows of them, and thus you // pass nonzeroRows == C.rows dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);</code></p>
<p><code> // now copy the result back to C. tempA(<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>(0, 0, C.cols, C.rows)).copyTo(C);</code></p>
<p><code> // all the temporary buffers will be deallocated automatically } </code> To optimize this sample, consider the following approaches: </p><ul>
<li>
Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols) rightmost columns of the matrices.  </li>
<li>
This DFT-based convolution does not have to be applied to the whole big arrays, especially if B is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array C into multiple tiles. For each tile, estimate which parts of A and B are required to calculate convolution in this tile. If the tiles in C are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle.  </li>
<li>
If different tiles in C can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded.  </li>
</ul>
<p>All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-correlation, not convolution, so you need to "flip" the second convolution operand B vertically and horizontally using flip . <b>Note:</b> </p><ul>
<li>
An example using the discrete fourier transform can be found at opencv_source_code/samples/cpp/dft.cpp  </li>
<li>
(Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv_source/samples/python/deconvolution.py  </li>
<li>
(Python) An example rearranging the quadrants of a Fourier image can be found at opencv_source/samples/python/dft.py param src input array that could be real or complex. param dst output array whose size and type depends on the flags . nonzeroRows rows of the input array (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is not set) or only the first nonzeroRows of the output array (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a> is set) contain non-zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-correlation or convolution using DFT. SEE: dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar , magnitude , phase  </li>
</ul>

</div>
</div>
<a id="ac3ba80bc70b7936509e314382ed918c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ba80bc70b7936509e314382ed918c6">&#9670;&nbsp;</a></span>divide() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs per-element division of two arrays or a scalar by an array.</p>
<p>The function cv::divide divides one array by another: (\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}) or a scalar by an array when there is no src1 : (\texttt{dst(I) = saturate(scale/src2(I))})</p>
<p>Different channels of multi-channel arrays are processed independently.</p>
<p>For integer types when src2(I) is zero, dst(I) will also be zero.</p>
<p><b>Note:</b> In case of floating point data there is no special defined behavior for zero src2(I) values. Regular floating-point division is used. Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).</p>
<p><b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param src2 second input array of the same size and type as src1. param scale scalar factor. param dst output array of the same size and type as src2. param dtype optional depth of the output array; if -1, dst will have depth src2.depth(), but in case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth(). SEE: multiply, add, subtract </p>

</div>
</div>
<a id="a02ee09e91f417aa03a4a87b93d72cd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ee09e91f417aa03a4a87b93d72cd1a">&#9670;&nbsp;</a></span>divide() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs per-element division of two arrays or a scalar by an array.</p>
<p>The function cv::divide divides one array by another: (\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}) or a scalar by an array when there is no src1 : (\texttt{dst(I) = saturate(scale/src2(I))})</p>
<p>Different channels of multi-channel arrays are processed independently.</p>
<p>For integer types when src2(I) is zero, dst(I) will also be zero.</p>
<p><b>Note:</b> In case of floating point data there is no special defined behavior for zero src2(I) values. Regular floating-point division is used. Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).</p>
<p><b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param src2 second input array of the same size and type as src1. param scale scalar factor. param dst output array of the same size and type as src2. case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth(). SEE: multiply, add, subtract </p>

</div>
</div>
<a id="ac7d9cdb371525f36057abdafdd609c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d9cdb371525f36057abdafdd609c54">&#9670;&nbsp;</a></span>divide() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs per-element division of two arrays or a scalar by an array.</p>
<p>The function cv::divide divides one array by another: (\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}) or a scalar by an array when there is no src1 : (\texttt{dst(I) = saturate(scale/src2(I))})</p>
<p>Different channels of multi-channel arrays are processed independently.</p>
<p>For integer types when src2(I) is zero, dst(I) will also be zero.</p>
<p><b>Note:</b> In case of floating point data there is no special defined behavior for zero src2(I) values. Regular floating-point division is used. Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).</p>
<p><b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param src2 second input array of the same size and type as src1. param dst output array of the same size and type as src2. case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth(). SEE: multiply, add, subtract </p>

</div>
</div>
<a id="a6dfcd950f1a48eb0622703a99f792590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfcd950f1a48eb0622703a99f792590">&#9670;&nbsp;</a></span>divide() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e7990e13b763247fac3f2d05c54a5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7990e13b763247fac3f2d05c54a5b2">&#9670;&nbsp;</a></span>divide() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf205e44d433d920981d3c8d28ab1c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf205e44d433d920981d3c8d28ab1c9d">&#9670;&nbsp;</a></span>divide() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9603766e3901ad0da898cf75f7815ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9603766e3901ad0da898cf75f7815ac6">&#9670;&nbsp;</a></span>divide() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c04001516fbaf9d1e95e0c59fbb7098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c04001516fbaf9d1e95e0c59fbb7098">&#9670;&nbsp;</a></span>divide() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.divide </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b7fd8bf7dca9c230636f43c4e638cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7fd8bf7dca9c230636f43c4e638cc4">&#9670;&nbsp;</a></span>eigen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.eigen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates eigenvalues and eigenvectors of a symmetric matrix.</p>
<p>The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric matrix src: <code> src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t() </code></p>
<p><b>Note:</b> Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.</p>
<p>param src input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical (src ^T^ == src). param eigenvalues output vector of eigenvalues of the same type as src; the eigenvalues are stored in the descending order. param eigenvectors output matrix of eigenvectors; it has the same size and type as src; the eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. SEE: eigenNonSymmetric, completeSymm , PCA return automatically generated </p>

</div>
</div>
<a id="a27f30b1bff51a114c9cc7f188d0b3f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f30b1bff51a114c9cc7f188d0b3f79">&#9670;&nbsp;</a></span>eigen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.eigen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates eigenvalues and eigenvectors of a symmetric matrix.</p>
<p>The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric matrix src: <code> src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t() </code></p>
<p><b>Note:</b> Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.</p>
<p>param src input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical (src ^T^ == src). param eigenvalues output vector of eigenvalues of the same type as src; the eigenvalues are stored in the descending order. eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. SEE: eigenNonSymmetric, completeSymm , PCA return automatically generated </p>

</div>
</div>
<a id="a6d3219b28c1a318c81bf4dba24f658c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3219b28c1a318c81bf4dba24f658c3">&#9670;&nbsp;</a></span>eigenNonSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.eigenNonSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).</p>
<p><b>Note:</b> Assumes real eigenvalues.</p>
<p>The function calculates eigenvalues and eigenvectors (optional) of the square matrix src: <code> src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t() </code></p>
<p>param src input matrix (CV_32FC1 or CV_64FC1 type). param eigenvalues output vector of eigenvalues (type is the same type as src). param eigenvectors output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. SEE: eigen </p>

</div>
</div>
<a id="aa31b0f8b9cb1536e021092c9f09017a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31b0f8b9cb1536e021092c9f09017a5">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the exponent of every array element.</p>
<p>The function cv::exp calculates the exponent of every element of the input array: (\texttt{dst} [I] = e^{ src(I) })</p>
<p>The maximum relative error is about 7e-6 for single-precision input and less than 1e-10 for double-precision input. Currently, the function converts denormalized values to zeros on output. Special values (NaN, Inf) are not handled. param src input array. param dst output array of the same size and type as src. SEE: log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude </p>

</div>
</div>
<a id="a1ce16fd41376338d52f61128387b4c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce16fd41376338d52f61128387b4c4c">&#9670;&nbsp;</a></span>extractChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.extractChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts a single channel from src (coi is 0-based index) param src input array param dst output array param coi index of channel to extract SEE: mixChannels, split </p>

</div>
</div>
<a id="a431aa65df203a0950d631f6b93253251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431aa65df203a0950d631f6b93253251">&#9670;&nbsp;</a></span>fastAtan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float OpenCVForUnity.CoreModule.Core.fastAtan2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the angle of a 2D vector in degrees.</p>
<p>The function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured in degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees. param x x-coordinate of the vector. param y y-coordinate of the vector. return automatically generated </p>

</div>
</div>
<a id="a13396309f2ee7f3a77604d00637b81e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13396309f2ee7f3a77604d00637b81e2">&#9670;&nbsp;</a></span>findFile() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.findFile </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>relative_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silentMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to find requested data file</p>
<p>Search directories:</p>
<ol type="1">
<li>Directories passed via {code <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1623398b4f1a7c4990823fb02e7f1d62">addSamplesDataSearchPath()</a>}</li>
<li>OPENCV_SAMPLES_DATA_PATH_HINT environment variable</li>
<li>OPENCV_SAMPLES_DATA_PATH environment variable If parameter value is not empty and nothing is found then stop searching.</li>
<li>Detects build/install path based on: a. current working directory (CWD) b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage)</li>
<li>Scan {code &lt;source&gt;/{,data,samples/data}} directories if build directory is detected or the current directory is in source tree.</li>
<li>Scan {code &lt;install&gt;/share/OpenCV} directory if install directory is detected.</li>
</ol>
<p>SEE: cv::utils::findDataFile</p>
<p>param relative_path Relative path to data file param required Specify "file not found" handling. If true, function prints information message and raises cv::Exception. If false, function returns empty result param silentMode Disables messages return Returns path (absolute or relative to the current directory) or empty string if file is not found </p>

</div>
</div>
<a id="ae61ec2b469d2c7103a9e2fdf688b4ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61ec2b469d2c7103a9e2fdf688b4ef0">&#9670;&nbsp;</a></span>findFile() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.findFile </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>relative_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to find requested data file</p>
<p>Search directories:</p>
<ol type="1">
<li>Directories passed via {code <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1623398b4f1a7c4990823fb02e7f1d62">addSamplesDataSearchPath()</a>}</li>
<li>OPENCV_SAMPLES_DATA_PATH_HINT environment variable</li>
<li>OPENCV_SAMPLES_DATA_PATH environment variable If parameter value is not empty and nothing is found then stop searching.</li>
<li>Detects build/install path based on: a. current working directory (CWD) b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage)</li>
<li>Scan {code &lt;source&gt;/{,data,samples/data}} directories if build directory is detected or the current directory is in source tree.</li>
<li>Scan {code &lt;install&gt;/share/OpenCV} directory if install directory is detected.</li>
</ol>
<p>SEE: cv::utils::findDataFile</p>
<p>param relative_path Relative path to data file param required Specify "file not found" handling. If true, function prints information message and raises cv::Exception. If false, function returns empty result return Returns path (absolute or relative to the current directory) or empty string if file is not found </p>

</div>
</div>
<a id="a04930fe4185f18142b589788513d60a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04930fe4185f18142b589788513d60a4">&#9670;&nbsp;</a></span>findFile() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.findFile </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>relative_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to find requested data file</p>
<p>Search directories:</p>
<ol type="1">
<li>Directories passed via {code <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a1623398b4f1a7c4990823fb02e7f1d62">addSamplesDataSearchPath()</a>}</li>
<li>OPENCV_SAMPLES_DATA_PATH_HINT environment variable</li>
<li>OPENCV_SAMPLES_DATA_PATH environment variable If parameter value is not empty and nothing is found then stop searching.</li>
<li>Detects build/install path based on: a. current working directory (CWD) b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage)</li>
<li>Scan {code &lt;source&gt;/{,data,samples/data}} directories if build directory is detected or the current directory is in source tree.</li>
<li>Scan {code &lt;install&gt;/share/OpenCV} directory if install directory is detected.</li>
</ol>
<p>SEE: cv::utils::findDataFile</p>
<p>param relative_path Relative path to data file If true, function prints information message and raises cv::Exception. If false, function returns empty result return Returns path (absolute or relative to the current directory) or empty string if file is not found </p>

</div>
</div>
<a id="ae312cb93a3e5cd8f1a91dbd4d24032a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae312cb93a3e5cd8f1a91dbd4d24032a3">&#9670;&nbsp;</a></span>findFileOrKeep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.findFileOrKeep </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>relative_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silentMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a346163bcd998955e69e9277de194fe9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346163bcd998955e69e9277de194fe9c">&#9670;&nbsp;</a></span>findFileOrKeep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.findFileOrKeep </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>relative_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32ae5e37ff5de75a389da2ca0bb30fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ae5e37ff5de75a389da2ca0bb30fff">&#9670;&nbsp;</a></span>findNonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.findNonZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of locations of non-zero pixels</p>
<p>Given a binary matrix (likely returned from an operation such as threshold(), <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a09b5b4761e2510828070520b5056506b">compare()</a>, &gt;, ==, etc, return all of the non-zero indices as a cv::Mat or std::vector&lt;cv::Point&gt; (x,y) For example: <code> cv::Mat binaryImage; // input, binary image cv::Mat locations; // output, locations of non-zero pixels cv::findNonZero(binaryImage, locations);</code></p>
<p><code> // access pixel coordinates <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pnt = locations.at&lt;<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&gt;(i); </code> or <code> cv::Mat binaryImage; // input, binary image vector&lt;<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&gt; locations; // output, locations of non-zero pixels cv::findNonZero(binaryImage, locations);</code></p>
<p><code> // access pixel coordinates <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pnt = locations[i]; </code> param src single-channel array param idx the output array, type of cv::Mat or std::vector&lt;<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&gt;, corresponding to non-zero indices in the input </p>

</div>
</div>
<a id="a06719211e27bdb5c67c454ea28b16f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06719211e27bdb5c67c454ea28b16f8b">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flipCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flips a 2D array around vertical, horizontal, or both axes.</p>
<p>The function cv::flip flips the array in one of three different ways (row and column indices are 0-based): (\texttt{dst} _{ij} = \left\{ \begin{array}{l l} \texttt{src} _{\texttt{src.rows}-i-1,j} &amp; if\; \texttt{flipCode} = 0 \ \texttt{src} _{i, \texttt{src.cols} -j-1} &amp; if\; \texttt{flipCode} &gt; 0 \ \texttt{src} _{ \texttt{src.rows} -i-1, \texttt{src.cols} -j-1} &amp; if\; \texttt{flipCode} &lt; 0 \ \end{array} \right.) The example scenarios of using the function are the following: Vertical flipping of the image (flipCode == 0) to switch between top-left and bottom-left image origin. This is a typical operation in video processing on Microsoft Windows* OS. Horizontal flipping of the image with the subsequent horizontal shift and absolute difference calculation to check for a vertical-axis symmetry (flipCode &gt; 0). Simultaneous horizontal and vertical flipping of the image with the subsequent shift and absolute difference calculation to check for a central symmetry (flipCode &lt; 0). Reversing the order of point arrays (flipCode &gt; 0 or flipCode == 0). param src input array. param dst output array of the same size and type as src. param flipCode a flag to specify how to flip the array; 0 means flipping around the x-axis and positive value (for example, 1) means flipping around y-axis. Negative value (for example, -1) means flipping around both axes. SEE: transpose , repeat , completeSymm </p>

</div>
</div>
<a id="ab92c515d8a2d29f05d74081472b937f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92c515d8a2d29f05d74081472b937f7">&#9670;&nbsp;</a></span>gemm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs generalized matrix multiplication.</p>
<p>The function cv::gemm performs generalized matrix multiplication similar to the gemm functions in BLAS level 3. For example, {code gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)} corresponds to (\texttt{dst} = \texttt{alpha} \cdot \texttt{src1} ^T \cdot \texttt{src2} + \texttt{beta} \cdot \texttt{src3} ^T)</p>
<p>In case of complex (two-channel) data, performed a complex matrix multiplication.</p>
<p>The function can be replaced with a matrix expression. For example, the above call can be replaced with: <code> dst = alpha*src1.t()*src2 + beta*src3.t(); </code> param src1 first multiplied input matrix that could be real(CV_32FC1, CV_64FC1) or complex(CV_32FC2, CV_64FC2). param src2 second multiplied input matrix of the same type as src1. param alpha weight of the matrix product. param src3 third optional delta matrix added to the matrix product; it should have the same type as src1 and src2. param beta weight of src3. param dst output matrix; it has the proper size and the same type as input matrices. param flags operation flags (cv::GemmFlags) SEE: mulTransposed , transform </p>

</div>
</div>
<a id="a8a014f27240f77a34e6d2d9e90b7019d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a014f27240f77a34e6d2d9e90b7019d">&#9670;&nbsp;</a></span>gemm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs generalized matrix multiplication.</p>
<p>The function cv::gemm performs generalized matrix multiplication similar to the gemm functions in BLAS level 3. For example, {code gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)} corresponds to (\texttt{dst} = \texttt{alpha} \cdot \texttt{src1} ^T \cdot \texttt{src2} + \texttt{beta} \cdot \texttt{src3} ^T)</p>
<p>In case of complex (two-channel) data, performed a complex matrix multiplication.</p>
<p>The function can be replaced with a matrix expression. For example, the above call can be replaced with: <code> dst = alpha*src1.t()*src2 + beta*src3.t(); </code> param src1 first multiplied input matrix that could be real(CV_32FC1, CV_64FC1) or complex(CV_32FC2, CV_64FC2). param src2 second multiplied input matrix of the same type as src1. param alpha weight of the matrix product. param src3 third optional delta matrix added to the matrix product; it should have the same type as src1 and src2. param beta weight of src3. param dst output matrix; it has the proper size and the same type as input matrices. SEE: mulTransposed , transform </p>

</div>
</div>
<a id="a8e647297cfa4400751bef5c4b7a3b667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e647297cfa4400751bef5c4b7a3b667">&#9670;&nbsp;</a></span>getBuildInformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.getBuildInformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns full configuration time cmake output.</p>
<p>Returned value is raw cmake output including version control system revision, compiler version, compiler flags, enabled modules and third party libraries, etc. Output format depends on target architecture. return automatically generated </p>

</div>
</div>
<a id="a5d4e9fc59bb107b140cf139db4c6d823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4e9fc59bb107b140cf139db4c6d823">&#9670;&nbsp;</a></span>getCPUFeaturesLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.getCPUFeaturesLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns list of CPU features enabled during compilation.</p>
<p>Returned value is a string containing space separated list of CPU features with following markers:</p>
<ul>
<li>
no markers - baseline features  </li>
<li>
prefix {code *} - features enabled in dispatcher  </li>
<li>
suffix {code ?} - features enabled but not available in HW  </li>
</ul>
<p>Example: {code SSE SSE2 SSE3 *SSE4.1 *SSE4.2 *FP16 *AVX *AVX2 *AVX512-SKX?} return automatically generated </p>

</div>
</div>
<a id="a8613cb7c4cc85f2ba736f9efc769b6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8613cb7c4cc85f2ba736f9efc769b6c1">&#9670;&nbsp;</a></span>getCPUTickCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long OpenCVForUnity.CoreModule.Core.getCPUTickCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of CPU ticks.</p>
<p>The function returns the current number of CPU ticks on some architectures (such as x86, x64, PowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for very accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU systems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU with its own counter. So, theoretically (and practically) the subsequent calls to the function do not necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU frequency depending on the load, the number of CPU clocks spent in some code cannot be directly converted to time units. Therefore, getTickCount is generally a preferable solution for measuring execution time. return automatically generated </p>

</div>
</div>
<a id="aca29ca6e9e12fe85100f45805c978953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca29ca6e9e12fe85100f45805c978953">&#9670;&nbsp;</a></span>getHardwareFeatureName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.getHardwareFeatureName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>feature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns feature name by ID</p>
<p>Returns empty string if feature is not defined param feature automatically generated return automatically generated </p>

</div>
</div>
<a id="a73e8e5dddf8606367830e7d14fcc33cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e8e5dddf8606367830e7d14fcc33cb">&#9670;&nbsp;</a></span>getIppVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.getIppVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a865f0ee81456a015c0aa2828d4fcfd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865f0ee81456a015c0aa2828d4fcfd48">&#9670;&nbsp;</a></span>getNumberOfCPUs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.getNumberOfCPUs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of logical CPUs available for the process. return automatically generated </p>

</div>
</div>
<a id="ada858e987ec8db0a379ae7d346865b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada858e987ec8db0a379ae7d346865b1d">&#9670;&nbsp;</a></span>getNumThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.getNumThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of threads used by OpenCV for parallel regions.</p>
<p>Always returns 1 if OpenCV is built without threading support.</p>
<p>The exact meaning of return value depends on the threading framework used by OpenCV library: </p><ul>
<li>
{code TBB} - The number of threads, that OpenCV will try to use for parallel regions. If there is any tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns default number of threads used by TBB library.  </li>
<li>
{code OpenMP} - An upper bound on the number of threads that could be used to form a new team.  </li>
<li>
{code Concurrency} - The number of threads, that OpenCV will try to use for parallel regions.  </li>
<li>
{code GCD} - Unsupported; returns the GCD thread pool limit (512) for compatibility.  </li>
<li>
{code C=} - The number of threads, that OpenCV will try to use for parallel regions, if before called setNumThreads with threads &gt; 0, otherwise returns the number of logical CPUs, available for the process. SEE: setNumThreads, getThreadNum  </li>
</ul>
<p>return automatically generated </p>

</div>
</div>
<a id="aba395b2232635e6ba829f645871bd06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba395b2232635e6ba829f645871bd06f">&#9670;&nbsp;</a></span>getOptimalDFTSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.getOptimalDFTSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vecsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the optimal DFT size for a given vector size.</p>
<p>DFT performance is not a monotonic function of a vector size. Therefore, when you calculate convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to pad the input data with zeros to get a bit larger array that can be transformed much faster than the original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process. Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5*5*3*2*2) are also processed quite efficiently.</p>
<p>The function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize so that the DFT of a vector of size N can be processed efficiently. In the current implementation N = 2 ^p^ * 3 ^q^ * 5 ^r^ for some integer p, q, r.</p>
<p>The function returns a negative number if vecsize is too large (very close to INT_MAX ).</p>
<p>While the function cannot be used directly to estimate the optimal vector size for DCT transform (since the current DCT implementation supports only even-size vectors), it can be easily processed as getOptimalDFTSize((vecsize+1)/2)*2. param vecsize vector size. SEE: dft , dct , idft , idct , mulSpectrums return automatically generated </p>

</div>
</div>
<a id="a037aadbcc65aab3f55921a6792fd23b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037aadbcc65aab3f55921a6792fd23b0">&#9670;&nbsp;</a></span>getThreadNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.getThreadNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index of the currently executed thread within the current parallel region. Always returns 0 if called outside of parallel region.</p>
<p>deprecated Current implementation doesn't corresponding to this documentation.</p>
<p>The exact meaning of the return value depends on the threading framework used by OpenCV library: </p><ul>
<li>
{code TBB} - Unsupported with current 4.1 TBB release. Maybe will be supported in future.  </li>
<li>
{code OpenMP} - The thread number, within the current team, of the calling thread.  </li>
<li>
{code Concurrency} - An ID for the virtual processor that the current context is executing on (0 for master thread and unique number for others, but not necessary 1,2,3,...).  </li>
<li>
{code GCD} - System calling thread's ID. Never returns 0 inside parallel region.  </li>
<li>
{code C=} - The index of the current parallel task. SEE: setNumThreads, getNumThreads  </li>
</ul>
<p>return automatically generated </p>

</div>
</div>
<a id="a208f302ff9b1a6fe2621eadfe6027664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208f302ff9b1a6fe2621eadfe6027664">&#9670;&nbsp;</a></span>getTickCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long OpenCVForUnity.CoreModule.Core.getTickCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of ticks.</p>
<p>The function returns the number of ticks after the certain event (for example, when the machine was turned on). It can be used to initialize RNG or to measure a function execution time by reading the tick count before and after the function call. SEE: getTickFrequency, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_tick_meter.html">TickMeter</a> return automatically generated </p>

</div>
</div>
<a id="a5d8ef99721a08457355011e970a1c4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8ef99721a08457355011e970a1c4c1">&#9670;&nbsp;</a></span>getTickFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.getTickFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of ticks per second.</p>
<p>The function returns the number of ticks per second. That is, the following code computes the execution time in seconds: <code> double t = (double)<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a208f302ff9b1a6fe2621eadfe6027664">getTickCount()</a>; // do something ... t = ((double)<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a208f302ff9b1a6fe2621eadfe6027664">getTickCount()</a> - t)/getTickFrequency(); </code> SEE: getTickCount, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_tick_meter.html">TickMeter</a> return automatically generated </p>

</div>
</div>
<a id="a5faf7f6ff30aea195991d93be71a2d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faf7f6ff30aea195991d93be71a2d28">&#9670;&nbsp;</a></span>getVersionMajor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.getVersionMajor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns major library version return automatically generated </p>

</div>
</div>
<a id="a7092c590029ef971efa2eb0dc7aa3e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7092c590029ef971efa2eb0dc7aa3e30">&#9670;&nbsp;</a></span>getVersionMinor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.getVersionMinor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns minor library version return automatically generated </p>

</div>
</div>
<a id="a38dccaf5ee65496b0af0e66ac896a7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dccaf5ee65496b0af0e66ac896a7ee">&#9670;&nbsp;</a></span>getVersionRevision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.getVersionRevision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns revision field of the library version return automatically generated </p>

</div>
</div>
<a id="a6c49a3a93e01f2aac900ace2282cf5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c49a3a93e01f2aac900ace2282cf5eb">&#9670;&nbsp;</a></span>getVersionString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string OpenCVForUnity.CoreModule.Core.getVersionString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns library version string</p>
<p>For example "3.4.1-dev".</p>
<p>SEE: getMajorVersion, getMinorVersion, getRevisionVersion return automatically generated </p>

</div>
</div>
<a id="a92e94aeb54835fea90fa1b5ee6798836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e94aeb54835fea90fa1b5ee6798836">&#9670;&nbsp;</a></span>hconcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.hconcat </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code> std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)), cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};</code></p>
<p><code> cv::Mat out; cv::hconcat( matrices, out ); //out: //[1, 2, 3; // 1, 2, 3; // 1, 2, 3; // 1, 2, 3] </code> param src input array or vector of matrices. all of the matrices must have the same number of rows and the same depth. param dst output array. It has the same number of rows and depth as the src, and the sum of cols of the src. same depth. </p>

</div>
</div>
<a id="adbf24e275fe80d5100877eb544f11b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf24e275fe80d5100877eb544f11b7d">&#9670;&nbsp;</a></span>idct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.idct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</p>
<p>idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE). param src input floating-point single-channel array. param dst output array of the same size and type as src. param flags operation flags. SEE: dct, dft, idft, getOptimalDFTSize </p>

</div>
</div>
<a id="a92f31feeb094b72f265f818ec63f819e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f31feeb094b72f265f818ec63f819e">&#9670;&nbsp;</a></span>idct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.idct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</p>
<p>idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE). param src input floating-point single-channel array. param dst output array of the same size and type as src. SEE: dct, dft, idft, getOptimalDFTSize </p>

</div>
</div>
<a id="a76715522aef23c3f9a6f20cc26763fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76715522aef23c3f9a6f20cc26763fbd">&#9670;&nbsp;</a></span>idft() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.idft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nonzeroRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</p>
<p>idft(src, dst, flags) is equivalent to dft(src, dst, flags | <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a>) . <b>Note:</b> None of dft and idft scales the result by default. So, you should pass <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac5b6cafe67cb86f13fa99b3557761dc0">DFT_SCALE</a> to one of dft or idft explicitly to make these transforms mutually inverse. SEE: dft, dct, idct, mulSpectrums, getOptimalDFTSize param src input floating-point real or complex array. param dst output array whose size and type depend on the flags. param flags operation flags (see dft and #DftFlags). param nonzeroRows number of dst rows to process; the rest of the rows have undefined content (see the convolution sample in dft description. </p>

</div>
</div>
<a id="a6051d6f6762ea8f039736f24b652cc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6051d6f6762ea8f039736f24b652cc45">&#9670;&nbsp;</a></span>idft() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.idft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</p>
<p>idft(src, dst, flags) is equivalent to dft(src, dst, flags | <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a>) . <b>Note:</b> None of dft and idft scales the result by default. So, you should pass <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac5b6cafe67cb86f13fa99b3557761dc0">DFT_SCALE</a> to one of dft or idft explicitly to make these transforms mutually inverse. SEE: dft, dct, idct, mulSpectrums, getOptimalDFTSize param src input floating-point real or complex array. param dst output array whose size and type depend on the flags. param flags operation flags (see dft and #DftFlags). the convolution sample in dft description. </p>

</div>
</div>
<a id="a9abb52ac82bcba1b893953c5baad4be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abb52ac82bcba1b893953c5baad4be3">&#9670;&nbsp;</a></span>idft() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.idft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</p>
<p>idft(src, dst, flags) is equivalent to dft(src, dst, flags | <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a>) . <b>Note:</b> None of dft and idft scales the result by default. So, you should pass <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ac5b6cafe67cb86f13fa99b3557761dc0">DFT_SCALE</a> to one of dft or idft explicitly to make these transforms mutually inverse. SEE: dft, dct, idct, mulSpectrums, getOptimalDFTSize param src input floating-point real or complex array. param dst output array whose size and type depend on the flags. the convolution sample in dft description. </p>

</div>
</div>
<a id="a881e6beb9f2729162f910dd65e2553d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881e6beb9f2729162f910dd65e2553d0">&#9670;&nbsp;</a></span>inRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.inRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>lowerb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>upperb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if array elements lie between the elements of two other arrays.</p>
<p>The function checks the range as follows: </p><ul>
<li>
For every element of a single-channel input array: (\texttt{dst} (I)= \texttt{lowerb} (I)_0 \leq \texttt{src} (I)_0 \leq \texttt{upperb} (I)_0)  </li>
<li>
For two-channel arrays: (\texttt{dst} (I)= \texttt{lowerb} (I)_0 \leq \texttt{src} (I)_0 \leq \texttt{upperb} (I)_0 \land \texttt{lowerb} (I)_1 \leq \texttt{src} (I)_1 \leq \texttt{upperb} (I)_1)  </li>
<li>
and so forth.  </li>
</ul>
<p>That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the specified 1D, 2D, 3D, ... box and 0 otherwise.</p>
<p>When the lower and/or upper boundary parameters are scalars, the indexes (I) at lowerb and upperb in the above formulas should be omitted. param src first input array. param lowerb inclusive lower boundary array or a scalar. param upperb inclusive upper boundary array or a scalar. param dst output array of the same size as src and CV_8U type. </p>

</div>
</div>
<a id="a6b9f638028cbb739d65b615f0ef7d400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9f638028cbb739d65b615f0ef7d400">&#9670;&nbsp;</a></span>insertChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.insertChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a single channel to dst (coi is 0-based index) param src input array param dst output array param coi index of channel for insertion SEE: mixChannels, merge </p>

</div>
</div>
<a id="a24d0a5a69b0b5b9e78a46e5028a52a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d0a5a69b0b5b9e78a46e5028a52a26">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the inverse or pseudo-inverse of a matrix.</p>
<p>The function cv::invert inverts the matrix src and stores the result in dst . When the matrix src is singular or non-square, the function calculates the pseudo-inverse matrix (the dst matrix) so that norm(src*dst - I) is minimal, where I is an identity matrix.</p>
<p>In case of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a63de797ce590a1fd08b2a84a9af1c1b7">DECOMP_LU</a> method, the function returns non-zero value if the inverse has been successfully calculated and 0 if src is singular.</p>
<p>In case of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae8a16e6c8d4785ce2d627fcdae6aed83">DECOMP_SVD</a> method, the function returns the inverse condition number of src (the ratio of the smallest singular value to the largest singular value) and 0 if src is singular. The SVD method calculates a pseudo-inverse matrix if src is singular.</p>
<p>Similarly to <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a63de797ce590a1fd08b2a84a9af1c1b7">DECOMP_LU</a>, the method <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53f88f83a383fc769f459b8c7f7f4191">DECOMP_CHOLESKY</a> works only with non-singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in dst and returns non-zero. Otherwise, it returns 0.</p>
<p>param src input floating-point M x N matrix. param dst output matrix of N x M size and the same type as src. param flags inversion method (cv::DecompTypes) SEE: solve, SVD return automatically generated </p>

</div>
</div>
<a id="acb14236ffbede2b4931aa67e78e925b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb14236ffbede2b4931aa67e78e925b8">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the inverse or pseudo-inverse of a matrix.</p>
<p>The function cv::invert inverts the matrix src and stores the result in dst . When the matrix src is singular or non-square, the function calculates the pseudo-inverse matrix (the dst matrix) so that norm(src*dst - I) is minimal, where I is an identity matrix.</p>
<p>In case of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a63de797ce590a1fd08b2a84a9af1c1b7">DECOMP_LU</a> method, the function returns non-zero value if the inverse has been successfully calculated and 0 if src is singular.</p>
<p>In case of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae8a16e6c8d4785ce2d627fcdae6aed83">DECOMP_SVD</a> method, the function returns the inverse condition number of src (the ratio of the smallest singular value to the largest singular value) and 0 if src is singular. The SVD method calculates a pseudo-inverse matrix if src is singular.</p>
<p>Similarly to <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a63de797ce590a1fd08b2a84a9af1c1b7">DECOMP_LU</a>, the method <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53f88f83a383fc769f459b8c7f7f4191">DECOMP_CHOLESKY</a> works only with non-singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in dst and returns non-zero. Otherwise, it returns 0.</p>
<p>param src input floating-point M x N matrix. param dst output matrix of N x M size and the same type as src. SEE: solve, SVD return automatically generated </p>

</div>
</div>
<a id="aa54d4488d95f8ef823bab115c2ec0db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54d4488d95f8ef823bab115c2ec0db6">&#9670;&nbsp;</a></span>kmeans() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.kmeans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>bestLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>centers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds centers of clusters and groups input samples around the clusters.</p>
<p>The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters and groups the input samples around the clusters. As an output, (\texttt{bestLabels}_i) contains a 0-based cluster index for the sample stored in the (i^{th}) row of the samples matrix.</p>
<p><b>Note:</b> </p><ul>
<li>
(Python) An example on K-means clustering can be found at opencv_source_code/samples/python/kmeans.py param data Data for clustering. An array of N-Dimensional points with float coordinates is needed. Examples of this array can be:  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points(count, 2, CV_32F);  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points(count, 1, CV_32FC2);  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points(1, count, CV_32FC2);  </li>
<li>
std::vector&lt;cv::Point2f&gt; points(sampleCount); param K Number of clusters to split the set by. param bestLabels Input/output integer array that stores the cluster indices for every sample. param criteria The algorithm termination criteria, that is, the maximum number of iterations and/or the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster centers moves by less than criteria.epsilon on some iteration, the algorithm stops. param attempts Flag to specify the number of times the algorithm is executed using different initial labellings. The algorithm returns the labels that yield the best compactness (see the last function parameter). param flags Flag that can take values of cv::KmeansFlags param centers Output matrix of the cluster centers, one row per each cluster center. return The function returns the compactness measure that is computed as (\sum _i | \texttt{samples} _i - \texttt{centers} _{ \texttt{labels} _i} | ^2) after every attempt. The best (minimum) value is chosen and the corresponding labels and the compactness value are returned by the function. Basically, you can use only the core of the function, set the number of attempts to 1, initialize labels each time using a custom algorithm, pass them with the ( flags = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#affcb62ffc3700ae98bfb7c59b458ac8d">KMEANS_USE_INITIAL_LABELS</a> ) flag, and then choose the best (most-compact) clustering.  </li>
</ul>

</div>
</div>
<a id="ae86290ef2c416ff00281b94d79014d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86290ef2c416ff00281b94d79014d5e">&#9670;&nbsp;</a></span>kmeans() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.kmeans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>bestLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds centers of clusters and groups input samples around the clusters.</p>
<p>The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters and groups the input samples around the clusters. As an output, (\texttt{bestLabels}_i) contains a 0-based cluster index for the sample stored in the (i^{th}) row of the samples matrix.</p>
<p><b>Note:</b> </p><ul>
<li>
(Python) An example on K-means clustering can be found at opencv_source_code/samples/python/kmeans.py param data Data for clustering. An array of N-Dimensional points with float coordinates is needed. Examples of this array can be:  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points(count, 2, CV_32F);  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points(count, 1, CV_32FC2);  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points(1, count, CV_32FC2);  </li>
<li>
std::vector&lt;cv::Point2f&gt; points(sampleCount); param K Number of clusters to split the set by. param bestLabels Input/output integer array that stores the cluster indices for every sample. param criteria The algorithm termination criteria, that is, the maximum number of iterations and/or the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster centers moves by less than criteria.epsilon on some iteration, the algorithm stops. param attempts Flag to specify the number of times the algorithm is executed using different initial labellings. The algorithm returns the labels that yield the best compactness (see the last function parameter). param flags Flag that can take values of cv::KmeansFlags return The function returns the compactness measure that is computed as (\sum _i | \texttt{samples} _i - \texttt{centers} _{ \texttt{labels} _i} | ^2) after every attempt. The best (minimum) value is chosen and the corresponding labels and the compactness value are returned by the function. Basically, you can use only the core of the function, set the number of attempts to 1, initialize labels each time using a custom algorithm, pass them with the ( flags = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#affcb62ffc3700ae98bfb7c59b458ac8d">KMEANS_USE_INITIAL_LABELS</a> ) flag, and then choose the best (most-compact) clustering.  </li>
</ul>

</div>
</div>
<a id="a9c76e31c90bd954a1f1219b45a080564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c76e31c90bd954a1f1219b45a080564">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the natural logarithm of every array element.</p>
<p>The function cv::log calculates the natural logarithm of every element of the input array: (\texttt{dst} (I) = \log (\texttt{src}(I)) )</p>
<p>Output on zero, negative and special (NaN, Inf) values is undefined.</p>
<p>param src input array. param dst output array of the same size and type as src . SEE: exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude </p>

</div>
</div>
<a id="a0c8383ebe3bcc91813b06c3a5f90395e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8383ebe3bcc91813b06c3a5f90395e">&#9670;&nbsp;</a></span>LUT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.LUT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a look-up table transform of an array.</p>
<p>The function LUT fills the output array with values from the look-up table. Indices of the entries are taken from the input array. That is, the function processes each element of src as follows: (\texttt{dst} (I) \leftarrow \texttt{lut(src(I) + d)}) where (d = \fork{0}{if (\texttt{src}) has depth (\texttt{CV_8U})}{128}{if (\texttt{src}) has depth (\texttt{CV_8S})}) param src input array of 8-bit elements. param lut look-up table of 256 elements; in case of multi-channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input array. param dst output array of the same size and number of channels as src, and the same depth as lut. SEE: convertScaleAbs, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="ade1a02da217526c9612861eb46789b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1a02da217526c9612861eb46789b47">&#9670;&nbsp;</a></span>magnitude()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.magnitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>magnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the magnitude of 2D vectors.</p>
<p>The function cv::magnitude calculates the magnitude of 2D vectors formed from the corresponding elements of x and y arrays: (\texttt{dst} (I) = \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2}) param x floating-point array of x-coordinates of the vectors. param y floating-point array of y-coordinates of the vectors; it must have the same size as x. param magnitude output array of the same size and type as x. SEE: cartToPolar, polarToCart, phase, sqrt </p>

</div>
</div>
<a id="aeb3d1d1e6056d684d93abef86e753818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3d1d1e6056d684d93abef86e753818">&#9670;&nbsp;</a></span>Mahalanobis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.Mahalanobis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>icovar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the Mahalanobis distance between two vectors.</p>
<p>The function cv::Mahalanobis calculates and returns the weighted distance between two vectors: (d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} }) The covariance matrix may be calculated using the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a89874626e1f5ee355645d0ac862d2d00">calcCovarMatrix</a> function and then inverted using the invert function (preferably using the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae8a16e6c8d4785ce2d627fcdae6aed83">DECOMP_SVD</a> method, as the most accurate). param v1 first 1D input vector. param v2 second 1D input vector. param icovar inverse covariance matrix. return automatically generated </p>

</div>
</div>
<a id="aa1336ed734805b0c48ef0b12a5309ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1336ed734805b0c48ef0b12a5309ba9">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates per-element maximum of two arrays or an array and a scalar.</p>
<p>The function cv::max calculates the per-element maximum of two arrays: (\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I))) or array and a scalar: (\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} )) param src1 first input array. param src2 second input array of the same size and type as src1 . param dst output array of the same size and type as src1. SEE: min, compare, inRange, minMaxLoc, REF: MatrixExpressions </p>

</div>
</div>
<a id="a380811a8627ee54507839cf4da54734b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380811a8627ee54507839cf4da54734b">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f0ad71fe7fe4203a49e0cd1c112ec88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0ad71fe7fe4203a49e0cd1c112ec88">&#9670;&nbsp;</a></span>mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> OpenCVForUnity.CoreModule.Core.mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an average (mean) of array elements.</p>
<p>The function cv::mean calculates the mean value M of array elements, independently for each channel, and return it: (\begin{array}{l} N = \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \ M_c = \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}) When all the mask elements are 0's, the function returns Scalar::all(0) param src input array that should have from 1 to 4 channels so that the result can be stored in Scalar_ . param mask optional operation mask. SEE: countNonZero, meanStdDev, norm, minMaxLoc return automatically generated </p>

</div>
</div>
<a id="a1164b01aaba2483b75019a2a0f50603f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1164b01aaba2483b75019a2a0f50603f">&#9670;&nbsp;</a></span>mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> OpenCVForUnity.CoreModule.Core.mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an average (mean) of array elements.</p>
<p>The function cv::mean calculates the mean value M of array elements, independently for each channel, and return it: (\begin{array}{l} N = \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \ M_c = \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}) When all the mask elements are 0's, the function returns Scalar::all(0) param src input array that should have from 1 to 4 channels so that the result can be stored in Scalar_ . SEE: countNonZero, meanStdDev, norm, minMaxLoc return automatically generated </p>

</div>
</div>
<a id="afcf6760a6e549cbe00db6c6a812ca0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf6760a6e549cbe00db6c6a812ca0d2">&#9670;&nbsp;</a></span>meanStdDev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.meanStdDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a>&#160;</td>
          <td class="paramname"><em>stddev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a mean and standard deviation of array elements.</p>
<p>The function cv::meanStdDev calculates the mean and the standard deviation M of array elements independently for each channel and returns it via the output parameters: (\begin{array}{l} N = \sum _{I, \texttt{mask} (I) \ne 0} 1 \ \texttt{mean} _c = \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \ \texttt{stddev} _c = \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c - \texttt{mean} _c \right )^2}{N}} \end{array}) When all the mask elements are 0's, the function returns mean=stddev=Scalar::all(0). <b>Note:</b> The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-channel array M x N to the single-channel array M*N x mtx.channels() (only possible when the matrix is continuous) and then pass the matrix to calcCovarMatrix . param src input array that should have from 1 to 4 channels so that the results can be stored in Scalar_ 's. param mean output parameter: calculated mean value. param stddev output parameter: calculated standard deviation. param mask optional operation mask. SEE: countNonZero, mean, norm, minMaxLoc, calcCovarMatrix </p>

</div>
</div>
<a id="a2b3d6b5417eb7606f96a038f26685c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3d6b5417eb7606f96a038f26685c70">&#9670;&nbsp;</a></span>meanStdDev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.meanStdDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html">MatOfDouble</a>&#160;</td>
          <td class="paramname"><em>stddev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a mean and standard deviation of array elements.</p>
<p>The function cv::meanStdDev calculates the mean and the standard deviation M of array elements independently for each channel and returns it via the output parameters: (\begin{array}{l} N = \sum _{I, \texttt{mask} (I) \ne 0} 1 \ \texttt{mean} _c = \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \ \texttt{stddev} _c = \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c - \texttt{mean} _c \right )^2}{N}} \end{array}) When all the mask elements are 0's, the function returns mean=stddev=Scalar::all(0). <b>Note:</b> The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-channel array M x N to the single-channel array M*N x mtx.channels() (only possible when the matrix is continuous) and then pass the matrix to calcCovarMatrix . param src input array that should have from 1 to 4 channels so that the results can be stored in Scalar_ 's. param mean output parameter: calculated mean value. param stddev output parameter: calculated standard deviation. SEE: countNonZero, mean, norm, minMaxLoc, calcCovarMatrix </p>

</div>
</div>
<a id="acdaec204a321eff54db03f6e0e8fb019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaec204a321eff54db03f6e0e8fb019">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.merge </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param mv input vector of matrices to be merged; all the matrices in mv must have the same size and the same depth. param dst output array of the same size and the same depth as mv[0]; The number of channels will be the total number of channels in the matrix array. </p>

</div>
</div>
<a id="a35e45599d4ec446296d8a21a820fa10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e45599d4ec446296d8a21a820fa10b">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates per-element minimum of two arrays or an array and a scalar.</p>
<p>The function cv::min calculates the per-element minimum of two arrays: (\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I))) or array and a scalar: (\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} )) param src1 first input array. param src2 second input array of the same size and type as src1. param dst output array of the same size and type as src1. SEE: max, compare, inRange, minMaxLoc </p>

</div>
</div>
<a id="a4ca90c8da22eabcad628cfdf1d2b7213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca90c8da22eabcad628cfdf1d2b7213">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a77513b42c6d3d8f9a68b32bf019fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a77513b42c6d3d8f9a68b32bf019fab">&#9670;&nbsp;</a></span>minMaxLoc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core_1_1_min_max_loc_result.html">MinMaxLocResult</a> OpenCVForUnity.CoreModule.Core.minMaxLoc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ffbb5210d7b89d572bf95c20feb5a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffbb5210d7b89d572bf95c20feb5a00">&#9670;&nbsp;</a></span>minMaxLoc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core_1_1_min_max_loc_result.html">MinMaxLocResult</a> OpenCVForUnity.CoreModule.Core.minMaxLoc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab20dda8ab0b7c696f24a023acec9633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab20dda8ab0b7c696f24a023acec9633">&#9670;&nbsp;</a></span>mixChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.mixChannels </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>fromTo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param src input array or vector of matrices; all of the matrices must have the same size and the same depth. param dst output array or vector of matrices; all the matrices <b>must be allocated</b>; their size and depth must be the same as in src[0]. param fromTo array of index pairs specifying which channels are copied and where; fromTo[k*2] is a 0-based index of the input channel in src, fromTo[k*2+1] is an index of the output channel in dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to src[0].channels()-1, the second input image channels are indexed from src[0].channels() to src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image channels; as a special case, when fromTo[k*2] is negative, the corresponding output channel is filled with zero . </p>

</div>
</div>
<a id="a5714f19d1cbee3f5222d1ad5cfac9c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5714f19d1cbee3f5222d1ad5cfac9c11">&#9670;&nbsp;</a></span>mulSpectrums() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.mulSpectrums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the per-element multiplication of two Fourier spectrums.</p>
<p>The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex matrices that are results of a real or complex Fourier transform.</p>
<p>The function, together with dft and idft , may be used to calculate convolution (pass conjB=false ) or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-array elements. When the arrays are real, they are assumed to be CCS-packed (see dft for details). param a first input array. param b second input array of the same size and type as src1 . param c output array of the same size and type as src1 . param flags operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a {code 0} as value. param conjB optional flag that conjugates the second input array before the multiplication (true) or not (false). </p>

</div>
</div>
<a id="ab997b9a46a2c74bfd91e0e4ac157c0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab997b9a46a2c74bfd91e0e4ac157c0df">&#9670;&nbsp;</a></span>mulSpectrums() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.mulSpectrums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the per-element multiplication of two Fourier spectrums.</p>
<p>The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex matrices that are results of a real or complex Fourier transform.</p>
<p>The function, together with dft and idft , may be used to calculate convolution (pass conjB=false ) or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-array elements. When the arrays are real, they are assumed to be CCS-packed (see dft for details). param a first input array. param b second input array of the same size and type as src1 . param c output array of the same size and type as src1 . param flags operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a {code 0} as value. or not (false). </p>

</div>
</div>
<a id="a0e05566c60eecf6f42961a76bf86e7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e05566c60eecf6f42961a76bf86e7ec">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element scaled product of two arrays.</p>
<p>The function multiply calculates the per-element product of two arrays:</p>
<p>(\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I) \cdot \texttt{src2} (I)))</p>
<p>There is also a REF: MatrixExpressions -friendly variant of the first function. See <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a2f71afba9acec61497456f922282abdb">Mat::mul</a> .</p>
<p>For a not-per-element matrix product, see gemm .</p>
<p><b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param src2 second input array of the same size and the same type as src1. param dst output array of the same size and type as src1. param scale optional scale factor. param dtype optional depth of the output array SEE: add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a5011f045493b48e7233dead0c2c6cc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5011f045493b48e7233dead0c2c6cc9f">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element scaled product of two arrays.</p>
<p>The function multiply calculates the per-element product of two arrays:</p>
<p>(\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I) \cdot \texttt{src2} (I)))</p>
<p>There is also a REF: MatrixExpressions -friendly variant of the first function. See <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a2f71afba9acec61497456f922282abdb">Mat::mul</a> .</p>
<p>For a not-per-element matrix product, see gemm .</p>
<p><b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param src2 second input array of the same size and the same type as src1. param dst output array of the same size and type as src1. param scale optional scale factor. SEE: add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="ad87451b21ef4049e95478954a61e95ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87451b21ef4049e95478954a61e95ff">&#9670;&nbsp;</a></span>multiply() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element scaled product of two arrays.</p>
<p>The function multiply calculates the per-element product of two arrays:</p>
<p>(\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I) \cdot \texttt{src2} (I)))</p>
<p>There is also a REF: MatrixExpressions -friendly variant of the first function. See <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a2f71afba9acec61497456f922282abdb">Mat::mul</a> .</p>
<p>For a not-per-element matrix product, see gemm .</p>
<p><b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array. param src2 second input array of the same size and the same type as src1. param dst output array of the same size and type as src1. SEE: add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a268ce4190e2c24305724e19c378f07e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268ce4190e2c24305724e19c378f07e8">&#9670;&nbsp;</a></span>multiply() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04dc5baa3e60baa1baaeeb42600aa8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc5baa3e60baa1baaeeb42600aa8a0">&#9670;&nbsp;</a></span>multiply() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adeaf1521286d0e1cbd174aed9c56d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaf1521286d0e1cbd174aed9c56d90e">&#9670;&nbsp;</a></span>multiply() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90717e930baaeea7cc2aba0afbd72de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90717e930baaeea7cc2aba0afbd72de7">&#9670;&nbsp;</a></span>mulTransposed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.mulTransposed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aTa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the product of a matrix and its transposition.</p>
<p>The function cv::mulTransposed calculates the product of src and its transposition: (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )) if aTa=true , and (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T) otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product A*B when B=A' param src input single-channel matrix. Note that unlike gemm, the function can multiply not only floating-point matrices. param dst output square matrix. param aTa Flag specifying the multiplication ordering. See the description below. param delta Optional delta matrix subtracted from src before the multiplication. When the matrix is empty ( delta=noArray() ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as src , it is simply subtracted. Otherwise, it is "repeated" (see repeat ) to cover the full src and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the dtype parameter description below. param scale Optional scale factor for the matrix product. param dtype Optional type of the output matrix. When it is negative, the output matrix will have the same type as src . Otherwise, it will be type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F . SEE: calcCovarMatrix, gemm, repeat, reduce </p>

</div>
</div>
<a id="aacc6993f35356ec2d78df92674ced2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc6993f35356ec2d78df92674ced2fe">&#9670;&nbsp;</a></span>mulTransposed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.mulTransposed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aTa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the product of a matrix and its transposition.</p>
<p>The function cv::mulTransposed calculates the product of src and its transposition: (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )) if aTa=true , and (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T) otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product A*B when B=A' param src input single-channel matrix. Note that unlike gemm, the function can multiply not only floating-point matrices. param dst output square matrix. param aTa Flag specifying the multiplication ordering. See the description below. param delta Optional delta matrix subtracted from src before the multiplication. When the matrix is empty ( delta=noArray() ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as src , it is simply subtracted. Otherwise, it is "repeated" (see repeat ) to cover the full src and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the dtype parameter description below. param scale Optional scale factor for the matrix product. the output matrix will have the same type as src . Otherwise, it will be type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F . SEE: calcCovarMatrix, gemm, repeat, reduce </p>

</div>
</div>
<a id="a53ab9142ca92ee4dcf896095b4933b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ab9142ca92ee4dcf896095b4933b8d">&#9670;&nbsp;</a></span>mulTransposed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.mulTransposed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aTa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the product of a matrix and its transposition.</p>
<p>The function cv::mulTransposed calculates the product of src and its transposition: (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )) if aTa=true , and (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T) otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product A*B when B=A' param src input single-channel matrix. Note that unlike gemm, the function can multiply not only floating-point matrices. param dst output square matrix. param aTa Flag specifying the multiplication ordering. See the description below. param delta Optional delta matrix subtracted from src before the multiplication. When the matrix is empty ( delta=noArray() ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as src , it is simply subtracted. Otherwise, it is "repeated" (see repeat ) to cover the full src and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the dtype parameter description below. the output matrix will have the same type as src . Otherwise, it will be type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F . SEE: calcCovarMatrix, gemm, repeat, reduce </p>

</div>
</div>
<a id="a5d59e704f2c17ee2d5bed51ec165eea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d59e704f2c17ee2d5bed51ec165eea3">&#9670;&nbsp;</a></span>mulTransposed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.mulTransposed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aTa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the product of a matrix and its transposition.</p>
<p>The function cv::mulTransposed calculates the product of src and its transposition: (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )) if aTa=true , and (\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T) otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product A*B when B=A' param src input single-channel matrix. Note that unlike gemm, the function can multiply not only floating-point matrices. param dst output square matrix. param aTa Flag specifying the multiplication ordering. See the description below. multiplication. When the matrix is empty ( delta=noArray() ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as src , it is simply subtracted. Otherwise, it is "repeated" (see repeat ) to cover the full src and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the dtype parameter description below. the output matrix will have the same type as src . Otherwise, it will be type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F . SEE: calcCovarMatrix, gemm, repeat, reduce </p>

</div>
</div>
<a id="ae81a2df0a3d87ba2f825cb2b2455294e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81a2df0a3d87ba2f825cb2b2455294e">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an absolute difference norm or a relative difference norm.</p>
<p>This version of cv::norm calculates the absolute difference norm or the relative difference norm of arrays src1 and src2. The type of norm to calculate is specified using #NormTypes.</p>
<p>param src1 first input array. param src2 second input array of the same size and the same type as src1. param normType type of the norm (see #NormTypes). param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type. return automatically generated </p>

</div>
</div>
<a id="a685fe6d481dc54a93309a5ead50df724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685fe6d481dc54a93309a5ead50df724">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an absolute difference norm or a relative difference norm.</p>
<p>This version of cv::norm calculates the absolute difference norm or the relative difference norm of arrays src1 and src2. The type of norm to calculate is specified using #NormTypes.</p>
<p>param src1 first input array. param src2 second input array of the same size and the same type as src1. param normType type of the norm (see #NormTypes). return automatically generated </p>

</div>
</div>
<a id="a9281563c5a9e1a03c05cfe6a5a0c82c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9281563c5a9e1a03c05cfe6a5a0c82c8">&#9670;&nbsp;</a></span>norm() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an absolute difference norm or a relative difference norm.</p>
<p>This version of cv::norm calculates the absolute difference norm or the relative difference norm of arrays src1 and src2. The type of norm to calculate is specified using #NormTypes.</p>
<p>param src1 first input array. param src2 second input array of the same size and the same type as src1. return automatically generated </p>

</div>
</div>
<a id="a3bf26dfc459ee5f93f684bed9dc2f0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf26dfc459ee5f93f684bed9dc2f0a9">&#9670;&nbsp;</a></span>norm() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the absolute norm of an array.</p>
<p>This version of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae81a2df0a3d87ba2f825cb2b2455294e">norm</a> calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.</p>
<p>As example for one array consider the function (r(x)= \begin{pmatrix} x \ 1-x \end{pmatrix}, x \in [-1;1]). The ( L_{1}, L_{2} ) and ( L_{\infty} ) norm for the sample value (r(-1) = \begin{pmatrix} -1 \ 2 \end{pmatrix}) is calculated as follows (align*} | r(-1) |_{L_1} &amp;= |-1| + |2| = 3 \ | r(-1) |_{L_2} &amp;= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \ | r(-1) |_{L_\infty} &amp;= \max(|-1|,|2|) = 2 ) and for (r(0.5) = \begin{pmatrix} 0.5 \ 0.5 \end{pmatrix}) the calculation is (align*} | r(0.5) |_{L_1} &amp;= |0.5| + |0.5| = 1 \ | r(0.5) |_{L_2} &amp;= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \ | r(0.5) |_{L_\infty} &amp;= \max(|0.5|,|0.5|) = 0.5. ) The following graphic shows all values for the three norm functions (| r(x) |_{L_1}, | r(x) |_{L_2}) and (| r(x) |_{L_\infty}). It is notable that the ( L_{1} ) norm forms the upper and the ( L_{\infty} ) norm forms the lower border for the example function ( r(x) ). <img src="pics/NormTypes_OneArray_1-2-INF.png" alt="Graphs for the different norm functions from the above example" class="inline"/>
<p>When the mask parameter is specified and it is not empty, the norm is</p>
<p>If normType is not specified, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad2efcd606f3e551028491c4e4a68ef65">NORM_L2</a> is used. calculated only over the region specified by the mask.</p>
<p>Multi-channel input arrays are treated as single-channel arrays, that is, the results for all channels are combined.</p>
<p>Hamming norms can only be calculated with CV_8U depth arrays.</p>
<p>param src1 first input array. param normType type of the norm (see #NormTypes). param mask optional operation mask; it must have the same size as src1 and CV_8UC1 type. return automatically generated </p>

</div>
</div>
<a id="ae520c3a230b3881ff13c2d2149354dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae520c3a230b3881ff13c2d2149354dd4">&#9670;&nbsp;</a></span>norm() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the absolute norm of an array.</p>
<p>This version of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae81a2df0a3d87ba2f825cb2b2455294e">norm</a> calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.</p>
<p>As example for one array consider the function (r(x)= \begin{pmatrix} x \ 1-x \end{pmatrix}, x \in [-1;1]). The ( L_{1}, L_{2} ) and ( L_{\infty} ) norm for the sample value (r(-1) = \begin{pmatrix} -1 \ 2 \end{pmatrix}) is calculated as follows (align*} | r(-1) |_{L_1} &amp;= |-1| + |2| = 3 \ | r(-1) |_{L_2} &amp;= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \ | r(-1) |_{L_\infty} &amp;= \max(|-1|,|2|) = 2 ) and for (r(0.5) = \begin{pmatrix} 0.5 \ 0.5 \end{pmatrix}) the calculation is (align*} | r(0.5) |_{L_1} &amp;= |0.5| + |0.5| = 1 \ | r(0.5) |_{L_2} &amp;= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \ | r(0.5) |_{L_\infty} &amp;= \max(|0.5|,|0.5|) = 0.5. ) The following graphic shows all values for the three norm functions (| r(x) |_{L_1}, | r(x) |_{L_2}) and (| r(x) |_{L_\infty}). It is notable that the ( L_{1} ) norm forms the upper and the ( L_{\infty} ) norm forms the lower border for the example function ( r(x) ). <img src="pics/NormTypes_OneArray_1-2-INF.png" alt="Graphs for the different norm functions from the above example" class="inline"/>
<p>When the mask parameter is specified and it is not empty, the norm is</p>
<p>If normType is not specified, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad2efcd606f3e551028491c4e4a68ef65">NORM_L2</a> is used. calculated only over the region specified by the mask.</p>
<p>Multi-channel input arrays are treated as single-channel arrays, that is, the results for all channels are combined.</p>
<p>Hamming norms can only be calculated with CV_8U depth arrays.</p>
<p>param src1 first input array. param normType type of the norm (see #NormTypes). return automatically generated </p>

</div>
</div>
<a id="a7867ef1188bdceb5a37de2949f269cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7867ef1188bdceb5a37de2949f269cf5">&#9670;&nbsp;</a></span>norm() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the absolute norm of an array.</p>
<p>This version of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ae81a2df0a3d87ba2f825cb2b2455294e">norm</a> calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.</p>
<p>As example for one array consider the function (r(x)= \begin{pmatrix} x \ 1-x \end{pmatrix}, x \in [-1;1]). The ( L_{1}, L_{2} ) and ( L_{\infty} ) norm for the sample value (r(-1) = \begin{pmatrix} -1 \ 2 \end{pmatrix}) is calculated as follows (align*} | r(-1) |_{L_1} &amp;= |-1| + |2| = 3 \ | r(-1) |_{L_2} &amp;= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \ | r(-1) |_{L_\infty} &amp;= \max(|-1|,|2|) = 2 ) and for (r(0.5) = \begin{pmatrix} 0.5 \ 0.5 \end{pmatrix}) the calculation is (align*} | r(0.5) |_{L_1} &amp;= |0.5| + |0.5| = 1 \ | r(0.5) |_{L_2} &amp;= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \ | r(0.5) |_{L_\infty} &amp;= \max(|0.5|,|0.5|) = 0.5. ) The following graphic shows all values for the three norm functions (| r(x) |_{L_1}, | r(x) |_{L_2}) and (| r(x) |_{L_\infty}). It is notable that the ( L_{1} ) norm forms the upper and the ( L_{\infty} ) norm forms the lower border for the example function ( r(x) ). <img src="pics/NormTypes_OneArray_1-2-INF.png" alt="Graphs for the different norm functions from the above example" class="inline"/>
<p>When the mask parameter is specified and it is not empty, the norm is</p>
<p>If normType is not specified, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#ad2efcd606f3e551028491c4e4a68ef65">NORM_L2</a> is used. calculated only over the region specified by the mask.</p>
<p>Multi-channel input arrays are treated as single-channel arrays, that is, the results for all channels are combined.</p>
<p>Hamming norms can only be calculated with CV_8U depth arrays.</p>
<p>param src1 first input array. return automatically generated </p>

</div>
</div>
<a id="af19b75b7e7925326f558bbdecdf7537f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19b75b7e7925326f558bbdecdf7537f">&#9670;&nbsp;</a></span>normalize() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the norm or value range of an array.</p>
<p>The function cv::normalize normalizes scale and shift the input array elements so that (| \texttt{dst} | _{L_p}= \texttt{alpha}) (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that (\min _I \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I \texttt{dst} (I)= \texttt{beta})</p>
<p>when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>.</p>
<p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p>
<p>Possible usage with some positive example data: <code> vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;</code></p>
<p><code> // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);</code></p>
<p><code> // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);</code></p>
<p><code> // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);</code></p>
<p><code> // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); </code></p>
<p>param src input array. param dst output array of the same size as src . param alpha norm value to normalize to or the lower range boundary in case of the range normalization. param beta upper range boundary in case of the range normalization; it is not used for the norm normalization. param norm_type normalization type (see cv::NormTypes). param dtype when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth =CV_MAT_DEPTH(dtype). param mask optional operation mask. SEE: norm, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, SparseMat::convertTo </p>

</div>
</div>
<a id="aa3fd11cdb823851d118090099fc8a53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fd11cdb823851d118090099fc8a53c">&#9670;&nbsp;</a></span>normalize() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the norm or value range of an array.</p>
<p>The function cv::normalize normalizes scale and shift the input array elements so that (| \texttt{dst} | _{L_p}= \texttt{alpha}) (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that (\min _I \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I \texttt{dst} (I)= \texttt{beta})</p>
<p>when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>.</p>
<p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p>
<p>Possible usage with some positive example data: <code> vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;</code></p>
<p><code> // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);</code></p>
<p><code> // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);</code></p>
<p><code> // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);</code></p>
<p><code> // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); </code></p>
<p>param src input array. param dst output array of the same size as src . param alpha norm value to normalize to or the lower range boundary in case of the range normalization. param beta upper range boundary in case of the range normalization; it is not used for the norm normalization. param norm_type normalization type (see cv::NormTypes). param dtype when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth =CV_MAT_DEPTH(dtype). SEE: norm, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, SparseMat::convertTo </p>

</div>
</div>
<a id="a2be4215c7b5181e90d5b0701bcbca19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be4215c7b5181e90d5b0701bcbca19a">&#9670;&nbsp;</a></span>normalize() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the norm or value range of an array.</p>
<p>The function cv::normalize normalizes scale and shift the input array elements so that (| \texttt{dst} | _{L_p}= \texttt{alpha}) (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that (\min _I \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I \texttt{dst} (I)= \texttt{beta})</p>
<p>when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>.</p>
<p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p>
<p>Possible usage with some positive example data: <code> vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;</code></p>
<p><code> // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);</code></p>
<p><code> // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);</code></p>
<p><code> // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);</code></p>
<p><code> // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); </code></p>
<p>param src input array. param dst output array of the same size as src . param alpha norm value to normalize to or the lower range boundary in case of the range normalization. param beta upper range boundary in case of the range normalization; it is not used for the norm normalization. param norm_type normalization type (see cv::NormTypes). number of channels as src and the depth =CV_MAT_DEPTH(dtype). SEE: norm, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, SparseMat::convertTo </p>

</div>
</div>
<a id="ad43c037b64e2653596c77851097f31d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43c037b64e2653596c77851097f31d5">&#9670;&nbsp;</a></span>normalize() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the norm or value range of an array.</p>
<p>The function cv::normalize normalizes scale and shift the input array elements so that (| \texttt{dst} | _{L_p}= \texttt{alpha}) (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that (\min _I \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I \texttt{dst} (I)= \texttt{beta})</p>
<p>when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>.</p>
<p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p>
<p>Possible usage with some positive example data: <code> vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;</code></p>
<p><code> // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);</code></p>
<p><code> // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);</code></p>
<p><code> // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);</code></p>
<p><code> // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); </code></p>
<p>param src input array. param dst output array of the same size as src . param alpha norm value to normalize to or the lower range boundary in case of the range normalization. param beta upper range boundary in case of the range normalization; it is not used for the norm normalization. number of channels as src and the depth =CV_MAT_DEPTH(dtype). SEE: norm, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, SparseMat::convertTo </p>

</div>
</div>
<a id="a4233122f27ebefa148d7fc9c93d76af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4233122f27ebefa148d7fc9c93d76af8">&#9670;&nbsp;</a></span>normalize() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the norm or value range of an array.</p>
<p>The function cv::normalize normalizes scale and shift the input array elements so that (| \texttt{dst} | _{L_p}= \texttt{alpha}) (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that (\min _I \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I \texttt{dst} (I)= \texttt{beta})</p>
<p>when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>.</p>
<p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p>
<p>Possible usage with some positive example data: <code> vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;</code></p>
<p><code> // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);</code></p>
<p><code> // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);</code></p>
<p><code> // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);</code></p>
<p><code> // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); </code></p>
<p>param src input array. param dst output array of the same size as src . param alpha norm value to normalize to or the lower range boundary in case of the range normalization. normalization. number of channels as src and the depth =CV_MAT_DEPTH(dtype). SEE: norm, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, SparseMat::convertTo </p>

</div>
</div>
<a id="a4cc3cf19d614754f9c8245b98fa44ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc3cf19d614754f9c8245b98fa44ecd">&#9670;&nbsp;</a></span>normalize() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the norm or value range of an array.</p>
<p>The function cv::normalize normalizes scale and shift the input array elements so that (| \texttt{dst} | _{L_p}= \texttt{alpha}) (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that (\min _I \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I \texttt{dst} (I)= \texttt{beta})</p>
<p>when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>.</p>
<p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p>
<p>Possible usage with some positive example data: <code> vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 }; vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;</code></p>
<p><code> // Norm to probability (total count) // sum(numbers) = 20.0 // 2.0 0.1 (2.0/20.0) // 8.0 0.4 (8.0/20.0) // 10.0 0.5 (10.0/20.0) normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);</code></p>
<p><code> // Norm to unit vector: ||positiveData|| = 1.0 // 2.0 0.15 // 8.0 0.62 // 10.0 0.77 normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);</code></p>
<p><code> // Norm to max element // 2.0 0.2 (2.0/10.0) // 8.0 0.8 (8.0/10.0) // 10.0 1.0 (10.0/10.0) normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);</code></p>
<p><code> // Norm to range [0.0;1.0] // 2.0 0.0 (shift to left border) // 8.0 0.75 (6.0/8.0) // 10.0 1.0 (shift to right border) normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX); </code></p>
<p>param src input array. param dst output array of the same size as src . normalization. normalization. number of channels as src and the depth =CV_MAT_DEPTH(dtype). SEE: norm, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a>, SparseMat::convertTo </p>

</div>
</div>
<a id="a6159442437f889f168248da55a5356cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6159442437f889f168248da55a5356cb">&#9670;&nbsp;</a></span>patchNaNs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.patchNaNs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>converts NaN's to the given number param a automatically generated param val automatically generated </p>

</div>
</div>
<a id="a4f8c8d3be495fcb57e3e9289a23d0a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8c8d3be495fcb57e3e9289a23d0a78">&#9670;&nbsp;</a></span>patchNaNs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.patchNaNs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>converts NaN's to the given number param a automatically generated </p>

</div>
</div>
<a id="a7703d5fc634f9729ff14ecb2391657d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7703d5fc634f9729ff14ecb2391657d8">&#9670;&nbsp;</a></span>PCABackProject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCABackProject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::backProject param data automatically generated param mean automatically generated param eigenvectors automatically generated param result automatically generated </p>

</div>
</div>
<a id="a684eaf52058395dbccb59ee237dedb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684eaf52058395dbccb59ee237dedb56">&#9670;&nbsp;</a></span>PCACompute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCACompute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>retainedVariance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::operator() param data automatically generated param mean automatically generated param eigenvectors automatically generated param retainedVariance automatically generated </p>

</div>
</div>
<a id="a7f2fd927fb4be8445413935cbcf08ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2fd927fb4be8445413935cbcf08ae8">&#9670;&nbsp;</a></span>PCACompute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCACompute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::operator() param data automatically generated param mean automatically generated param eigenvectors automatically generated param maxComponents automatically generated </p>

</div>
</div>
<a id="abb6649a63ea7c46f068c3d86f8dc573d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6649a63ea7c46f068c3d86f8dc573d">&#9670;&nbsp;</a></span>PCACompute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCACompute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::operator() param data automatically generated param mean automatically generated param eigenvectors automatically generated </p>

</div>
</div>
<a id="adf2ab6785c337f0f6191141ca202a3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2ab6785c337f0f6191141ca202a3be">&#9670;&nbsp;</a></span>PCACompute2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCACompute2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>retainedVariance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::operator() and add eigenvalues output parameter param data automatically generated param mean automatically generated param eigenvectors automatically generated param eigenvalues automatically generated param retainedVariance automatically generated </p>

</div>
</div>
<a id="a6003198cec970cdfabde698a5a3b1209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6003198cec970cdfabde698a5a3b1209">&#9670;&nbsp;</a></span>PCACompute2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCACompute2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::operator() and add eigenvalues output parameter param data automatically generated param mean automatically generated param eigenvectors automatically generated param eigenvalues automatically generated param maxComponents automatically generated </p>

</div>
</div>
<a id="acc849aa6f04b413be7faefbbe3987497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc849aa6f04b413be7faefbbe3987497">&#9670;&nbsp;</a></span>PCACompute2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCACompute2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::operator() and add eigenvalues output parameter param data automatically generated param mean automatically generated param eigenvectors automatically generated param eigenvalues automatically generated </p>

</div>
</div>
<a id="a3140e53c41ee1949d0b4859be377cabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3140e53c41ee1949d0b4859be377cabd">&#9670;&nbsp;</a></span>PCAProject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.PCAProject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap PCA::project param data automatically generated param mean automatically generated param eigenvectors automatically generated param result automatically generated </p>

</div>
</div>
<a id="aea962c2e506b4c90e2a9b068ca30125f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea962c2e506b4c90e2a9b068ca30125f">&#9670;&nbsp;</a></span>perspectiveTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.perspectiveTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the perspective matrix transformation of vectors.</p>
<p>The function cv::perspectiveTransform transforms every element of src by treating it as a 2D or 3D vector, in the following way: ((x, y, z) \rightarrow (x'/w, y'/w, z'/w)) where ((x', y', z', w') = \texttt{mat} \cdot \begin{bmatrix} x &amp; y &amp; z &amp; 1 \end{bmatrix}) and (w = \fork{w'}{if (w' \ne 0)}{\infty}{otherwise})</p>
<p>Here a 3D vector transformation is shown. In case of a 2D vector transformation, the z component is omitted.</p>
<p><b>Note:</b> The function transforms a sparse set of 2D or 3D vectors. If you want to transform an image using perspective transformation, use warpPerspective . If you have an inverse problem, that is, you want to compute the most probable perspective transformation out of several pairs of corresponding points, you can use getPerspectiveTransform or findHomography . param src input two-channel or three-channel floating-point array; each element is a 2D/3D vector to be transformed. param dst output array of the same size and type as src. param m 3x3 or 4x4 floating-point transformation matrix. SEE: transform, warpPerspective, getPerspectiveTransform, findHomography </p>

</div>
</div>
<a id="aa78f3f073856ed4f96d12f2053055b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78f3f073856ed4f96d12f2053055b48">&#9670;&nbsp;</a></span>phase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.phase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>angleInDegrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the rotation angle of 2D vectors.</p>
<p>The function cv::phase calculates the rotation angle of each 2D vector that is formed from the corresponding elements of x and y : (\texttt{angle} (I) = \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I)))</p>
<p>The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 , the corresponding angle(I) is set to 0. param x input floating-point array of x-coordinates of 2D vectors. param y input array of y-coordinates of 2D vectors; it must have the same size and the same type as x. param angle output array of vector angles; it has the same size and same type as x . param angleInDegrees when true, the function calculates the angle in degrees, otherwise, they are measured in radians. </p>

</div>
</div>
<a id="a9f35e75c9428f78569c6b6f20300220b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f35e75c9428f78569c6b6f20300220b">&#9670;&nbsp;</a></span>phase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.phase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the rotation angle of 2D vectors.</p>
<p>The function cv::phase calculates the rotation angle of each 2D vector that is formed from the corresponding elements of x and y : (\texttt{angle} (I) = \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I)))</p>
<p>The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 , the corresponding angle(I) is set to 0. param x input floating-point array of x-coordinates of 2D vectors. param y input array of y-coordinates of 2D vectors; it must have the same size and the same type as x. param angle output array of vector angles; it has the same size and same type as x . degrees, otherwise, they are measured in radians. </p>

</div>
</div>
<a id="a38c517d61b3aa460dac7847512483c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c517d61b3aa460dac7847512483c4d">&#9670;&nbsp;</a></span>polarToCart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.polarToCart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>angleInDegrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates x and y coordinates of 2D vectors from their magnitude and angle.</p>
<p>The function cv::polarToCart calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of magnitude and angle: (\begin{array}{l} \texttt{x} (I) = \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \ \texttt{y} (I) = \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \ \end{array})</p>
<p>The relative accuracy of the estimated coordinates is about 1e-6. param magnitude input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle. param angle input floating-point array of angles of 2D vectors. param x output array of x-coordinates of 2D vectors; it has the same size and type as angle. param y output array of y-coordinates of 2D vectors; it has the same size and type as angle. param angleInDegrees when true, the input angles are measured in degrees, otherwise, they are measured in radians. SEE: cartToPolar, magnitude, phase, exp, log, pow, sqrt </p>

</div>
</div>
<a id="a9c65bd4040f9c8a8c975b11dcc126125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c65bd4040f9c8a8c975b11dcc126125">&#9670;&nbsp;</a></span>polarToCart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.polarToCart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates x and y coordinates of 2D vectors from their magnitude and angle.</p>
<p>The function cv::polarToCart calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of magnitude and angle: (\begin{array}{l} \texttt{x} (I) = \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \ \texttt{y} (I) = \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \ \end{array})</p>
<p>The relative accuracy of the estimated coordinates is about 1e-6. param magnitude input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle. param angle input floating-point array of angles of 2D vectors. param x output array of x-coordinates of 2D vectors; it has the same size and type as angle. param y output array of y-coordinates of 2D vectors; it has the same size and type as angle. degrees, otherwise, they are measured in radians. SEE: cartToPolar, magnitude, phase, exp, log, pow, sqrt </p>

</div>
</div>
<a id="acaff667376988a457d21993b511f0763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaff667376988a457d21993b511f0763">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Raises every array element to a power.</p>
<p>The function cv::pow raises every element of the input array to power : (\texttt{dst} (I) = \fork{\texttt{src}(I)^{power}}{if (\texttt{power}) is integer}{|\texttt{src}(I)|^{power}}{otherwise})</p>
<p>So, for a non-integer power exponent, the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations. In the example below, computing the 5th root of array src shows: <code> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask = src &lt; 0; pow(src, 1./5, dst); subtract(Scalar::all(0), dst, dst, mask); </code> For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.</p>
<p>Special values (NaN, Inf) are not handled. param src input array. param power exponent of power. param dst output array of the same size and type as src. SEE: sqrt, exp, log, cartToPolar, polarToCart </p>

</div>
</div>
<a id="af0f1d595e05155f3a617c93d63a8b499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f1d595e05155f3a617c93d63a8b499">&#9670;&nbsp;</a></span>PSNR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.PSNR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.</p>
<p>This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB), between two input arrays src1 and src2. The arrays must have the same type.</p>
<p>The PSNR is calculated as follows:</p>
<p>( \texttt{PSNR} = 10 \cdot \log_{10}{\left( \frac{R^2}{MSE} \right) } )</p>
<p>where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data) and MSE is the mean squared error between the two arrays.</p>
<p>param src1 first input array. param src2 second input array of the same size as src1. param R the maximum pixel value (255 by default) return automatically generated </p>

</div>
</div>
<a id="a979c224c69e41feba8ef7044fb7850bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979c224c69e41feba8ef7044fb7850bc">&#9670;&nbsp;</a></span>PSNR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.PSNR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.</p>
<p>This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB), between two input arrays src1 and src2. The arrays must have the same type.</p>
<p>The PSNR is calculated as follows:</p>
<p>( \texttt{PSNR} = 10 \cdot \log_{10}{\left( \frac{R^2}{MSE} \right) } )</p>
<p>where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data) and MSE is the mean squared error between the two arrays.</p>
<p>param src1 first input array. param src2 second input array of the same size as src1. return automatically generated </p>

</div>
</div>
<a id="a7dab1ed5c31ee30b2492e3c8d903ce80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dab1ed5c31ee30b2492e3c8d903ce80">&#9670;&nbsp;</a></span>randn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.randn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stddev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the array with normally distributed random numbers.</p>
<p>The function cv::randn fills the matrix dst with normally distributed random numbers with the specified mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the value range of the output array data type. param dst output array of random numbers; the array must be pre-allocated and have 1 to 4 channels. param mean mean value (expectation) of the generated random numbers. param stddev standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix. SEE: RNG, randu </p>

</div>
</div>
<a id="a726398cf4782f2168146bfb60e4d84c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726398cf4782f2168146bfb60e4d84c3">&#9670;&nbsp;</a></span>randShuffle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.randShuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iterFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shuffles the array elements randomly.</p>
<p>The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and swapping them. The number of such swap operations will be dst.rows*dst.cols*iterFactor . param dst input/output numerical 1D array. param iterFactor scale factor that determines the number of random swap operations (see the details below). instead. SEE: RNG, sort </p>

</div>
</div>
<a id="ad1216a0014e796dd1105dd52e7e7d02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1216a0014e796dd1105dd52e7e7d02b">&#9670;&nbsp;</a></span>randShuffle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.randShuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shuffles the array elements randomly.</p>
<p>The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and swapping them. The number of such swap operations will be dst.rows*dst.cols*iterFactor . param dst input/output numerical 1D array. below). instead. SEE: RNG, sort </p>

</div>
</div>
<a id="aeb61cab7f3564055720e2fd36b8166a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb61cab7f3564055720e2fd36b8166a9">&#9670;&nbsp;</a></span>randu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.randu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a single uniformly-distributed random number or an array of random numbers.</p>
<p>Non-template variant of the function fills the matrix dst with uniformly-distributed random numbers from the specified range: (\texttt{low} _c \leq \texttt{dst} (I)_c &lt; \texttt{high} _c) param dst output array of random numbers; the array must be pre-allocated. param low inclusive lower boundary of the generated random numbers. param high exclusive upper boundary of the generated random numbers. SEE: RNG, randn, theRNG </p>

</div>
</div>
<a id="a169446607306d71f35adcff40aa4d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169446607306d71f35adcff40aa4d6e5">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reduces a matrix to a vector.</p>
<p>The function <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a169446607306d71f35adcff40aa4d6e5">reduce</a> reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a03fa60b83c36239a2dd4465a191532e7">REDUCE_MAX</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0a075bfcc77682c67dcef57d7e40219c">REDUCE_MIN</a> , the output image should have the same type as the source one. In case of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af2e1a540a681ff0c8b9c47aef279a60f">REDUCE_SUM</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a09e2005ddc6cfe8308a55a1252a5d55f">REDUCE_AVG</a> , the output may have a larger element bit-depth to preserve accuracy. And multi-channel arrays are also supported in these two reduction modes.</p>
<p>The following code demonstrates its usage for a single channel matrix. SNIPPET: snippets/core_reduce.cpp example</p>
<p>And the following code demonstrates its usage for a two-channel matrix. SNIPPET: snippets/core_reduce.cpp example2</p>
<p>param src input 2D matrix. param dst output vector. Its size and type is defined by dim and dtype parameters. param dim dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column. param rtype reduction operation that could be one of #ReduceTypes param dtype when negative, the output vector will have the same type as the input matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()). SEE: repeat </p>

</div>
</div>
<a id="a5f2d63e6f924527e1221a703580ebe89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2d63e6f924527e1221a703580ebe89">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reduces a matrix to a vector.</p>
<p>The function <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a169446607306d71f35adcff40aa4d6e5">reduce</a> reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a03fa60b83c36239a2dd4465a191532e7">REDUCE_MAX</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a0a075bfcc77682c67dcef57d7e40219c">REDUCE_MIN</a> , the output image should have the same type as the source one. In case of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#af2e1a540a681ff0c8b9c47aef279a60f">REDUCE_SUM</a> and <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a09e2005ddc6cfe8308a55a1252a5d55f">REDUCE_AVG</a> , the output may have a larger element bit-depth to preserve accuracy. And multi-channel arrays are also supported in these two reduction modes.</p>
<p>The following code demonstrates its usage for a single channel matrix. SNIPPET: snippets/core_reduce.cpp example</p>
<p>And the following code demonstrates its usage for a two-channel matrix. SNIPPET: snippets/core_reduce.cpp example2</p>
<p>param src input 2D matrix. param dst output vector. Its size and type is defined by dim and dtype parameters. param dim dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column. param rtype reduction operation that could be one of #ReduceTypes otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()). SEE: repeat </p>

</div>
</div>
<a id="a2993f18e5e50db04b97d861424b21470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2993f18e5e50db04b97d861424b21470">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the output array with repeated copies of the input array.</p>
<p>The function cv::repeat duplicates the input array one or more times along each of the two axes: (\texttt{dst} _{ij}= \texttt{src} _{i\mod src.rows, \; j\mod src.cols }) The second variant of the function is more convenient to use with REF: MatrixExpressions. param src input array to replicate. param ny Flag to specify how many times the {code src} is repeated along the vertical axis. param nx Flag to specify how many times the {code src} is repeated along the horizontal axis. param dst output array of the same type as {code src}. SEE: cv::reduce </p>

</div>
</div>
<a id="a8d11b0f392585a665722be8e1e7e428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d11b0f392585a665722be8e1e7e428c">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rotateCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates a 2D array in multiples of 90 degrees. The function cv::rotate rotates the array in one of three different ways: Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE). Rotate by 180 degrees clockwise (rotateCode = ROTATE_180). Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE). param src input array. param dst output array of the same type as src. The size is the same with ROTATE_180, and the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE. param rotateCode an enum to specify how to rotate the array; see the enum #RotateFlags SEE: transpose , repeat , completeSymm, flip, RotateFlags </p>

</div>
</div>
<a id="a7a5d50c46362bc44274febf1fcf1db19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5d50c46362bc44274febf1fcf1db19">&#9670;&nbsp;</a></span>scaleAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.scaleAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the sum of a scaled array and another array.</p>
<p>The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY or SAXPY in <a href="http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a>. It calculates the sum of a scaled array and another array: (\texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) + \texttt{src2} (I)) The function can also be emulated with a matrix expression, for example: <code> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A(3, 3, CV_64F); ... A.row(0) = A.row(1)*2 + A.row(2); </code> param src1 first input array. param alpha scale factor for the first array. param src2 second input array of the same size and type as src1. param dst output array of the same size and type as src1. SEE: add, addWeighted, subtract, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a87394e8979587ef2f5cf9a062ba2a62a">Mat::dot</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a35cb83e7d23b61e776578dd545d794b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cb83e7d23b61e776578dd545d794b1">&#9670;&nbsp;</a></span>setErrorVerbosity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.setErrorVerbosity </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fa02eb14f8f99fa8f7ce85e73022bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa02eb14f8f99fa8f7ce85e73022bdf">&#9670;&nbsp;</a></span>setIdentity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.setIdentity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a scaled identity matrix.</p>
<p>The function cv::setIdentity initializes a scaled identity matrix: (\texttt{mtx} (i,j)= \fork{\texttt{value}}{ if (i=j)}{0}{otherwise})</p>
<p>The function can also be emulated using the matrix initializers and the matrix expressions: <code> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = Mat::eye(4, 3, CV_32F)*5; // A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]] </code> param mtx matrix to initialize (not necessarily square). param s value to assign to diagonal elements. SEE: <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a415b6818d16ea2a7a1dcd571e04e14ab">Mat::zeros</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a87787208caf135e9a0530b74c9c2633d">Mat::ones</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ad18e915ae5367254558ae21a1b45664c">Mat::setTo</a>, Mat::operator= </p>

</div>
</div>
<a id="ae2b5f6c3e6d4a78ca6d453553c59c8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b5f6c3e6d4a78ca6d453553c59c8d0">&#9670;&nbsp;</a></span>setIdentity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.setIdentity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a scaled identity matrix.</p>
<p>The function cv::setIdentity initializes a scaled identity matrix: (\texttt{mtx} (i,j)= \fork{\texttt{value}}{ if (i=j)}{0}{otherwise})</p>
<p>The function can also be emulated using the matrix initializers and the matrix expressions: <code> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = Mat::eye(4, 3, CV_32F)*5; // A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]] </code> param mtx matrix to initialize (not necessarily square). SEE: <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a415b6818d16ea2a7a1dcd571e04e14ab">Mat::zeros</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#a87787208caf135e9a0530b74c9c2633d">Mat::ones</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ad18e915ae5367254558ae21a1b45664c">Mat::setTo</a>, Mat::operator= </p>

</div>
</div>
<a id="a295910b348927d95cc2f66decc26a55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295910b348927d95cc2f66decc26a55c">&#9670;&nbsp;</a></span>setNumThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.setNumThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>OpenCV will try to set the number of threads for the next parallel region.</p>
<p>If threads == 0, OpenCV will disable threading optimizations and run all it's functions sequentially. Passing threads &lt; 0 will reset threads number to system default. This function must be called outside of parallel region.</p>
<p>OpenCV will try to run its functions with specified threads number, but some behaviour differs from framework: </p><ul>
<li>
{code TBB} - User-defined parallel constructions will run with the same threads number, if another is not specified. If later on user creates his own scheduler, OpenCV will use it.  </li>
<li>
{code OpenMP} - No special defined behaviour.  </li>
<li>
{code Concurrency} - If threads == 1, OpenCV will disable threading optimizations and run its functions sequentially.  </li>
<li>
{code GCD} - Supports only values &lt;= 0.  </li>
<li>
{code C=} - No special defined behaviour. param nthreads Number of threads used by OpenCV. SEE: getNumThreads, getThreadNum  </li>
</ul>

</div>
</div>
<a id="a1011e9b0100647833f5511ba334a4b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1011e9b0100647833f5511ba334a4b16">&#9670;&nbsp;</a></span>setRNGSeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.setRNGSeed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets state of default random number generator.</p>
<p>The function cv::setRNGSeed sets state of default random number generator to custom value. param seed new state for default random number generator SEE: RNG, randu, randn </p>

</div>
</div>
<a id="a78eb7c0fecb9161c6cbda78db6239169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78eb7c0fecb9161c6cbda78db6239169">&#9670;&nbsp;</a></span>setUseIPP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.setUseIPP </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab844271d8ea4cb2efb07ff8b67ec349b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab844271d8ea4cb2efb07ff8b67ec349b">&#9670;&nbsp;</a></span>setUseIPP_NotExact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.setUseIPP_NotExact </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d1ad161c9e65802e5da32b538218888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1ad161c9e65802e5da32b538218888">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solves one or more linear systems or least-squares problems.</p>
<p>The function cv::solve solves a linear system or least-squares problem (the latter is possible with SVD or QR methods, or by specifying the flag <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a430c9780821bb4cf861c919343c7d694">DECOMP_NORMAL</a> ): (\texttt{dst} = </p><ul>
<li>\min _X | \texttt{src1} \cdot \texttt{X} - \texttt{src2} |)</li>
</ul>
<p>If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a63de797ce590a1fd08b2a84a9af1c1b7">DECOMP_LU</a> or <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53f88f83a383fc769f459b8c7f7f4191">DECOMP_CHOLESKY</a> method is used, the function returns 1 if src1 (or (\texttt{src1}^T\texttt{src1}) ) is non-singular. Otherwise, it returns 0. In the latter case, dst is not valid. Other methods find a pseudo-solution in case of a singular left-hand side part.</p>
<p><b>Note:</b> If you want to find a unity-norm solution of an under-defined singular system (\texttt{src1}\cdot\texttt{dst}=0) , the function solve will not do the work. Use SVD::solveZ instead.</p>
<p>param src1 input matrix on the left-hand side of the system. param src2 input matrix on the right-hand side of the system. param dst output solution. param flags solution (matrix inversion) method (#DecompTypes) SEE: invert, SVD, eigen return automatically generated </p>

</div>
</div>
<a id="a8e9bc4028443ce6c9e8ce137d8289504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9bc4028443ce6c9e8ce137d8289504">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solves one or more linear systems or least-squares problems.</p>
<p>The function cv::solve solves a linear system or least-squares problem (the latter is possible with SVD or QR methods, or by specifying the flag <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a430c9780821bb4cf861c919343c7d694">DECOMP_NORMAL</a> ): (\texttt{dst} = </p><ul>
<li>\min _X | \texttt{src1} \cdot \texttt{X} - \texttt{src2} |)</li>
</ul>
<p>If <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a63de797ce590a1fd08b2a84a9af1c1b7">DECOMP_LU</a> or <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a53f88f83a383fc769f459b8c7f7f4191">DECOMP_CHOLESKY</a> method is used, the function returns 1 if src1 (or (\texttt{src1}^T\texttt{src1}) ) is non-singular. Otherwise, it returns 0. In the latter case, dst is not valid. Other methods find a pseudo-solution in case of a singular left-hand side part.</p>
<p><b>Note:</b> If you want to find a unity-norm solution of an under-defined singular system (\texttt{src1}\cdot\texttt{dst}=0) , the function solve will not do the work. Use SVD::solveZ instead.</p>
<p>param src1 input matrix on the left-hand side of the system. param src2 input matrix on the right-hand side of the system. param dst output solution. SEE: invert, SVD, eigen return automatically generated </p>

</div>
</div>
<a id="adaf5073f128bac97be5edf68a4a16dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf5073f128bac97be5edf68a4a16dec">&#9670;&nbsp;</a></span>solveCubic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.CoreModule.Core.solveCubic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the real roots of a cubic equation.</p>
<p>The function solveCubic finds the real roots of a cubic equation: </p><ul>
<li>
if coeffs is a 4-element vector: (\texttt{coeffs} [0] x^3 + \texttt{coeffs} [1] x^2 + \texttt{coeffs} [2] x + \texttt{coeffs} [3] = 0)  </li>
<li>
if coeffs is a 3-element vector: (x^3 + \texttt{coeffs} [0] x^2 + \texttt{coeffs} [1] x + \texttt{coeffs} [2] = 0)  </li>
</ul>
<p>The roots are stored in the roots array. param coeffs equation coefficients, an array of 3 or 4 elements. param roots output array of real roots that has 1 or 3 elements. return number of real roots. It can be 0, 1 or 2. </p>

</div>
</div>
<a id="a66d8f951f5f4da0b894fa48cc336d2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d8f951f5f4da0b894fa48cc336d2e6">&#9670;&nbsp;</a></span>solvePoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.solvePoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the real or complex roots of a polynomial equation.</p>
<p>The function cv::solvePoly finds real and complex roots of a polynomial equation: (\texttt{coeffs} [n] x^{n} + \texttt{coeffs} [n-1] x^{n-1} + ... + \texttt{coeffs} [1] x + \texttt{coeffs} [0] = 0) param coeffs array of polynomial coefficients. param roots output (complex) array of roots. param maxIters maximum number of iterations the algorithm does. return automatically generated </p>

</div>
</div>
<a id="adc1d4b6a69514aafb994a0102e263298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1d4b6a69514aafb994a0102e263298">&#9670;&nbsp;</a></span>solvePoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.CoreModule.Core.solvePoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the real or complex roots of a polynomial equation.</p>
<p>The function cv::solvePoly finds real and complex roots of a polynomial equation: (\texttt{coeffs} [n] x^{n} + \texttt{coeffs} [n-1] x^{n-1} + ... + \texttt{coeffs} [1] x + \texttt{coeffs} [0] = 0) param coeffs array of polynomial coefficients. param roots output (complex) array of roots. return automatically generated </p>

</div>
</div>
<a id="a53df35d84adae45464f6416fe84ff361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53df35d84adae45464f6416fe84ff361">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts each row or each column of a matrix.</p>
<p>The function cv::sort sorts each matrix row or each matrix column in ascending or descending order. So you should pass two operation flags to get desired behaviour. If you want to sort matrix rows or columns lexicographically, you can use STL std::sort generic function with the proper comparison predicate.</p>
<p>param src input single-channel array. param dst output array of the same size and type as src. param flags operation flags, a combination of #SortFlags SEE: sortIdx, randShuffle </p>

</div>
</div>
<a id="a353f5e466e20f583f70e478ac1c0953a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353f5e466e20f583f70e478ac1c0953a">&#9670;&nbsp;</a></span>sortIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.sortIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts each row or each column of a matrix.</p>
<p>The function cv::sortIdx sorts each matrix row or each matrix column in the ascending or descending order. So you should pass two operation flags to get desired behaviour. Instead of reordering the elements themselves, it stores the indices of sorted elements in the output array. For example: <code> <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = Mat::eye(3,3,CV_32F), B; sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING); // B will probably contain // (because of equal elements in A some permutations are possible): // [[1, 2, 0], [0, 2, 1], [0, 1, 2]] </code> param src input single-channel array. param dst output integer array of the same size as src. param flags operation flags that could be a combination of cv::SortFlags SEE: sort, randShuffle </p>

</div>
</div>
<a id="a1251b355138163682c3cefbf31874f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1251b355138163682c3cefbf31874f85">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>mv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param m input multi-channel array. param mv output vector of arrays; the arrays themselves are reallocated, if needed. </p>

</div>
</div>
<a id="a49792c1d55133782d6344dfa1f7c0558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49792c1d55133782d6344dfa1f7c0558">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a square root of array elements.</p>
<p>The function cv::sqrt calculates a square root of each input array element. In case of multi-channel arrays, each channel is processed independently. The accuracy is approximately the same as of the built-in std::sqrt . param src input floating-point array. param dst output array of the same size and type as src. </p>

</div>
</div>
<a id="af7e67fdff0b02fb6cc6ec245fddcd9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e67fdff0b02fb6cc6ec245fddcd9e8">&#9670;&nbsp;</a></span>subtract() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element difference between two arrays or array and a scalar.</p>
<p>The function subtract calculates: </p><ul>
<li>
Difference between two arrays, when both input arrays have the same size and the same number of channels: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) - \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Difference between an array and a scalar, when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) - \texttt{src2} ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Difference between a scalar and an array, when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1} - \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
The reverse difference between a scalar and an array in the case of {code SubRS}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src2} - \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0) where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.  </li>
</ul>
<p>The first function in the list above can be replaced with matrix expressions: <code> dst = src1 - src2; dst -= src1; // equivalent to subtract(dst, src1, dst); </code> The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of the output array is determined by dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case the output array will have the same depth as the input array, be it src1, src2 or both. <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array of the same size and the same number of channels as the input array. param mask optional operation mask; this is an 8-bit single channel array that specifies elements of the output array to be changed. param dtype optional depth of the output array SEE: add, addWeighted, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a176f5ecab5a2550e3554661b19071c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176f5ecab5a2550e3554661b19071c65">&#9670;&nbsp;</a></span>subtract() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element difference between two arrays or array and a scalar.</p>
<p>The function subtract calculates: </p><ul>
<li>
Difference between two arrays, when both input arrays have the same size and the same number of channels: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) - \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Difference between an array and a scalar, when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) - \texttt{src2} ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Difference between a scalar and an array, when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1} - \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
The reverse difference between a scalar and an array in the case of {code SubRS}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src2} - \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0) where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.  </li>
</ul>
<p>The first function in the list above can be replaced with matrix expressions: <code> dst = src1 - src2; dst -= src1; // equivalent to subtract(dst, src1, dst); </code> The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of the output array is determined by dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case the output array will have the same depth as the input array, be it src1, src2 or both. <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array of the same size and the same number of channels as the input array. param mask optional operation mask; this is an 8-bit single channel array that specifies elements of the output array to be changed. SEE: add, addWeighted, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="a5e93c3e36a4040338e5989d923ce429a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e93c3e36a4040338e5989d923ce429a">&#9670;&nbsp;</a></span>subtract() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the per-element difference between two arrays or array and a scalar.</p>
<p>The function subtract calculates: </p><ul>
<li>
Difference between two arrays, when both input arrays have the same size and the same number of channels: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) - \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Difference between an array and a scalar, when src2 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src1.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1}(I) - \texttt{src2} ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
Difference between a scalar and an array, when src1 is constructed from <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> or has the same number of elements as {code src2.channels()}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src1} - \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0)  </li>
<li>
The reverse difference between a scalar and an array in the case of {code SubRS}: (\texttt{dst}(I) = \texttt{saturate} ( \texttt{src2} - \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0) where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.  </li>
</ul>
<p>The first function in the list above can be replaced with matrix expressions: <code> dst = src1 - src2; dst -= src1; // equivalent to subtract(dst, src1, dst); </code> The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of the output array is determined by dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case the output array will have the same depth as the input array, be it src1, src2 or both. <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow. param src1 first input array or a scalar. param src2 second input array or a scalar. param dst output array of the same size and the same number of channels as the input array. of the output array to be changed. SEE: add, addWeighted, scaleAdd, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html#ae89d02605d9843365941fa911908a7f1">Mat::convertTo</a> </p>

</div>
</div>
<a id="ab61e57769c8d4e25f9da4801c893e436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61e57769c8d4e25f9da4801c893e436">&#9670;&nbsp;</a></span>subtract() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="affdb7c0329f41b7de2f28812c6243f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb7c0329f41b7de2f28812c6243f57">&#9670;&nbsp;</a></span>subtract() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27c6ba57417b73e7371fa38be56582d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c6ba57417b73e7371fa38be56582d7">&#9670;&nbsp;</a></span>subtract() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8eae21526efeeafe675a409d1e4f8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8eae21526efeeafe675a409d1e4f8dc">&#9670;&nbsp;</a></span>sumElems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> OpenCVForUnity.CoreModule.Core.sumElems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the sum of array elements.</p>
<p>The function cv::sum calculates and returns the sum of array elements, independently for each channel. param src input array that must have from 1 to 4 channels. SEE: countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce return automatically generated </p>

</div>
</div>
<a id="ab943b0770e86fe2386f9d44f6b848606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab943b0770e86fe2386f9d44f6b848606">&#9670;&nbsp;</a></span>SVBackSubst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.SVBackSubst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap SVD::backSubst param w automatically generated param u automatically generated param vt automatically generated param rhs automatically generated param dst automatically generated </p>

</div>
</div>
<a id="aac50816b6cee0e1152f75ba37a7df027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac50816b6cee0e1152f75ba37a7df027">&#9670;&nbsp;</a></span>SVDecomp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.SVDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap SVD::compute param src automatically generated param w automatically generated param u automatically generated param vt automatically generated param flags automatically generated </p>

</div>
</div>
<a id="a53a8267cd259995775e0e5547371ca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a8267cd259995775e0e5547371ca33">&#9670;&nbsp;</a></span>SVDecomp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.SVDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrap SVD::compute param src automatically generated param w automatically generated param u automatically generated param vt automatically generated </p>

</div>
</div>
<a id="ae3bfc810ed4ff57d8e8fd7127286deda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3bfc810ed4ff57d8e8fd7127286deda">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> OpenCVForUnity.CoreModule.Core.trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the trace of a matrix.</p>
<p>The function cv::trace returns the sum of the diagonal elements of the matrix mtx . (\mathrm{tr} ( \texttt{mtx} ) = \sum _i \texttt{mtx} (i,i)) param mtx input matrix. return automatically generated </p>

</div>
</div>
<a id="ad8c33f0fb5deafc1457cf9a1cb1568a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c33f0fb5deafc1457cf9a1cb1568a6">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the matrix transformation of every array element.</p>
<p>The function cv::transform performs the matrix transformation of every element of the array src and stores the results in dst : (\texttt{dst} (I) = \texttt{m} \cdot \texttt{src} (I)) (when m.cols=src.channels() ), or (\texttt{dst} (I) = \texttt{m} \cdot [ \texttt{src} (I); 1]) (when m.cols=src.channels()+1 )</p>
<p>Every element of the N -channel array src is interpreted as N -element vector that is transformed using the M x N or M x (N+1) matrix m to M-element vector - the corresponding element of the output array dst .</p>
<p>The function may be used for geometrical transformation of N -dimensional points, arbitrary linear color space transformation (such as various kinds of RGB to YUV transforms), shuffling the image channels, and so forth. param src input array that must have as many channels (1 to 4) as m.cols or m.cols-1. param dst output array of the same size and depth as src; it has as many channels as m.rows. param m transformation 2x2 or 2x3 floating-point matrix. SEE: perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective </p>

</div>
</div>
<a id="a1bc608b5531dce3ded593b1ca0a2836f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc608b5531dce3ded593b1ca0a2836f">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transposes a matrix.</p>
<p>The function cv::transpose transposes the matrix src : (\texttt{dst} (i,j) = \texttt{src} (j,i)) <b>Note:</b> No complex conjugation is done in case of a complex matrix. It should be done separately if needed. param src input array. param dst output array of the same type as src. </p>

</div>
</div>
<a id="ad9dc7bfdd36424687625176d6883a2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dc7bfdd36424687625176d6883a2d8">&#9670;&nbsp;</a></span>useIPP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.useIPP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>proxy for hal::Cholesky return automatically generated </p>

</div>
</div>
<a id="a27941040c435fae64832b5e22bdbdf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27941040c435fae64832b5e22bdbdf6b">&#9670;&nbsp;</a></span>useIPP_NotExact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.CoreModule.Core.useIPP_NotExact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6435b1a999402987596e62ae4fbf46fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435b1a999402987596e62ae4fbf46fb">&#9670;&nbsp;</a></span>vconcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.CoreModule.Core.vconcat </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code> std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)), cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};</code></p>
<p><code> cv::Mat out; cv::vconcat( matrices, out ); //out: //[1, 1, 1, 1; // 2, 2, 2, 2; // 3, 3, 3, 3] </code> param src input array or vector of matrices. all of the matrices must have the same number of cols and the same depth param dst output array. It has the same number of cols and depth as the src, and the sum of rows of the src. same depth. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a23d0df8a6af75ffe78758fabec27ede0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d0df8a6af75ffe78758fabec27ede0">&#9670;&nbsp;</a></span>BadAlign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadAlign = -21</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e699fdef4a45e2095486f9abf73438b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e699fdef4a45e2095486f9abf73438b">&#9670;&nbsp;</a></span>BadAlphaChannel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadAlphaChannel = -18</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5b021e176d5c085bc2f9c5ce2782f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b021e176d5c085bc2f9c5ce2782f4c">&#9670;&nbsp;</a></span>BadCallBack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadCallBack = -22</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38e832cb36c7e2b33ede4edfa8f8cff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e832cb36c7e2b33ede4edfa8f8cff7">&#9670;&nbsp;</a></span>BadCOI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadCOI = -24</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af545caa33eefb19f2fd9e9b1dba095fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af545caa33eefb19f2fd9e9b1dba095fd">&#9670;&nbsp;</a></span>BadDataPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadDataPtr = -12</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad344f40e4af2a06dcf625eeb207153a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad344f40e4af2a06dcf625eeb207153a5">&#9670;&nbsp;</a></span>BadDepth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadDepth = -17</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a227e863e84298ac8fe5cafbcf415b009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e863e84298ac8fe5cafbcf415b009">&#9670;&nbsp;</a></span>BadImageSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadImageSize = -10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f39e270b5929ebbc1968e63415d1edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f39e270b5929ebbc1968e63415d1edb">&#9670;&nbsp;</a></span>BadModelOrChSeq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadModelOrChSeq = -14</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59befab9a1534e2819c26495d8126596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59befab9a1534e2819c26495d8126596">&#9670;&nbsp;</a></span>BadNumChannel1U</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadNumChannel1U = -16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acac9f8df16a97fde65b91094d221f4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac9f8df16a97fde65b91094d221f4b6">&#9670;&nbsp;</a></span>BadNumChannels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadNumChannels = -15</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82a63abaa22a9966c0d62a6d4290b9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a63abaa22a9966c0d62a6d4290b9ca">&#9670;&nbsp;</a></span>BadOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadOffset = -11</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad8dd1f9927c6b14ee8d94b70d30c267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8dd1f9927c6b14ee8d94b70d30c267">&#9670;&nbsp;</a></span>BadOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadOrder = -19</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc0a330a3a094c2c7ef361d0f5fda083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0a330a3a094c2c7ef361d0f5fda083">&#9670;&nbsp;</a></span>BadOrigin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadOrigin = -20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78a1eadb1868f63168be0958ecb7c035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a1eadb1868f63168be0958ecb7c035">&#9670;&nbsp;</a></span>BadROISize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadROISize = -25</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fe7cd59bc06420ee1199f68b94be785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe7cd59bc06420ee1199f68b94be785">&#9670;&nbsp;</a></span>BadStep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadStep = -13</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd4099ba25e4452e771368f1c5794a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4099ba25e4452e771368f1c5794a85">&#9670;&nbsp;</a></span>BadTileSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BadTileSize = -23</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a700587c589e753b9b04bb2340ff4beac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700587c589e753b9b04bb2340ff4beac">&#9670;&nbsp;</a></span>BORDER_CONSTANT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_CONSTANT = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1a0c1c9c55be780c286221c91fa576f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a0c1c9c55be780c286221c91fa576f">&#9670;&nbsp;</a></span>BORDER_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_DEFAULT = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7af68df90fc0017e1f292c65675ed688">BORDER_REFLECT_101</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaaeecb4a62c6a427156d108e5926613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaeecb4a62c6a427156d108e5926613">&#9670;&nbsp;</a></span>BORDER_ISOLATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_ISOLATED = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b0d3cd361e61ac45a1c8f6a3f092022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0d3cd361e61ac45a1c8f6a3f092022">&#9670;&nbsp;</a></span>BORDER_REFLECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_REFLECT = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a975e23c5e514e17326bc7a774c5762e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975e23c5e514e17326bc7a774c5762e7">&#9670;&nbsp;</a></span>BORDER_REFLECT101</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_REFLECT101 = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a7af68df90fc0017e1f292c65675ed688">BORDER_REFLECT_101</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7af68df90fc0017e1f292c65675ed688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af68df90fc0017e1f292c65675ed688">&#9670;&nbsp;</a></span>BORDER_REFLECT_101</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_REFLECT_101 = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66c183b655c10a86153ed017119e2bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c183b655c10a86153ed017119e2bc9">&#9670;&nbsp;</a></span>BORDER_REPLICATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_REPLICATE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdd0751a0136965d3caf57bfc43620e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd0751a0136965d3caf57bfc43620e7">&#9670;&nbsp;</a></span>BORDER_TRANSPARENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_TRANSPARENT = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84f61c3ce2dcf35434deee2be7a618db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f61c3ce2dcf35434deee2be7a618db">&#9670;&nbsp;</a></span>BORDER_WRAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.BORDER_WRAP = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafb35ab9b39df7c7938ae175ed2f8fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb35ab9b39df7c7938ae175ed2f8fa9">&#9670;&nbsp;</a></span>CMP_EQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.CMP_EQ = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fcb799793788c85804511ba6666cefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcb799793788c85804511ba6666cefc">&#9670;&nbsp;</a></span>CMP_GE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.CMP_GE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d9553cd6444cd66b59239770008ba43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9553cd6444cd66b59239770008ba43">&#9670;&nbsp;</a></span>CMP_GT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.CMP_GT = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4595416c90061a9f3e8e8578609d346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4595416c90061a9f3e8e8578609d346">&#9670;&nbsp;</a></span>CMP_LE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.CMP_LE = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a2251b639494a07f88c553729a049ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2251b639494a07f88c553729a049ba">&#9670;&nbsp;</a></span>CMP_LT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.CMP_LT = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacb06e1dc203a84cc7fb959f25aa988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb06e1dc203a84cc7fb959f25aa988c">&#9670;&nbsp;</a></span>CMP_NE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.CMP_NE = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32e0c7b926e5c8bf66afbd397713b093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e0c7b926e5c8bf66afbd397713b093">&#9670;&nbsp;</a></span>COVAR_COLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.COVAR_COLS = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a366a792fb02b7b4b34e86d360e3a00a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366a792fb02b7b4b34e86d360e3a00a0">&#9670;&nbsp;</a></span>COVAR_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.COVAR_NORMAL = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34381817f95caf807b3d3ec4c0de008e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34381817f95caf807b3d3ec4c0de008e">&#9670;&nbsp;</a></span>COVAR_ROWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.COVAR_ROWS = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4cd7ef3bfc9ed9b902cdc57dad3e12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cd7ef3bfc9ed9b902cdc57dad3e12c">&#9670;&nbsp;</a></span>COVAR_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.COVAR_SCALE = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d04f03637669210aa721c1c395b586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d04f03637669210aa721c1c395b586">&#9670;&nbsp;</a></span>COVAR_SCRAMBLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.COVAR_SCRAMBLED = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a263460aedbf841c64f7deadda74ab73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263460aedbf841c64f7deadda74ab73b">&#9670;&nbsp;</a></span>COVAR_USE_AVG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.COVAR_USE_AVG = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9af8231d95e29adf18d44f8548fa24fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af8231d95e29adf18d44f8548fa24fa">&#9670;&nbsp;</a></span>DCT_INVERSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DCT_INVERSE = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#a8f93feabe44e4c2e62fc33daddb3e057">DFT_INVERSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32cc5f0d908ec03cfa6215697d0b1ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cc5f0d908ec03cfa6215697d0b1ec5">&#9670;&nbsp;</a></span>DCT_ROWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DCT_ROWS = <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_core.html#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">DFT_ROWS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53f88f83a383fc769f459b8c7f7f4191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f88f83a383fc769f459b8c7f7f4191">&#9670;&nbsp;</a></span>DECOMP_CHOLESKY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DECOMP_CHOLESKY = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3cae8d8b4ac62063a788d8480949c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cae8d8b4ac62063a788d8480949c51">&#9670;&nbsp;</a></span>DECOMP_EIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DECOMP_EIG = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63de797ce590a1fd08b2a84a9af1c1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63de797ce590a1fd08b2a84a9af1c1b7">&#9670;&nbsp;</a></span>DECOMP_LU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DECOMP_LU = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a430c9780821bb4cf861c919343c7d694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430c9780821bb4cf861c919343c7d694">&#9670;&nbsp;</a></span>DECOMP_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DECOMP_NORMAL = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae17bb61ddd8e1322016a91a9138f2d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17bb61ddd8e1322016a91a9138f2d7e">&#9670;&nbsp;</a></span>DECOMP_QR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DECOMP_QR = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8a16e6c8d4785ce2d627fcdae6aed83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a16e6c8d4785ce2d627fcdae6aed83">&#9670;&nbsp;</a></span>DECOMP_SVD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DECOMP_SVD = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45f190257e535e93b9e5d889d2a28897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f190257e535e93b9e5d889d2a28897">&#9670;&nbsp;</a></span>DFT_COMPLEX_INPUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DFT_COMPLEX_INPUT = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0910f497f735b83cbf02f40d8cbede98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0910f497f735b83cbf02f40d8cbede98">&#9670;&nbsp;</a></span>DFT_COMPLEX_OUTPUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DFT_COMPLEX_OUTPUT = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f93feabe44e4c2e62fc33daddb3e057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f93feabe44e4c2e62fc33daddb3e057">&#9670;&nbsp;</a></span>DFT_INVERSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DFT_INVERSE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5afda64a7880e084d74eeb7d9ec520f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afda64a7880e084d74eeb7d9ec520f5">&#9670;&nbsp;</a></span>DFT_REAL_OUTPUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DFT_REAL_OUTPUT = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf1d8d366d4b6a6a6ed8d2f60f95b8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1d8d366d4b6a6a6ed8d2f60f95b8ee">&#9670;&nbsp;</a></span>DFT_ROWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DFT_ROWS = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5b6cafe67cb86f13fa99b3557761dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b6cafe67cb86f13fa99b3557761dc0">&#9670;&nbsp;</a></span>DFT_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.DFT_SCALE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7e0eb67c3dab3873e3739b857612b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e0eb67c3dab3873e3739b857612b86">&#9670;&nbsp;</a></span>FILLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.FILLED = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a929d06b5dc9dcd84fdf8789bd9027fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929d06b5dc9dcd84fdf8789bd9027fae">&#9670;&nbsp;</a></span>Formatter_FMT_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Formatter_FMT_C = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2c92305f00527d5106fda4c4f58d743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c92305f00527d5106fda4c4f58d743">&#9670;&nbsp;</a></span>Formatter_FMT_CSV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Formatter_FMT_CSV = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48da3791baeba76631263cc4735a5e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48da3791baeba76631263cc4735a5e2b">&#9670;&nbsp;</a></span>Formatter_FMT_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Formatter_FMT_DEFAULT = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e4f7c7ceaae8ef2298a5fe25d7abffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4f7c7ceaae8ef2298a5fe25d7abffd">&#9670;&nbsp;</a></span>Formatter_FMT_MATLAB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Formatter_FMT_MATLAB = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2c060b710e81d3a0dad34c2d6e5ab87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c060b710e81d3a0dad34c2d6e5ab87">&#9670;&nbsp;</a></span>Formatter_FMT_NUMPY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Formatter_FMT_NUMPY = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0619036a1120a1e7a1ec51383d7a0ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0619036a1120a1e7a1ec51383d7a0ae5">&#9670;&nbsp;</a></span>Formatter_FMT_PYTHON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Formatter_FMT_PYTHON = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a052de9efb4bd2341abc5cfe493502b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052de9efb4bd2341abc5cfe493502b9e">&#9670;&nbsp;</a></span>GEMM_1_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.GEMM_1_T = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f892f16a85d857c8dfad9d2295541a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f892f16a85d857c8dfad9d2295541a9">&#9670;&nbsp;</a></span>GEMM_2_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.GEMM_2_T = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46e109d4b4e5645e297ede64eac368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46e109d4b4e5645e297ede64eac368">&#9670;&nbsp;</a></span>GEMM_3_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.GEMM_3_T = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ae63e9c65e9be5f1752487f627d4134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae63e9c65e9be5f1752487f627d4134">&#9670;&nbsp;</a></span>GpuApiCallError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.GpuApiCallError = -217</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87daf0064bff70dba58e53b53c27c04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87daf0064bff70dba58e53b53c27c04c">&#9670;&nbsp;</a></span>GpuNotSupported</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.GpuNotSupported = -216</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8f416370667b50f0c3d090f10546ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f416370667b50f0c3d090f10546ecc">&#9670;&nbsp;</a></span>HeaderIsNull</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.HeaderIsNull = -9</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac4117f740a37ee5e1476fd0ff0f62f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4117f740a37ee5e1476fd0ff0f62f5">&#9670;&nbsp;</a></span>KMEANS_PP_CENTERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.KMEANS_PP_CENTERS = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80360b5754885776ef19e32a15ed7ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80360b5754885776ef19e32a15ed7ec7">&#9670;&nbsp;</a></span>KMEANS_RANDOM_CENTERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.KMEANS_RANDOM_CENTERS = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affcb62ffc3700ae98bfb7c59b458ac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcb62ffc3700ae98bfb7c59b458ac8d">&#9670;&nbsp;</a></span>KMEANS_USE_INITIAL_LABELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.KMEANS_USE_INITIAL_LABELS = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f60655f81f73453705d6c7005a3630e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f60655f81f73453705d6c7005a3630e">&#9670;&nbsp;</a></span>MaskIsTiled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.MaskIsTiled = -26</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b008794d77156d1de8d51088cf7ec72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b008794d77156d1de8d51088cf7ec72">&#9670;&nbsp;</a></span>NATIVE_LIBRARY_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly string OpenCVForUnity.CoreModule.Core.NATIVE_LIBRARY_NAME = getNativeLibraryName()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60edae42a10d409c7bab8ec57f86a4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60edae42a10d409c7bab8ec57f86a4d3">&#9670;&nbsp;</a></span>NORM_HAMMING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_HAMMING = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aad50a69f4a185f346a0f424b09c7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aad50a69f4a185f346a0f424b09c7f0">&#9670;&nbsp;</a></span>NORM_HAMMING2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_HAMMING2 = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c84658333b1ac0ab22f1a83b316101d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c84658333b1ac0ab22f1a83b316101d">&#9670;&nbsp;</a></span>NORM_INF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_INF = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a3135a85b8f7b3aed4fe65faf0e3855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3135a85b8f7b3aed4fe65faf0e3855">&#9670;&nbsp;</a></span>NORM_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_L1 = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2efcd606f3e551028491c4e4a68ef65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2efcd606f3e551028491c4e4a68ef65">&#9670;&nbsp;</a></span>NORM_L2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_L2 = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d6cb1b92ac96d437261561c4678feec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6cb1b92ac96d437261561c4678feec">&#9670;&nbsp;</a></span>NORM_L2SQR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_L2SQR = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ab8a50eed4210b018d2de2be2a2fc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab8a50eed4210b018d2de2be2a2fc15">&#9670;&nbsp;</a></span>NORM_MINMAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_MINMAX = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68354597e77350023f108276ae8f73e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68354597e77350023f108276ae8f73e6">&#9670;&nbsp;</a></span>NORM_RELATIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_RELATIVE = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a856046e45aea104486f595799757587c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856046e45aea104486f595799757587c">&#9670;&nbsp;</a></span>NORM_TYPE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.NORM_TYPE_MASK = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a184f83567cc447e5362c20513b06927c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184f83567cc447e5362c20513b06927c">&#9670;&nbsp;</a></span>OpenCLApiCallError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.OpenCLApiCallError = -220</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ce3a5edd35ed5cb39215ffc21602572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce3a5edd35ed5cb39215ffc21602572">&#9670;&nbsp;</a></span>OpenCLDoubleNotSupported</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.OpenCLDoubleNotSupported = -221</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91a10885db215b6c26053969e9e0d25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a10885db215b6c26053969e9e0d25f">&#9670;&nbsp;</a></span>OpenCLInitError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.OpenCLInitError = -222</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79707bfb5813ac9d32eb66d2f8bfe41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79707bfb5813ac9d32eb66d2f8bfe41d">&#9670;&nbsp;</a></span>OpenCLNoAMDBlasFft</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.OpenCLNoAMDBlasFft = -223</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1782518177fa5ba7c09858d7d985eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1782518177fa5ba7c09858d7d985eaf">&#9670;&nbsp;</a></span>OpenGlApiCallError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.OpenGlApiCallError = -219</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68185da56861e861b720ff4bf0bce610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68185da56861e861b720ff4bf0bce610">&#9670;&nbsp;</a></span>OpenGlNotSupported</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.OpenGlNotSupported = -218</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72246e8f544e345565ade9ac02e0823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72246e8f544e345565ade9ac02e0823b">&#9670;&nbsp;</a></span>Param_ALGORITHM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_ALGORITHM = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5926bdb4546b4e79e18bbccc5ab9207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5926bdb4546b4e79e18bbccc5ab9207">&#9670;&nbsp;</a></span>Param_BOOLEAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_BOOLEAN = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12ad996cfe1b0143b58853c402ba98cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ad996cfe1b0143b58853c402ba98cf">&#9670;&nbsp;</a></span>Param_FLOAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_FLOAT = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac314069d421dc66045e72df3188bac51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac314069d421dc66045e72df3188bac51">&#9670;&nbsp;</a></span>Param_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_INT = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2f40423c1703fe1fa71578549cfd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2f40423c1703fe1fa71578549cfd46">&#9670;&nbsp;</a></span>Param_MAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_MAT = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19bcc772cc68426525e1706e83ff2849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bcc772cc68426525e1706e83ff2849">&#9670;&nbsp;</a></span>Param_MAT_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_MAT_VECTOR = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91b828006eb4044dfa476774c0b8386e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b828006eb4044dfa476774c0b8386e">&#9670;&nbsp;</a></span>Param_REAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_REAL = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f6d264976869ab39443cc405688501a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6d264976869ab39443cc405688501a">&#9670;&nbsp;</a></span>Param_SCALAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_SCALAR = 12</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58fda03fcbb2af9c682b20614f3a20eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fda03fcbb2af9c682b20614f3a20eb">&#9670;&nbsp;</a></span>Param_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_STRING = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86bfb58c5091c296da87882a8ab7d5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bfb58c5091c296da87882a8ab7d5d0">&#9670;&nbsp;</a></span>Param_UCHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_UCHAR = 11</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10bdb5f4e3b7f905e9db8d564e58c473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bdb5f4e3b7f905e9db8d564e58c473">&#9670;&nbsp;</a></span>Param_UINT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_UINT64 = 9</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb7873b9bb39cee0a9e25181a5831180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7873b9bb39cee0a9e25181a5831180">&#9670;&nbsp;</a></span>Param_UNSIGNED_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.Param_UNSIGNED_INT = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3238daae8dab95190422e60bbd80222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3238daae8dab95190422e60bbd80222">&#9670;&nbsp;</a></span>PCA_DATA_AS_COL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.PCA_DATA_AS_COL = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aeab3b925c6c40cf475fb39f7a8332e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aeab3b925c6c40cf475fb39f7a8332e">&#9670;&nbsp;</a></span>PCA_DATA_AS_ROW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.PCA_DATA_AS_ROW = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add7fddae89e8ffa0c268ab8ec29d757a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7fddae89e8ffa0c268ab8ec29d757a">&#9670;&nbsp;</a></span>PCA_USE_AVG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.PCA_USE_AVG = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09e2005ddc6cfe8308a55a1252a5d55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e2005ddc6cfe8308a55a1252a5d55f">&#9670;&nbsp;</a></span>REDUCE_AVG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.REDUCE_AVG = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03fa60b83c36239a2dd4465a191532e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fa60b83c36239a2dd4465a191532e7">&#9670;&nbsp;</a></span>REDUCE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.REDUCE_MAX = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a075bfcc77682c67dcef57d7e40219c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a075bfcc77682c67dcef57d7e40219c">&#9670;&nbsp;</a></span>REDUCE_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.REDUCE_MIN = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2e1a540a681ff0c8b9c47aef279a60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e1a540a681ff0c8b9c47aef279a60f">&#9670;&nbsp;</a></span>REDUCE_SUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.REDUCE_SUM = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa64f00949eaf56c0c04b39476e70bb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64f00949eaf56c0c04b39476e70bb25">&#9670;&nbsp;</a></span>RNG_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.RNG_NORMAL = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d972605929c29c07d245b061ba8fc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d972605929c29c07d245b061ba8fc78">&#9670;&nbsp;</a></span>RNG_UNIFORM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.RNG_UNIFORM = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19210e6d16815fe030e13f2f659b1e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19210e6d16815fe030e13f2f659b1e4b">&#9670;&nbsp;</a></span>ROTATE_180</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.ROTATE_180 = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20ca470ec0f6eec0aa32d5928878ce2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ca470ec0f6eec0aa32d5928878ce2d">&#9670;&nbsp;</a></span>ROTATE_90_CLOCKWISE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.ROTATE_90_CLOCKWISE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a725f2e773d906cfaf59b89297043a81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725f2e773d906cfaf59b89297043a81e">&#9670;&nbsp;</a></span>ROTATE_90_COUNTERCLOCKWISE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.ROTATE_90_COUNTERCLOCKWISE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13ed7dd121188517e2372d0f45bbf085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ed7dd121188517e2372d0f45bbf085">&#9670;&nbsp;</a></span>SORT_ASCENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.SORT_ASCENDING = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae148d538488e0df4e884b6918c432327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae148d538488e0df4e884b6918c432327">&#9670;&nbsp;</a></span>SORT_DESCENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.SORT_DESCENDING = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8630fd16ab30ecf391e00a2a0d031b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8630fd16ab30ecf391e00a2a0d031b8d">&#9670;&nbsp;</a></span>SORT_EVERY_COLUMN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.SORT_EVERY_COLUMN = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ec7592fac11c3ea1b049aaf93e9884f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec7592fac11c3ea1b049aaf93e9884f">&#9670;&nbsp;</a></span>SORT_EVERY_ROW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.SORT_EVERY_ROW = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aade2dfd134bf7c78fba3484e46385180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade2dfd134bf7c78fba3484e46385180">&#9670;&nbsp;</a></span>StsAssert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsAssert = -215</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a725085189b4e99d3277f7046479cb224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725085189b4e99d3277f7046479cb224">&#9670;&nbsp;</a></span>StsAutoTrace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsAutoTrace = -8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a1c59badfb6808ab3d06592898ca37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1c59badfb6808ab3d06592898ca37c">&#9670;&nbsp;</a></span>StsBackTrace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBackTrace = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a308005b761a4c33e8ef586efdbb07856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308005b761a4c33e8ef586efdbb07856">&#9670;&nbsp;</a></span>StsBadArg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBadArg = -5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a6ed35a1599c98ddf7b49432761fc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6ed35a1599c98ddf7b49432761fc35">&#9670;&nbsp;</a></span>StsBadFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBadFlag = -206</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bae582bfa8df142ec143cd4bcc7af0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bae582bfa8df142ec143cd4bcc7af0a">&#9670;&nbsp;</a></span>StsBadFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBadFunc = -6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8a9a9c25694b3d8b9b448a42a384c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a9a9c25694b3d8b9b448a42a384c02">&#9670;&nbsp;</a></span>StsBadMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBadMask = -208</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64e17e0d1d4165b613607d2499e8c761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e17e0d1d4165b613607d2499e8c761">&#9670;&nbsp;</a></span>StsBadMemBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBadMemBlock = -214</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d2453475597c5d96fca7570acf7efff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2453475597c5d96fca7570acf7efff">&#9670;&nbsp;</a></span>StsBadPoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBadPoint = -207</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2762151ab18194ce60933d1fc9622866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2762151ab18194ce60933d1fc9622866">&#9670;&nbsp;</a></span>StsBadSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsBadSize = -201</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e84ef1c6f20121c116b4d52222b145d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e84ef1c6f20121c116b4d52222b145d">&#9670;&nbsp;</a></span>StsDivByZero</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsDivByZero = -202</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e5f1abe2bee5aeaffce39b59092a99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5f1abe2bee5aeaffce39b59092a99a">&#9670;&nbsp;</a></span>StsError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsError = -2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cc8efce1d3f0fa221c9e252e54aa7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc8efce1d3f0fa221c9e252e54aa7f8">&#9670;&nbsp;</a></span>StsFilterOffsetErr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsFilterOffsetErr = -31</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7ccc15d81698805573bd4ce22249ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ccc15d81698805573bd4ce22249ac5">&#9670;&nbsp;</a></span>StsFilterStructContentErr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsFilterStructContentErr = -29</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ebdc1721334a2a0a6e515a09fe44bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebdc1721334a2a0a6e515a09fe44bfd">&#9670;&nbsp;</a></span>StsInplaceNotSupported</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsInplaceNotSupported = -203</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a59dbe205ad41a82f1dff92b9d781b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a59dbe205ad41a82f1dff92b9d781b0">&#9670;&nbsp;</a></span>StsInternal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsInternal = -3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1169b77abadeab66cd27270e29819088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1169b77abadeab66cd27270e29819088">&#9670;&nbsp;</a></span>StsKernelStructContentErr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsKernelStructContentErr = -30</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7f8f03d395287b9b8982b2ae4f68f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f8f03d395287b9b8982b2ae4f68f8f">&#9670;&nbsp;</a></span>StsNoConv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsNoConv = -7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af00b551945fc774ee77bc0a2a94ff77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00b551945fc774ee77bc0a2a94ff77e">&#9670;&nbsp;</a></span>StsNoMem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsNoMem = -4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31eef32d20fd01223cdf21369b147826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eef32d20fd01223cdf21369b147826">&#9670;&nbsp;</a></span>StsNotImplemented</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsNotImplemented = -213</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afaef2c5c0c6752a73545331647b4a1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaef2c5c0c6752a73545331647b4a1d0">&#9670;&nbsp;</a></span>StsNullPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsNullPtr = -27</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24c50059821dedbbaeb6fc4237958134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c50059821dedbbaeb6fc4237958134">&#9670;&nbsp;</a></span>StsObjectNotFound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsObjectNotFound = -204</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87ebffb0f7b74f08d56f4effecd5fb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ebffb0f7b74f08d56f4effecd5fb97">&#9670;&nbsp;</a></span>StsOk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsOk = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aa5cb32856846531c49ea21dcfa3c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa5cb32856846531c49ea21dcfa3c27">&#9670;&nbsp;</a></span>StsOutOfRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsOutOfRange = -211</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a102404cc7a51267bc98cd01e014f0839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102404cc7a51267bc98cd01e014f0839">&#9670;&nbsp;</a></span>StsParseError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsParseError = -212</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adac6b164f5bd5bec666da74487b026da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac6b164f5bd5bec666da74487b026da">&#9670;&nbsp;</a></span>StsUnmatchedFormats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsUnmatchedFormats = -205</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7646dae49467f3c245e3ee9f1743627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7646dae49467f3c245e3ee9f1743627">&#9670;&nbsp;</a></span>StsUnmatchedSizes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsUnmatchedSizes = -209</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0e98b3efe48cfd5617c2445b9a2c10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e98b3efe48cfd5617c2445b9a2c10d">&#9670;&nbsp;</a></span>StsUnsupportedFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsUnsupportedFormat = -210</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45db4d7bb37573483849be45aae65027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45db4d7bb37573483849be45aae65027">&#9670;&nbsp;</a></span>StsVecLengthErr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.StsVecLengthErr = -28</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97bccee19c21bf2e813c4409c0819e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bccee19c21bf2e813c4409c0819e33">&#9670;&nbsp;</a></span>SVD_FULL_UV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.SVD_FULL_UV = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a626f3ff74658f54136b963f214561667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626f3ff74658f54136b963f214561667">&#9670;&nbsp;</a></span>SVD_MODIFY_A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.SVD_MODIFY_A = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affc266343b375968677fd23b2d140844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc266343b375968677fd23b2d140844">&#9670;&nbsp;</a></span>SVD_NO_UV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Core.SVD_NO_UV = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1521db94d6b2363e09cf19f4b4ad1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1521db94d6b2363e09cf19f4b4ad1db">&#9670;&nbsp;</a></span>VERSION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly string OpenCVForUnity.CoreModule.Core.VERSION = getVersion()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cbe6467510a016cebb4d5b7e2931ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbe6467510a016cebb4d5b7e2931ce6">&#9670;&nbsp;</a></span>VERSION_MAJOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int OpenCVForUnity.CoreModule.Core.VERSION_MAJOR = getVersionMajorJ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd5762a3a4848b435a55fbe44e57f830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5762a3a4848b435a55fbe44e57f830">&#9670;&nbsp;</a></span>VERSION_MINOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int OpenCVForUnity.CoreModule.Core.VERSION_MINOR = getVersionMinorJ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4eaa0d0f0bf1e9ae6aa2d9355c44e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eaa0d0f0bf1e9ae6aa2d9355c44e1f">&#9670;&nbsp;</a></span>VERSION_REVISION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly int OpenCVForUnity.CoreModule.Core.VERSION_REVISION = getVersionRevisionJ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85feb234beabc20a52fb41cf7e4ad0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85feb234beabc20a52fb41cf7e4ad0eb">&#9670;&nbsp;</a></span>VERSION_STATUS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">readonly string OpenCVForUnity.CoreModule.Core.VERSION_STATUS = getVersionStatusJ()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>OpenCVForUnity/org/opencv/core/<a class="el" href="_core_8cs.html">Core.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 30 2020 22:54:00 for OpenCV for Unity by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
