<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenCV for Unity: OpenCVForUnity.ImgprocModule.Imgproc Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenCV for Unity
   &#160;<span id="projectnumber">2.4.1</span>
   </div>
   <div id="projectbrief">Enox Software / Please refer to OpenCV official document ( http://docs.opencv.org/4.5.0/index.html ) for the details of the argument of the method.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_open_c_v_for_unity.html">OpenCVForUnity</a></li><li class="navelem"><a class="el" href="namespace_open_c_v_for_unity_1_1_imgproc_module.html">ImgprocModule</a></li><li class="navelem"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html">Imgproc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenCVForUnity.ImgprocModule.Imgproc Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adc1ff2e2b2365ea9b27d454b9ea43dcb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adc1ff2e2b2365ea9b27d454b9ea43dcb">getAffineTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> dst)</td></tr>
<tr class="separator:adc1ff2e2b2365ea9b27d454b9ea43dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0037fbccf78b7eb59440abfdbe03fa4d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0037fbccf78b7eb59440abfdbe03fa4d">getGaborKernel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, double sigma, double theta, double lambd, double gamma, double psi, int ktype)</td></tr>
<tr class="separator:a0037fbccf78b7eb59440abfdbe03fa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20ef06bcd2915b36809ad9f87a66b3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af20ef06bcd2915b36809ad9f87a66b3c">getGaborKernel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, double sigma, double theta, double lambd, double gamma, double psi)</td></tr>
<tr class="separator:af20ef06bcd2915b36809ad9f87a66b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281c70dcc8d11418cdd8f43f909c97a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae281c70dcc8d11418cdd8f43f909c97a">getGaborKernel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, double sigma, double theta, double lambd, double gamma)</td></tr>
<tr class="separator:ae281c70dcc8d11418cdd8f43f909c97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726835f6a190b95bb46f3a966f035d39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a726835f6a190b95bb46f3a966f035d39">getGaussianKernel</a> (int ksize, double sigma, int ktype)</td></tr>
<tr class="separator:a726835f6a190b95bb46f3a966f035d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebaf09bcdbefd36deb09efb0675badc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7ebaf09bcdbefd36deb09efb0675badc">getGaussianKernel</a> (int ksize, double sigma)</td></tr>
<tr class="separator:a7ebaf09bcdbefd36deb09efb0675badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771bcc929549ce912d17fab419c7241"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7771bcc929549ce912d17fab419c7241">getPerspectiveTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int solveMethod)</td></tr>
<tr class="separator:a7771bcc929549ce912d17fab419c7241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde9ae771e86f43c9c45e4bed3687843"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acde9ae771e86f43c9c45e4bed3687843">getPerspectiveTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:acde9ae771e86f43c9c45e4bed3687843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b8b89051891d37da62abf9bd0dfb5a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab9b8b89051891d37da62abf9bd0dfb5a">getRotationMatrix2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, double angle, double scale)</td></tr>
<tr class="separator:ab9b8b89051891d37da62abf9bd0dfb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72818a59ccc8afaa8ec04c4da2024205"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a> (int shape, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:a72818a59ccc8afaa8ec04c4da2024205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185de8772a80f01b14ba1bab3f0a537"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab185de8772a80f01b14ba1bab3f0a537">getStructuringElement</a> (int shape, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize)</td></tr>
<tr class="separator:ab185de8772a80f01b14ba1bab3f0a537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8f0e5b7acaddcc22ea310a284ef31b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_moments.html">Moments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aaa8f0e5b7acaddcc22ea310a284ef31b">moments</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> array, bool binaryImage)</td></tr>
<tr class="separator:aaa8f0e5b7acaddcc22ea310a284ef31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e2391f9647076d893b6a29c340d498"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_moments.html">Moments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a63e2391f9647076d893b6a29c340d498">moments</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> array)</td></tr>
<tr class="separator:a63e2391f9647076d893b6a29c340d498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fde3b2a54d0e8711c3d7846c5463002"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3fde3b2a54d0e8711c3d7846c5463002">phaseCorrelate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> window, double[] response)</td></tr>
<tr class="separator:a3fde3b2a54d0e8711c3d7846c5463002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007ff489328f5a0d15d637054b5596a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a007ff489328f5a0d15d637054b5596a2">phaseCorrelate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> window)</td></tr>
<tr class="separator:a007ff489328f5a0d15d637054b5596a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8993032331a3ad7f177d315c0f958d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab8993032331a3ad7f177d315c0f958d0">phaseCorrelate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2)</td></tr>
<tr class="separator:ab8993032331a3ad7f177d315c0f958d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12298839f3019c429952194b08597aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_c_l_a_h_e.html">CLAHE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad12298839f3019c429952194b08597aa">createCLAHE</a> (double clipLimit, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> tileGridSize)</td></tr>
<tr class="separator:ad12298839f3019c429952194b08597aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3483c65bba4f0a96be8d804475b40c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_c_l_a_h_e.html">CLAHE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6a3483c65bba4f0a96be8d804475b40c">createCLAHE</a> (double clipLimit)</td></tr>
<tr class="separator:a6a3483c65bba4f0a96be8d804475b40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539692a77803a007b6870352d37965cb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_c_l_a_h_e.html">CLAHE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a539692a77803a007b6870352d37965cb">createCLAHE</a> ()</td></tr>
<tr class="separator:a539692a77803a007b6870352d37965cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a20ee191b2e601730ddb7360bf9f14f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_generalized_hough_ballard.html">GeneralizedHoughBallard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6a20ee191b2e601730ddb7360bf9f14f">createGeneralizedHoughBallard</a> ()</td></tr>
<tr class="separator:a6a20ee191b2e601730ddb7360bf9f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7954c7637c07fbb812a9457aa7f79714"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_generalized_hough_guil.html">GeneralizedHoughGuil</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7954c7637c07fbb812a9457aa7f79714">createGeneralizedHoughGuil</a> ()</td></tr>
<tr class="separator:a7954c7637c07fbb812a9457aa7f79714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640a6005bb032caaa7a1f501d19690f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a640a6005bb032caaa7a1f501d19690f1">createLineSegmentDetector</a> (int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps, double _density_th, int _n_bins)</td></tr>
<tr class="separator:a640a6005bb032caaa7a1f501d19690f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1241a1de292e9ff7a80d6576f57553f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac1241a1de292e9ff7a80d6576f57553f">createLineSegmentDetector</a> (int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps, double _density_th)</td></tr>
<tr class="separator:ac1241a1de292e9ff7a80d6576f57553f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8164875fd42543ec51c68daa7323c9fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8164875fd42543ec51c68daa7323c9fe">createLineSegmentDetector</a> (int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps)</td></tr>
<tr class="separator:a8164875fd42543ec51c68daa7323c9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff860cb81c090c94b04aeadc25bea6ae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aff860cb81c090c94b04aeadc25bea6ae">createLineSegmentDetector</a> (int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th)</td></tr>
<tr class="separator:aff860cb81c090c94b04aeadc25bea6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736c99b21e365c10676b216ee427d1c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a736c99b21e365c10676b216ee427d1c0">createLineSegmentDetector</a> (int _refine, double _scale, double _sigma_scale, double _quant)</td></tr>
<tr class="separator:a736c99b21e365c10676b216ee427d1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685393e129a061cc0130b0e329e25d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad685393e129a061cc0130b0e329e25d6">createLineSegmentDetector</a> (int _refine, double _scale, double _sigma_scale)</td></tr>
<tr class="separator:ad685393e129a061cc0130b0e329e25d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cdc042e2d3e231b60fbe115a5c34c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a96cdc042e2d3e231b60fbe115a5c34c5">createLineSegmentDetector</a> (int _refine, double _scale)</td></tr>
<tr class="separator:a96cdc042e2d3e231b60fbe115a5c34c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f36a6af6deca550a1b5fca7ba7cc70"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad4f36a6af6deca550a1b5fca7ba7cc70">createLineSegmentDetector</a> (int _refine)</td></tr>
<tr class="separator:ad4f36a6af6deca550a1b5fca7ba7cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa79220da2d281486430939a0ca2421"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abfa79220da2d281486430939a0ca2421">createLineSegmentDetector</a> ()</td></tr>
<tr class="separator:abfa79220da2d281486430939a0ca2421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e82a7086668675f8ce5629741c87453"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6e82a7086668675f8ce5629741c87453">boundingRect</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> array)</td></tr>
<tr class="separator:a6e82a7086668675f8ce5629741c87453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79126d22a79e182b46fd010ac3351bba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79126d22a79e182b46fd010ac3351bba">fitEllipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> points)</td></tr>
<tr class="separator:a79126d22a79e182b46fd010ac3351bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a956510a12870ec69920b99ef4d68"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1c6a956510a12870ec69920b99ef4d68">fitEllipseAMS</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points)</td></tr>
<tr class="separator:a1c6a956510a12870ec69920b99ef4d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624e098bb2b1f8a4be1ce83cd0c04ddf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a624e098bb2b1f8a4be1ce83cd0c04ddf">fitEllipseDirect</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points)</td></tr>
<tr class="separator:a624e098bb2b1f8a4be1ce83cd0c04ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4befd98bf52847f7b5efe47550402d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac4befd98bf52847f7b5efe47550402d9">minAreaRect</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> points)</td></tr>
<tr class="separator:ac4befd98bf52847f7b5efe47550402d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ca31cea2ed3d56ffe35a9fdcc4c272"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a55ca31cea2ed3d56ffe35a9fdcc4c272">clipLine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> imgRect, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2)</td></tr>
<tr class="separator:a55ca31cea2ed3d56ffe35a9fdcc4c272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bef198abdf2513529a7479ac216327"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a75bef198abdf2513529a7479ac216327">isContourConvex</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> contour)</td></tr>
<tr class="separator:a75bef198abdf2513529a7479ac216327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246113d68dafe23bcfb7fafd3c4271e0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a246113d68dafe23bcfb7fafd3c4271e0">arcLength</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> curve, bool closed)</td></tr>
<tr class="separator:a246113d68dafe23bcfb7fafd3c4271e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a166d5592f8b46c589b5f687281c6f4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a166d5592f8b46c589b5f687281c6f4">compareHist</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> H1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> H2, int method)</td></tr>
<tr class="separator:a5a166d5592f8b46c589b5f687281c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6463ee75ae41159c2c6c2141edb5c6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afb6463ee75ae41159c2c6c2141edb5c6">contourArea</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> contour, bool oriented)</td></tr>
<tr class="separator:afb6463ee75ae41159c2c6c2141edb5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383b889e0aaf32d2dfa0aabc09a68c62"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a383b889e0aaf32d2dfa0aabc09a68c62">contourArea</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> contour)</td></tr>
<tr class="separator:a383b889e0aaf32d2dfa0aabc09a68c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246acc054ac86da2286edb7fe47d577"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af246acc054ac86da2286edb7fe47d577">getFontScaleFromHeight</a> (int fontFace, int pixelHeight, int thickness)</td></tr>
<tr class="separator:af246acc054ac86da2286edb7fe47d577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34b90b1c25d3d4b3cf287f6aa9beb33"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac34b90b1c25d3d4b3cf287f6aa9beb33">getFontScaleFromHeight</a> (int fontFace, int pixelHeight)</td></tr>
<tr class="separator:ac34b90b1c25d3d4b3cf287f6aa9beb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a8652398eacb0d6ee5fdc59cbaa1b8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad4a8652398eacb0d6ee5fdc59cbaa1b8">matchShapes</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> contour1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> contour2, int method, double parameter)</td></tr>
<tr class="separator:ad4a8652398eacb0d6ee5fdc59cbaa1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d8f3c432501f896ab18b5962a38b8d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a66d8f3c432501f896ab18b5962a38b8d">minEnclosingTriangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> triangle)</td></tr>
<tr class="separator:a66d8f3c432501f896ab18b5962a38b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fb74437c933d324569d069b5245230"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a09fb74437c933d324569d069b5245230">pointPolygonTest</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> contour, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt, bool measureDist)</td></tr>
<tr class="separator:a09fb74437c933d324569d069b5245230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bddd2f479a606944d19b3bca2dd208a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double thresh, double maxval, int type)</td></tr>
<tr class="separator:a0bddd2f479a606944d19b3bca2dd208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d510e341245f6c0e578e697f6a08708"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5d510e341245f6c0e578e697f6a08708">intersectConvexConvex</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _p1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _p2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _p12, bool handleNested)</td></tr>
<tr class="separator:a5d510e341245f6c0e578e697f6a08708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1226246d1169bc77e10e20096f4097d"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa1226246d1169bc77e10e20096f4097d">intersectConvexConvex</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _p1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _p2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _p12)</td></tr>
<tr class="separator:aa1226246d1169bc77e10e20096f4097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c66029d7932044689e7be343d9c9f0"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a12c66029d7932044689e7be343d9c9f0">EMD</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> signature1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> signature2, int distType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> cost, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> flow)</td></tr>
<tr class="separator:a12c66029d7932044689e7be343d9c9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0403253123f4ac11f8faa14667e4d479"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0403253123f4ac11f8faa14667e4d479">EMD</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> signature1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> signature2, int distType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> cost)</td></tr>
<tr class="separator:a0403253123f4ac11f8faa14667e4d479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172de0251df42d02cb65f84b502cedeb"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a172de0251df42d02cb65f84b502cedeb">EMD</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> signature1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> signature2, int distType)</td></tr>
<tr class="separator:a172de0251df42d02cb65f84b502cedeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e54afc0afa740deca4f17866133005"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa0e54afc0afa740deca4f17866133005">connectedComponentsWithAlgorithm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, int connectivity, int ltype, int ccltype)</td></tr>
<tr class="separator:aa0e54afc0afa740deca4f17866133005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea44cfa83d39aaaf784575df237d997"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8ea44cfa83d39aaaf784575df237d997">connectedComponents</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, int connectivity, int ltype)</td></tr>
<tr class="separator:a8ea44cfa83d39aaaf784575df237d997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274dd0096dbfe40d3c79d3932a7c146b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a274dd0096dbfe40d3c79d3932a7c146b">connectedComponents</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, int connectivity)</td></tr>
<tr class="separator:a274dd0096dbfe40d3c79d3932a7c146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe241a582151a5065c1cef47ffd8195c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abe241a582151a5065c1cef47ffd8195c">connectedComponents</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels)</td></tr>
<tr class="separator:abe241a582151a5065c1cef47ffd8195c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b8ca72d1087900abfdebc1bd8bbd9a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a50b8ca72d1087900abfdebc1bd8bbd9a">connectedComponentsWithStatsWithAlgorithm</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> stats, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> centroids, int connectivity, int ltype, int ccltype)</td></tr>
<tr class="separator:a50b8ca72d1087900abfdebc1bd8bbd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7732191f1e173df1aa9e4e03bfc26051"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7732191f1e173df1aa9e4e03bfc26051">connectedComponentsWithStats</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> stats, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> centroids, int connectivity, int ltype)</td></tr>
<tr class="separator:a7732191f1e173df1aa9e4e03bfc26051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fecd2d52b491ef21af3b6c7bc9d09c3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7fecd2d52b491ef21af3b6c7bc9d09c3">connectedComponentsWithStats</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> stats, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> centroids, int connectivity)</td></tr>
<tr class="separator:a7fecd2d52b491ef21af3b6c7bc9d09c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4b399a4172da100fa58d73b2caae0a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4f4b399a4172da100fa58d73b2caae0a">connectedComponentsWithStats</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> stats, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> centroids)</td></tr>
<tr class="separator:a4f4b399a4172da100fa58d73b2caae0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac051fa7176259d8f39bcd92025f35863"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac051fa7176259d8f39bcd92025f35863">floodFill</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> seedPoint, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> newVal, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rect, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> loDiff, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> upDiff, int flags)</td></tr>
<tr class="separator:ac051fa7176259d8f39bcd92025f35863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17115e3322933420ee5fc5844774dac"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac17115e3322933420ee5fc5844774dac">floodFill</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> seedPoint, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> newVal, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rect, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> loDiff, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> upDiff)</td></tr>
<tr class="separator:ac17115e3322933420ee5fc5844774dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe49012732735c97f74831fa07efc043"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afe49012732735c97f74831fa07efc043">floodFill</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> seedPoint, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> newVal, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rect, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> loDiff)</td></tr>
<tr class="separator:afe49012732735c97f74831fa07efc043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5542c5b87acfa905d37358d2481da8df"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5542c5b87acfa905d37358d2481da8df">floodFill</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> seedPoint, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> newVal, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a5542c5b87acfa905d37358d2481da8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7060ea714f0797a5873241e59620ae"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5f7060ea714f0797a5873241e59620ae">floodFill</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> seedPoint, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> newVal)</td></tr>
<tr class="separator:a5f7060ea714f0797a5873241e59620ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9746115fdc5a58ece2bb322e777b3c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9f9746115fdc5a58ece2bb322e777b3c">rotatedRectangleIntersection</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> rect1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> rect2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> intersectingRegion)</td></tr>
<tr class="separator:a9f9746115fdc5a58ece2bb322e777b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae77b7fbf08a26bff1ecaed494f4bf1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5ae77b7fbf08a26bff1ecaed494f4bf1">Canny</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dy, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> edges, double threshold1, double threshold2, bool L2gradient)</td></tr>
<tr class="separator:a5ae77b7fbf08a26bff1ecaed494f4bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7f956927e1c6ccdde819f0c7a74a79"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ade7f956927e1c6ccdde819f0c7a74a79">Canny</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dy, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> edges, double threshold1, double threshold2)</td></tr>
<tr class="separator:ade7f956927e1c6ccdde819f0c7a74a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e10c173d149834c503119427f6bb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af59e10c173d149834c503119427f6bb5">Canny</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> edges, double threshold1, double threshold2, int apertureSize, bool L2gradient)</td></tr>
<tr class="separator:af59e10c173d149834c503119427f6bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad056e8b351a21499110607c6670406d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad056e8b351a21499110607c6670406d0">Canny</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> edges, double threshold1, double threshold2, int apertureSize)</td></tr>
<tr class="separator:ad056e8b351a21499110607c6670406d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f39feae6c58ad48d734be6ea23ad105"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4f39feae6c58ad48d734be6ea23ad105">Canny</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> edges, double threshold1, double threshold2)</td></tr>
<tr class="separator:a4f39feae6c58ad48d734be6ea23ad105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95192392e5ce830d79efa0d66da4f2a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a95192392e5ce830d79efa0d66da4f2a6">GaussianBlur</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, double sigmaX, double sigmaY, int borderType)</td></tr>
<tr class="separator:a95192392e5ce830d79efa0d66da4f2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32914f3b2bc9be6625aad93968d1b7d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae32914f3b2bc9be6625aad93968d1b7d">GaussianBlur</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, double sigmaX, double sigmaY)</td></tr>
<tr class="separator:ae32914f3b2bc9be6625aad93968d1b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba7835286e1ce1289ba3a268da493c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6ba7835286e1ce1289ba3a268da493c0">GaussianBlur</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, double sigmaX)</td></tr>
<tr class="separator:a6ba7835286e1ce1289ba3a268da493c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3729184115d8f750969754fa1c93cc50"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3729184115d8f750969754fa1c93cc50">HoughCircles</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)</td></tr>
<tr class="separator:a3729184115d8f750969754fa1c93cc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab550320a1153f8b3f9b4dc689bbc3425"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab550320a1153f8b3f9b4dc689bbc3425">HoughCircles</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> circles, int method, double dp, double minDist, double param1, double param2, int minRadius)</td></tr>
<tr class="separator:ab550320a1153f8b3f9b4dc689bbc3425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4030205c6e9cd949ed0248133e0b5d49"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4030205c6e9cd949ed0248133e0b5d49">HoughCircles</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> circles, int method, double dp, double minDist, double param1, double param2)</td></tr>
<tr class="separator:a4030205c6e9cd949ed0248133e0b5d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0138a4f04075ffb7cfe220ee385cbee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0138a4f04075ffb7cfe220ee385cbee">HoughCircles</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> circles, int method, double dp, double minDist, double param1)</td></tr>
<tr class="separator:ae0138a4f04075ffb7cfe220ee385cbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91802acba604a33a5ce7329f80fb18b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a91802acba604a33a5ce7329f80fb18b2">HoughCircles</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> circles, int method, double dp, double minDist)</td></tr>
<tr class="separator:a91802acba604a33a5ce7329f80fb18b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c216f3a4af7dd304a02710f9f05d42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a19c216f3a4af7dd304a02710f9f05d42">HoughLines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>, double srn, double stn, double min_theta, double max_theta)</td></tr>
<tr class="separator:a19c216f3a4af7dd304a02710f9f05d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0e740e23c0731541f859168cf2db42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5f0e740e23c0731541f859168cf2db42">HoughLines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>, double srn, double stn, double min_theta)</td></tr>
<tr class="separator:a5f0e740e23c0731541f859168cf2db42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921989f5714701220fcba97932696ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9921989f5714701220fcba97932696ac">HoughLines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>, double srn, double stn)</td></tr>
<tr class="separator:a9921989f5714701220fcba97932696ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345a7b4f2e8c1d852f86480e601c7f4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345a7b4f2e8c1d852f86480e601c7f4e">HoughLines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>, double srn)</td></tr>
<tr class="separator:a345a7b4f2e8c1d852f86480e601c7f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c2054eb1cbf029ef6ee5e05be10e26"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad2c2054eb1cbf029ef6ee5e05be10e26">HoughLines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>)</td></tr>
<tr class="separator:ad2c2054eb1cbf029ef6ee5e05be10e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8ba49f26a5dfd22d8235e9165176e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abcd8ba49f26a5dfd22d8235e9165176e">HoughLinesP</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>, double minLineLength, double maxLineGap)</td></tr>
<tr class="separator:abcd8ba49f26a5dfd22d8235e9165176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268e324c177041662dae3c7eff9ff50e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a268e324c177041662dae3c7eff9ff50e">HoughLinesP</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>, double minLineLength)</td></tr>
<tr class="separator:a268e324c177041662dae3c7eff9ff50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1ba9753e9dbd139039df7b343d3605"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1d1ba9753e9dbd139039df7b343d3605">HoughLinesP</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> lines, double rho, double theta, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>)</td></tr>
<tr class="separator:a1d1ba9753e9dbd139039df7b343d3605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab626e3f5cc2fc109553bff1a0aa145da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab626e3f5cc2fc109553bff1a0aa145da">HoughLinesPointSet</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _point, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> _lines, int lines_max, int <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a>, double min_rho, double max_rho, double rho_step, double min_theta, double max_theta, double theta_step)</td></tr>
<tr class="separator:ab626e3f5cc2fc109553bff1a0aa145da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cced1df97e47fe7b5a8aa26fce6318"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0cced1df97e47fe7b5a8aa26fce6318">HuMoments</a> (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_moments.html">Moments</a> m, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hu)</td></tr>
<tr class="separator:ad0cced1df97e47fe7b5a8aa26fce6318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5509b3da4dae1501415b58701ae73b27"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5509b3da4dae1501415b58701ae73b27">Laplacian</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int ksize, double scale, double delta, int borderType)</td></tr>
<tr class="separator:a5509b3da4dae1501415b58701ae73b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d75ac69937ec4e8cbac46dced11564"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac7d75ac69937ec4e8cbac46dced11564">Laplacian</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int ksize, double scale, double delta)</td></tr>
<tr class="separator:ac7d75ac69937ec4e8cbac46dced11564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0197f22227786c0b30a202be6c11d998"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0197f22227786c0b30a202be6c11d998">Laplacian</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int ksize, double scale)</td></tr>
<tr class="separator:a0197f22227786c0b30a202be6c11d998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9764cdd0c3e7b0f5fa94d1c4a12641"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7a9764cdd0c3e7b0f5fa94d1c4a12641">Laplacian</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int ksize)</td></tr>
<tr class="separator:a7a9764cdd0c3e7b0f5fa94d1c4a12641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8966c8f326f84067685422b32f53f210"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8966c8f326f84067685422b32f53f210">Laplacian</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth)</td></tr>
<tr class="separator:a8966c8f326f84067685422b32f53f210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516aaaa89b458b067978906a54f358a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)</td></tr>
<tr class="separator:a516aaaa89b458b067978906a54f358a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010ac218e6fe02a907c5b1c0b9c423fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a010ac218e6fe02a907c5b1c0b9c423fe">Scharr</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy, double scale, double delta)</td></tr>
<tr class="separator:a010ac218e6fe02a907c5b1c0b9c423fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a39fa047400e8c9cc308d8ccb9971a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a29a39fa047400e8c9cc308d8ccb9971a">Scharr</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy, double scale)</td></tr>
<tr class="separator:a29a39fa047400e8c9cc308d8ccb9971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a66651017d30b92549d583ef343685"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a91a66651017d30b92549d583ef343685">Scharr</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy)</td></tr>
<tr class="separator:a91a66651017d30b92549d583ef343685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc11d47ee5206e9b6b56ae0796e1c88"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aedc11d47ee5206e9b6b56ae0796e1c88">Sobel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)</td></tr>
<tr class="separator:aedc11d47ee5206e9b6b56ae0796e1c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa541796245127554b0585c07880dea53"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa541796245127554b0585c07880dea53">Sobel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy, int ksize, double scale, double delta)</td></tr>
<tr class="separator:aa541796245127554b0585c07880dea53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8640141faf04538817b310375592c8f5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8640141faf04538817b310375592c8f5">Sobel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy, int ksize, double scale)</td></tr>
<tr class="separator:a8640141faf04538817b310375592c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d8dbb38914310680f3f07542fbf7c3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a91d8dbb38914310680f3f07542fbf7c3">Sobel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy, int ksize)</td></tr>
<tr class="separator:a91d8dbb38914310680f3f07542fbf7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07263af90084b6a94e630d18d11dcdd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa07263af90084b6a94e630d18d11dcdd">Sobel</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, int dx, int dy)</td></tr>
<tr class="separator:aa07263af90084b6a94e630d18d11dcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f1d32ccd2ebbc5c576dd5630391f4f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad6f1d32ccd2ebbc5c576dd5630391f4f">accumulate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:ad6f1d32ccd2ebbc5c576dd5630391f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845dba2cab8088ddabf2a7801931ed33"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a845dba2cab8088ddabf2a7801931ed33">accumulate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a845dba2cab8088ddabf2a7801931ed33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8023c8b828f52a7fe7e92d26b7450f2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8023c8b828f52a7fe7e92d26b7450f2b">accumulateProduct</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:a8023c8b828f52a7fe7e92d26b7450f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327f960314676b91a1918db680cb79aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a327f960314676b91a1918db680cb79aa">accumulateProduct</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a327f960314676b91a1918db680cb79aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b940fd90fa7419fd88a860ccc2e1b1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad2b940fd90fa7419fd88a860ccc2e1b1">accumulateSquare</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:ad2b940fd90fa7419fd88a860ccc2e1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0860536e4b3007f13969311ca7c1cde"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa0860536e4b3007f13969311ca7c1cde">accumulateSquare</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:aa0860536e4b3007f13969311ca7c1cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ea3ca195b1ca20dd18c2b49e1faf0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae9ea3ca195b1ca20dd18c2b49e1faf0f">accumulateWeighted</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:ae9ea3ca195b1ca20dd18c2b49e1faf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739cd11eec61fc6d9755c6b04ceb3072"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a739cd11eec61fc6d9755c6b04ceb3072">accumulateWeighted</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double alpha)</td></tr>
<tr class="separator:a739cd11eec61fc6d9755c6b04ceb3072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33679aa86f8ed5555474d6bb7ba44a59"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a33679aa86f8ed5555474d6bb7ba44a59">adaptiveThreshold</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)</td></tr>
<tr class="separator:a33679aa86f8ed5555474d6bb7ba44a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46fed96953c7d5c1df80679347c3c66"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad46fed96953c7d5c1df80679347c3c66">applyColorMap</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> userColor)</td></tr>
<tr class="separator:ad46fed96953c7d5c1df80679347c3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dae338d89aae9bfaf7a4dfda4658283"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2dae338d89aae9bfaf7a4dfda4658283">applyColorMap</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int colormap)</td></tr>
<tr class="separator:a2dae338d89aae9bfaf7a4dfda4658283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94b873e4c98e6740dfd800cfcb3036f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae94b873e4c98e6740dfd800cfcb3036f">approxPolyDP</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> curve, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> approxCurve, double epsilon, bool closed)</td></tr>
<tr class="separator:ae94b873e4c98e6740dfd800cfcb3036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de3daa90bce13936c68ebcfca983956"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4de3daa90bce13936c68ebcfca983956">arrowedLine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int line_type, int shift, double tipLength)</td></tr>
<tr class="separator:a4de3daa90bce13936c68ebcfca983956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c723992cdfada4bdf9f0ae95adcaca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a95c723992cdfada4bdf9f0ae95adcaca">arrowedLine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int line_type, int shift)</td></tr>
<tr class="separator:a95c723992cdfada4bdf9f0ae95adcaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345da36c91d345594ee009d3440afb84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345da36c91d345594ee009d3440afb84">arrowedLine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int line_type)</td></tr>
<tr class="separator:a345da36c91d345594ee009d3440afb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c000cf3a68d3c1a1a9a0d9cce03bb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a33c000cf3a68d3c1a1a9a0d9cce03bb5">arrowedLine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:a33c000cf3a68d3c1a1a9a0d9cce03bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b309be9b8cc422b1c77d5ea9a4f0c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a923b309be9b8cc422b1c77d5ea9a4f0c">arrowedLine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a923b309be9b8cc422b1c77d5ea9a4f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1910e2e5b55f6929751d2b7ce6f8a47d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1910e2e5b55f6929751d2b7ce6f8a47d">bilateralFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int d, double sigmaColor, double sigmaSpace, int borderType)</td></tr>
<tr class="separator:a1910e2e5b55f6929751d2b7ce6f8a47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a830e5dc2747058ecc2da72301839de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7a830e5dc2747058ecc2da72301839de">bilateralFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int d, double sigmaColor, double sigmaSpace)</td></tr>
<tr class="separator:a7a830e5dc2747058ecc2da72301839de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1021eb8c0529e4062d4f3af11f1a11"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9a1021eb8c0529e4062d4f3af11f1a11">blur</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int borderType)</td></tr>
<tr class="separator:a9a1021eb8c0529e4062d4f3af11f1a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6ac40fd4c7949a7db9edbd6fac366"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a37d6ac40fd4c7949a7db9edbd6fac366">blur</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:a37d6ac40fd4c7949a7db9edbd6fac366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d54406ed53289e76691f2d6a7d57c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab6d54406ed53289e76691f2d6a7d57c6">blur</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize)</td></tr>
<tr class="separator:ab6d54406ed53289e76691f2d6a7d57c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206806db2c03100470de002b5e44f8b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a206806db2c03100470de002b5e44f8b2">boxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, bool normalize, int borderType)</td></tr>
<tr class="separator:a206806db2c03100470de002b5e44f8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e6125323675f841e71a1afb8ce1005"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a88e6125323675f841e71a1afb8ce1005">boxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, bool normalize)</td></tr>
<tr class="separator:a88e6125323675f841e71a1afb8ce1005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93063c39f4b1da7ed4fc69cc090fb776"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a93063c39f4b1da7ed4fc69cc090fb776">boxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:a93063c39f4b1da7ed4fc69cc090fb776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba98f73a1cfbe02b1301005349bb0cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5ba98f73a1cfbe02b1301005349bb0cd">boxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize)</td></tr>
<tr class="separator:a5ba98f73a1cfbe02b1301005349bb0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17eb3f375ee0e72d74bb17d7eae2f04b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a17eb3f375ee0e72d74bb17d7eae2f04b">boxPoints</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> box, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points)</td></tr>
<tr class="separator:a17eb3f375ee0e72d74bb17d7eae2f04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e0929cfd8869278c03b97a062df8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a424e0929cfd8869278c03b97a062df8f">calcBackProject</a> (List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; images, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> channels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hist, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float.html">MatOfFloat</a> ranges, double scale)</td></tr>
<tr class="separator:a424e0929cfd8869278c03b97a062df8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e1cd1bc0ad5fb28dff3b004b769756"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a73e1cd1bc0ad5fb28dff3b004b769756">calcHist</a> (List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; images, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> channels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hist, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> histSize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float.html">MatOfFloat</a> ranges, bool <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad6f1d32ccd2ebbc5c576dd5630391f4f">accumulate</a>)</td></tr>
<tr class="separator:a73e1cd1bc0ad5fb28dff3b004b769756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e6e9f69e14b2659739e8973f0a4b44"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa0e6e9f69e14b2659739e8973f0a4b44">calcHist</a> (List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt; images, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> channels, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hist, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> histSize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float.html">MatOfFloat</a> ranges)</td></tr>
<tr class="separator:aa0e6e9f69e14b2659739e8973f0a4b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fcf5ff5501809e323ac7a405791863"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a19fcf5ff5501809e323ac7a405791863">circle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, int radius, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, int shift)</td></tr>
<tr class="separator:a19fcf5ff5501809e323ac7a405791863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eb4ee60e6ebd9e075c164302f86f94"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a03eb4ee60e6ebd9e075c164302f86f94">circle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, int radius, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:a03eb4ee60e6ebd9e075c164302f86f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b95f831d5acf8071fb8c97d89de990"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a43b95f831d5acf8071fb8c97d89de990">circle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, int radius, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:a43b95f831d5acf8071fb8c97d89de990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510686f2423c8f5ccce1d28c6749cbb0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a510686f2423c8f5ccce1d28c6749cbb0">circle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, int radius, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a510686f2423c8f5ccce1d28c6749cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3fa4b004f499201f2d8a3e4f29736c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8f3fa4b004f499201f2d8a3e4f29736c">convertMaps</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dstmap1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dstmap2, int dstmap1type, bool nninterpolation)</td></tr>
<tr class="separator:a8f3fa4b004f499201f2d8a3e4f29736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a5dfdd097f276535e6bc1bb219de1f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af7a5dfdd097f276535e6bc1bb219de1f">convertMaps</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dstmap1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dstmap2, int dstmap1type)</td></tr>
<tr class="separator:af7a5dfdd097f276535e6bc1bb219de1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b420ddcf1093536f060a33e137441df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8b420ddcf1093536f060a33e137441df">convexHull</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> hull, bool clockwise)</td></tr>
<tr class="separator:a8b420ddcf1093536f060a33e137441df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7db0720f71cb64f7782e5ae44a339ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af7db0720f71cb64f7782e5ae44a339ac">convexHull</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> hull)</td></tr>
<tr class="separator:af7db0720f71cb64f7782e5ae44a339ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1795beca8c208a75622113f715c3f1e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1795beca8c208a75622113f715c3f1e7">convexityDefects</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> contour, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a> convexhull, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int4.html">MatOfInt4</a> convexityDefects)</td></tr>
<tr class="separator:a1795beca8c208a75622113f715c3f1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1335f3e60433b7ca5fe59fca8afbe3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a1335f3e60433b7ca5fe59fca8afbe3">cornerEigenValsAndVecs</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int blockSize, int ksize, int borderType)</td></tr>
<tr class="separator:a5a1335f3e60433b7ca5fe59fca8afbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a24fecf761eb4cfcdbe68047fc6b34"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af2a24fecf761eb4cfcdbe68047fc6b34">cornerEigenValsAndVecs</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int blockSize, int ksize)</td></tr>
<tr class="separator:af2a24fecf761eb4cfcdbe68047fc6b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8ad0c7fab4c1f49409707163b2bc1a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int blockSize, int ksize, double k, int borderType)</td></tr>
<tr class="separator:a0f8ad0c7fab4c1f49409707163b2bc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e245e4638674325ec5c618c8ab73644"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8e245e4638674325ec5c618c8ab73644">cornerHarris</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int blockSize, int ksize, double k)</td></tr>
<tr class="separator:a8e245e4638674325ec5c618c8ab73644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdac67e089b6ea241ca3663cee1847b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int blockSize, int ksize, int borderType)</td></tr>
<tr class="separator:a4bdac67e089b6ea241ca3663cee1847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03bb5d7ff7b7ff0f5ea8a23c5ef9062"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa03bb5d7ff7b7ff0f5ea8a23c5ef9062">cornerMinEigenVal</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int blockSize, int ksize)</td></tr>
<tr class="separator:aa03bb5d7ff7b7ff0f5ea8a23c5ef9062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f193db7694dd3b9e7a66dfbc9e8ece"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a18f193db7694dd3b9e7a66dfbc9e8ece">cornerMinEigenVal</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int blockSize)</td></tr>
<tr class="separator:a18f193db7694dd3b9e7a66dfbc9e8ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e07d6d17eb513d89b93aa1f697fb7ce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0e07d6d17eb513d89b93aa1f697fb7ce">cornerSubPix</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> corners, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> winSize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> zeroZone, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="separator:a0e07d6d17eb513d89b93aa1f697fb7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfbb62171548daeca05ae48d3438ec3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bfbb62171548daeca05ae48d3438ec3">createHanningWindow</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> winSize, int type)</td></tr>
<tr class="separator:a2bfbb62171548daeca05ae48d3438ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eb47c7f4f3a5faff238c3dc8a8a9e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5eb47c7f4f3a5faff238c3dc8a8a9e2">cvtColor</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int code, int dstCn)</td></tr>
<tr class="separator:ab5eb47c7f4f3a5faff238c3dc8a8a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6085870b4e8f1ecd8a68329c1008873"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa6085870b4e8f1ecd8a68329c1008873">cvtColor</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int code)</td></tr>
<tr class="separator:aa6085870b4e8f1ecd8a68329c1008873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d84345e62f04a96a1da2297123373b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae6d84345e62f04a96a1da2297123373b">cvtColorTwoPlane</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int code)</td></tr>
<tr class="separator:ae6d84345e62f04a96a1da2297123373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd6b27e9616dec9b61b3f8e06f92644"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8fd6b27e9616dec9b61b3f8e06f92644">demosaicing</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int code, int dstCn)</td></tr>
<tr class="separator:a8fd6b27e9616dec9b61b3f8e06f92644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b902a939f86b6e5dfa5c081ff2093f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a99b902a939f86b6e5dfa5c081ff2093f">demosaicing</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int code)</td></tr>
<tr class="separator:a99b902a939f86b6e5dfa5c081ff2093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8132a3a849ddc6e08c26e46a74c2666d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8132a3a849ddc6e08c26e46a74c2666d">dilate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations, int borderType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> borderValue)</td></tr>
<tr class="separator:a8132a3a849ddc6e08c26e46a74c2666d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0089380bc0cf435f41d8bad067135b65"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0089380bc0cf435f41d8bad067135b65">dilate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations, int borderType)</td></tr>
<tr class="separator:a0089380bc0cf435f41d8bad067135b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af020278c9a054565cc3fc484b13d8e48"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af020278c9a054565cc3fc484b13d8e48">dilate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations)</td></tr>
<tr class="separator:af020278c9a054565cc3fc484b13d8e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f44c23079faa93e660a5873f1f1859d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6f44c23079faa93e660a5873f1f1859d">dilate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:a6f44c23079faa93e660a5873f1f1859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0fd81f42025984ecfb5d6197dcd21f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8b0fd81f42025984ecfb5d6197dcd21f">dilate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel)</td></tr>
<tr class="separator:a8b0fd81f42025984ecfb5d6197dcd21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb5667cefbe98eeef9dff4b1c00181b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4fb5667cefbe98eeef9dff4b1c00181b">distanceTransformWithLabels</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, int distanceType, int maskSize, int labelType)</td></tr>
<tr class="separator:a4fb5667cefbe98eeef9dff4b1c00181b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c64db4e1532b13547cef3bf4c9f407e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2c64db4e1532b13547cef3bf4c9f407e">distanceTransformWithLabels</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> labels, int distanceType, int maskSize)</td></tr>
<tr class="separator:a2c64db4e1532b13547cef3bf4c9f407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9a15337aebe89ae8eeca9b73e0d46"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a40a9a15337aebe89ae8eeca9b73e0d46">distanceTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int distanceType, int maskSize, int dstType)</td></tr>
<tr class="separator:a40a9a15337aebe89ae8eeca9b73e0d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1d292af1f4d8af72b861826d47dc4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abb1d292af1f4d8af72b861826d47dc4c">distanceTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int distanceType, int maskSize)</td></tr>
<tr class="separator:abb1d292af1f4d8af72b861826d47dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a742bf4f67b16ea1094a000a0646a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, int contourIdx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hierarchy, int maxLevel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> offset)</td></tr>
<tr class="separator:a598a742bf4f67b16ea1094a000a0646a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ee9de2d58e5a4619ade8811e77954b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a26ee9de2d58e5a4619ade8811e77954b">drawContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, int contourIdx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hierarchy, int maxLevel)</td></tr>
<tr class="separator:a26ee9de2d58e5a4619ade8811e77954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd67e0986a2b308f9e488e6d09799c8a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afd67e0986a2b308f9e488e6d09799c8a">drawContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, int contourIdx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hierarchy)</td></tr>
<tr class="separator:afd67e0986a2b308f9e488e6d09799c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7c77135ed8e55bb5acfebe5a3b0fa3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4a7c77135ed8e55bb5acfebe5a3b0fa3">drawContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, int contourIdx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:a4a7c77135ed8e55bb5acfebe5a3b0fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c1427e91203acf0fa0b45f6d292592"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a35c1427e91203acf0fa0b45f6d292592">drawContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, int contourIdx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:a35c1427e91203acf0fa0b45f6d292592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852ee36feb791f6749db1fe6c6b24d76"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a852ee36feb791f6749db1fe6c6b24d76">drawContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, int contourIdx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a852ee36feb791f6749db1fe6c6b24d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906fcc9d312c55df41ececf0ddde7cd3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a906fcc9d312c55df41ececf0ddde7cd3">drawMarker</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> position, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int markerType, int markerSize, int thickness, int line_type)</td></tr>
<tr class="separator:a906fcc9d312c55df41ececf0ddde7cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615f2945468d056c87b3bc5e798a5b1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a615f2945468d056c87b3bc5e798a5b1b">drawMarker</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> position, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int markerType, int markerSize, int thickness)</td></tr>
<tr class="separator:a615f2945468d056c87b3bc5e798a5b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea11fa46912c8a695750400bb440fc72"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aea11fa46912c8a695750400bb440fc72">drawMarker</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> position, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int markerType, int markerSize)</td></tr>
<tr class="separator:aea11fa46912c8a695750400bb440fc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710b399600cfb48606f6cedae8316c61"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a710b399600cfb48606f6cedae8316c61">drawMarker</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> position, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int markerType)</td></tr>
<tr class="separator:a710b399600cfb48606f6cedae8316c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9801a5338095e635c014fba39cf95787"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9801a5338095e635c014fba39cf95787">drawMarker</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> position, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a9801a5338095e635c014fba39cf95787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8e6a68c31eeb83e710a22e808a3f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab3c8e6a68c31eeb83e710a22e808a3f3">ellipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> axes, double angle, double startAngle, double endAngle, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, int shift)</td></tr>
<tr class="separator:ab3c8e6a68c31eeb83e710a22e808a3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233d52dc944bca38b23167ba376a484d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a233d52dc944bca38b23167ba376a484d">ellipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> axes, double angle, double startAngle, double endAngle, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:a233d52dc944bca38b23167ba376a484d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f590e8200e98d7ad793c625a9c0686f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1f590e8200e98d7ad793c625a9c0686f">ellipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> axes, double angle, double startAngle, double endAngle, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:a1f590e8200e98d7ad793c625a9c0686f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21725f465a2d1db4857038253431d90a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a21725f465a2d1db4857038253431d90a">ellipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> axes, double angle, double startAngle, double endAngle, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a21725f465a2d1db4857038253431d90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c6f8e7069cc4ed3b4f40497e6a320c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a09c6f8e7069cc4ed3b4f40497e6a320c">ellipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> box, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:a09c6f8e7069cc4ed3b4f40497e6a320c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a17033ab94731170443aa02e40e2b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab1a17033ab94731170443aa02e40e2b6">ellipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> box, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:ab1a17033ab94731170443aa02e40e2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1813fadcecde7e54fa97259b37efdc7f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1813fadcecde7e54fa97259b37efdc7f">ellipse</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> box, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a1813fadcecde7e54fa97259b37efdc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a872c1660203e992237241a1f76c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a7a872c1660203e992237241a1f76c7">ellipse2Poly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> axes, int angle, int arcStart, int arcEnd, int delta, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> pts)</td></tr>
<tr class="separator:a8a7a872c1660203e992237241a1f76c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad249c9fa6bcde1e21f7ea7c227558987"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad249c9fa6bcde1e21f7ea7c227558987">equalizeHist</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:ad249c9fa6bcde1e21f7ea7c227558987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d8a9c0378980731f7520977a7baeb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aec3d8a9c0378980731f7520977a7baeb">erode</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations, int borderType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> borderValue)</td></tr>
<tr class="separator:aec3d8a9c0378980731f7520977a7baeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b63bd3af8f276538704bed25bf3e0d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac2b63bd3af8f276538704bed25bf3e0d">erode</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations, int borderType)</td></tr>
<tr class="separator:ac2b63bd3af8f276538704bed25bf3e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c649ecb1f1977836b1ade1e202fff0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5c649ecb1f1977836b1ade1e202fff0f">erode</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations)</td></tr>
<tr class="separator:a5c649ecb1f1977836b1ade1e202fff0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92e5d5dc06c6074bf1e780b349f4715"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa92e5d5dc06c6074bf1e780b349f4715">erode</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:aa92e5d5dc06c6074bf1e780b349f4715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637819bd4e1951afc87800380c8c0f69"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a637819bd4e1951afc87800380c8c0f69">erode</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel)</td></tr>
<tr class="separator:a637819bd4e1951afc87800380c8c0f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe78037c39ca5ef1e98e621a6ac38116"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abe78037c39ca5ef1e98e621a6ac38116">fillConvexPoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int lineType, int shift)</td></tr>
<tr class="separator:abe78037c39ca5ef1e98e621a6ac38116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff50d208a28121e54d227e5fd181554"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4ff50d208a28121e54d227e5fd181554">fillConvexPoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int lineType)</td></tr>
<tr class="separator:a4ff50d208a28121e54d227e5fd181554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fb61d36061044cc793bb34320aa03b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a78fb61d36061044cc793bb34320aa03b">fillConvexPoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a78fb61d36061044cc793bb34320aa03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345500dfd93fc1ec89d567c883c50bc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int lineType, int shift, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> offset)</td></tr>
<tr class="separator:a345500dfd93fc1ec89d567c883c50bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad807352623eace94a8437d9513fa1f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aad807352623eace94a8437d9513fa1f7">fillPoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int lineType, int shift)</td></tr>
<tr class="separator:aad807352623eace94a8437d9513fa1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73179cfef9db2f7e11a9cd8628fc46f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad73179cfef9db2f7e11a9cd8628fc46f">fillPoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int lineType)</td></tr>
<tr class="separator:ad73179cfef9db2f7e11a9cd8628fc46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d573989468bd4912c9e4641ab53756b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8d573989468bd4912c9e4641ab53756b">fillPoly</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a8d573989468bd4912c9e4641ab53756b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22a21837035da2a35e853f9e8725fd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad22a21837035da2a35e853f9e8725fd9">filter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, double delta, int borderType)</td></tr>
<tr class="separator:ad22a21837035da2a35e853f9e8725fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5317c87bd4446426581d2e6ad7858d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af5317c87bd4446426581d2e6ad7858d8">filter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, double delta)</td></tr>
<tr class="separator:af5317c87bd4446426581d2e6ad7858d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac507f61d73e13a7b393d55c0083bc8f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac507f61d73e13a7b393d55c0083bc8f0">filter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:ac507f61d73e13a7b393d55c0083bc8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9199038849974109ad76d212d753fe8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad9199038849974109ad76d212d753fe8">filter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel)</td></tr>
<tr class="separator:ad9199038849974109ad76d212d753fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3fe471f679fa851ffce18e751d8625"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0a3fe471f679fa851ffce18e751d8625">findContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hierarchy, int mode, int method, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> offset)</td></tr>
<tr class="separator:a0a3fe471f679fa851ffce18e751d8625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b13506d50ef4ad9a6c909cdb95cd82"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a86b13506d50ef4ad9a6c909cdb95cd82">findContours</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; contours, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> hierarchy, int mode, int method)</td></tr>
<tr class="separator:a86b13506d50ef4ad9a6c909cdb95cd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6753e91a584383f93134b16b332e75f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac6753e91a584383f93134b16b332e75f">fitLine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08f6c6182fd1fdb9dec625a253e91eae">line</a>, int distType, double param, double reps, double aeps)</td></tr>
<tr class="separator:ac6753e91a584383f93134b16b332e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae449bb66300f367c5c3efef85954520a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> ky, int dx, int dy, int ksize, bool normalize, int ktype)</td></tr>
<tr class="separator:ae449bb66300f367c5c3efef85954520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9233ff67ebbf9a924af8c5ca70e92aa9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9233ff67ebbf9a924af8c5ca70e92aa9">getDerivKernels</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> ky, int dx, int dy, int ksize, bool normalize)</td></tr>
<tr class="separator:a9233ff67ebbf9a924af8c5ca70e92aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4014e40fc997a265bcad9f7070068a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae4014e40fc997a265bcad9f7070068a6">getDerivKernels</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> ky, int dx, int dy, int ksize)</td></tr>
<tr class="separator:ae4014e40fc997a265bcad9f7070068a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0138aec67899d4c27984b0ed6768c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2e0138aec67899d4c27984b0ed6768c7">getRectSubPix</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> patchSize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> patch, int patchType)</td></tr>
<tr class="separator:a2e0138aec67899d4c27984b0ed6768c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fc1408818b57adeaa85bd1098ab202"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a23fc1408818b57adeaa85bd1098ab202">getRectSubPix</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> patchSize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> patch)</td></tr>
<tr class="separator:a23fc1408818b57adeaa85bd1098ab202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695f38150588aa30eb476bd590bdd47"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab695f38150588aa30eb476bd590bdd47">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int blockSize, int gradientSize, bool useHarrisDetector, double k)</td></tr>
<tr class="separator:ab695f38150588aa30eb476bd590bdd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7de9aa4f2af6e36499aaf607fcb51f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa7de9aa4f2af6e36499aaf607fcb51f7">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int blockSize, int gradientSize, bool useHarrisDetector)</td></tr>
<tr class="separator:aa7de9aa4f2af6e36499aaf607fcb51f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179279ba725050549a3ee51f1c1e96ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a179279ba725050549a3ee51f1c1e96ba">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int blockSize, int gradientSize)</td></tr>
<tr class="separator:a179279ba725050549a3ee51f1c1e96ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8104c378c7a9978d3cdd23cb7be13be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa8104c378c7a9978d3cdd23cb7be13be">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int blockSize, bool useHarrisDetector, double k)</td></tr>
<tr class="separator:aa8104c378c7a9978d3cdd23cb7be13be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a9982aa926182fa6c23c0f195732a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac1a9982aa926182fa6c23c0f195732a4">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int blockSize, bool useHarrisDetector)</td></tr>
<tr class="separator:ac1a9982aa926182fa6c23c0f195732a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2ffdacdb79e78682d75c262d01ccb4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8c2ffdacdb79e78682d75c262d01ccb4">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, int blockSize)</td></tr>
<tr class="separator:a8c2ffdacdb79e78682d75c262d01ccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fe76978f8adf7a3d4575683ef12cda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad4fe76978f8adf7a3d4575683ef12cda">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:ad4fe76978f8adf7a3d4575683ef12cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4af3356b35847561e1655eb2faf1340"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab4af3356b35847561e1655eb2faf1340">goodFeaturesToTrack</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> corners, int maxCorners, double qualityLevel, double minDistance)</td></tr>
<tr class="separator:ab4af3356b35847561e1655eb2faf1340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae28998c34224bf8348f317f879f97f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8ae28998c34224bf8348f317f879f97f">grabCut</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rect, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> bgdModel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> fgdModel, int iterCount, int mode)</td></tr>
<tr class="separator:a8ae28998c34224bf8348f317f879f97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30d08f93c5d646ec7326866294c982e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa30d08f93c5d646ec7326866294c982e">grabCut</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rect, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> bgdModel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> fgdModel, int iterCount)</td></tr>
<tr class="separator:aa30d08f93c5d646ec7326866294c982e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eb4556cf9ec83c9c5010ac233e57f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a41eb4556cf9ec83c9c5010ac233e57f7">integral3</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sqsum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tilted, int sdepth, int sqdepth)</td></tr>
<tr class="separator:a41eb4556cf9ec83c9c5010ac233e57f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cacdf642be42bbd52701d887ea58f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad2cacdf642be42bbd52701d887ea58f1">integral3</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sqsum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tilted, int sdepth)</td></tr>
<tr class="separator:ad2cacdf642be42bbd52701d887ea58f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ac2dd520f6993fee65004cae03c633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab9ac2dd520f6993fee65004cae03c633">integral3</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sqsum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> tilted)</td></tr>
<tr class="separator:ab9ac2dd520f6993fee65004cae03c633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad357280d311b6cd6a724d846f378d2ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad357280d311b6cd6a724d846f378d2ff">integral2</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sqsum, int sdepth, int sqdepth)</td></tr>
<tr class="separator:ad357280d311b6cd6a724d846f378d2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8dcdac5a8affc068e14c2d6c90951"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3ce8dcdac5a8affc068e14c2d6c90951">integral2</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sqsum, int sdepth)</td></tr>
<tr class="separator:a3ce8dcdac5a8affc068e14c2d6c90951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30160f0c5c0bc652fffe8c4e29706479"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a30160f0c5c0bc652fffe8c4e29706479">integral2</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sqsum)</td></tr>
<tr class="separator:a30160f0c5c0bc652fffe8c4e29706479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de47b4e016e986eb5636b4dbd0e34ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7de47b4e016e986eb5636b4dbd0e34ba">integral</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum, int sdepth)</td></tr>
<tr class="separator:a7de47b4e016e986eb5636b4dbd0e34ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d91c3655547c49e7ab285b42046313"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a61d91c3655547c49e7ab285b42046313">integral</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> sum)</td></tr>
<tr class="separator:a61d91c3655547c49e7ab285b42046313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80e5dd8a074d21e406024b8e6352a60"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad80e5dd8a074d21e406024b8e6352a60">invertAffineTransform</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> iM)</td></tr>
<tr class="separator:ad80e5dd8a074d21e406024b8e6352a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f6c6182fd1fdb9dec625a253e91eae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08f6c6182fd1fdb9dec625a253e91eae">line</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, int shift)</td></tr>
<tr class="separator:a08f6c6182fd1fdb9dec625a253e91eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff7606a57c910d7e791fb8480bb630f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9ff7606a57c910d7e791fb8480bb630f">line</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:a9ff7606a57c910d7e791fb8480bb630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cef8c19c760a97bb4fa7bca49530f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a50cef8c19c760a97bb4fa7bca49530f0">line</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:a50cef8c19c760a97bb4fa7bca49530f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f4b3c012c42f450f7fa5dda374e16d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae7f4b3c012c42f450f7fa5dda374e16d">line</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:ae7f4b3c012c42f450f7fa5dda374e16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8dafda0dc522e6cf5d1625c44b56d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abf8dafda0dc522e6cf5d1625c44b56d2">linearPolar</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, double maxRadius, int flags)</td></tr>
<tr class="separator:abf8dafda0dc522e6cf5d1625c44b56d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec385e49d7fdd3b9a225b3bae24a4d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7ec385e49d7fdd3b9a225b3bae24a4d5">logPolar</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, double M, int flags)</td></tr>
<tr class="separator:a7ec385e49d7fdd3b9a225b3bae24a4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e0eb0521e4f8a96b776fbb5a06c098"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab3e0eb0521e4f8a96b776fbb5a06c098">matchTemplate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> templ, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> result, int method, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="separator:ab3e0eb0521e4f8a96b776fbb5a06c098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ac353db3f9a9bc26440af123e1e9ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a69ac353db3f9a9bc26440af123e1e9ad">matchTemplate</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> templ, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> result, int method)</td></tr>
<tr class="separator:a69ac353db3f9a9bc26440af123e1e9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5be8e1cb647bad739ff9bd81d85d4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3b5be8e1cb647bad739ff9bd81d85d4e">medianBlur</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ksize)</td></tr>
<tr class="separator:a3b5be8e1cb647bad739ff9bd81d85d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd84df0afa4b362123ca5dc2e7e9a58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5fd84df0afa4b362123ca5dc2e7e9a58">minEnclosingCircle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a> points, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, float[] radius)</td></tr>
<tr class="separator:a5fd84df0afa4b362123ca5dc2e7e9a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b3c848d39e08401daf8f1ee005348b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a83b3c848d39e08401daf8f1ee005348b">morphologyEx</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int op, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations, int borderType, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> borderValue)</td></tr>
<tr class="separator:a83b3c848d39e08401daf8f1ee005348b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b45c49e0e80ac980726b85c26eb810a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2b45c49e0e80ac980726b85c26eb810a">morphologyEx</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int op, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations, int borderType)</td></tr>
<tr class="separator:a2b45c49e0e80ac980726b85c26eb810a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8810646f7b3986bd787fc3e38ba87"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab3c8810646f7b3986bd787fc3e38ba87">morphologyEx</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int op, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, int iterations)</td></tr>
<tr class="separator:ab3c8810646f7b3986bd787fc3e38ba87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaad4b1047a205e9c0cdc8eb4bb551d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aeaad4b1047a205e9c0cdc8eb4bb551d3">morphologyEx</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int op, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:aeaad4b1047a205e9c0cdc8eb4bb551d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8530a9fb1785da7e3c1c2d1374fc3c2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa8530a9fb1785da7e3c1c2d1374fc3c2">morphologyEx</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int op, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernel)</td></tr>
<tr class="separator:aa8530a9fb1785da7e3c1c2d1374fc3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98ed9aaf79864022c2b3d7fa2f5648c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac98ed9aaf79864022c2b3d7fa2f5648c">polylines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, bool isClosed, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, int shift)</td></tr>
<tr class="separator:ac98ed9aaf79864022c2b3d7fa2f5648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6ffa373b44b2871ff79ab47f7c92f4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aec6ffa373b44b2871ff79ab47f7c92f4">polylines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, bool isClosed, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:aec6ffa373b44b2871ff79ab47f7c92f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d85a545d08db9a55cb5f1b9c3fb5bfd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3d85a545d08db9a55cb5f1b9c3fb5bfd">polylines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, bool isClosed, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:a3d85a545d08db9a55cb5f1b9c3fb5bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471a843f77bb16367448538afdad6471"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a471a843f77bb16367448538afdad6471">polylines</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt; pts, bool isClosed, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a471a843f77bb16367448538afdad6471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba7b2fc9dec529238c58205dc6969c4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aaba7b2fc9dec529238c58205dc6969c4">preCornerDetect</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ksize, int borderType)</td></tr>
<tr class="separator:aaba7b2fc9dec529238c58205dc6969c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a298b6358b5be1af96ddc1a042fcd8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a87a298b6358b5be1af96ddc1a042fcd8">preCornerDetect</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ksize)</td></tr>
<tr class="separator:a87a298b6358b5be1af96ddc1a042fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb6b1f82df67dc5224580d77ea0fb02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aedb6b1f82df67dc5224580d77ea0fb02">putText</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, string text, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> org, int fontFace, double fontScale, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, bool bottomLeftOrigin)</td></tr>
<tr class="separator:aedb6b1f82df67dc5224580d77ea0fb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81bb458e42dd2ab94a8d1b07410d189"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af81bb458e42dd2ab94a8d1b07410d189">putText</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, string text, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> org, int fontFace, double fontScale, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:af81bb458e42dd2ab94a8d1b07410d189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0db98c79737c96a2d9a1ff366998e05"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab0db98c79737c96a2d9a1ff366998e05">putText</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, string text, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> org, int fontFace, double fontScale, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:ab0db98c79737c96a2d9a1ff366998e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262a6d8baa2a6f9a184bc5e42d5a9655"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a262a6d8baa2a6f9a184bc5e42d5a9655">putText</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, string text, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> org, int fontFace, double fontScale, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a262a6d8baa2a6f9a184bc5e42d5a9655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af095ac8765714266d30bc24d55bfa068"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af095ac8765714266d30bc24d55bfa068">pyrDown</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dstsize, int borderType)</td></tr>
<tr class="separator:af095ac8765714266d30bc24d55bfa068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5227f72d5d796183271b503a2f5b2e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af5227f72d5d796183271b503a2f5b2e8">pyrDown</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dstsize)</td></tr>
<tr class="separator:af5227f72d5d796183271b503a2f5b2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d074422b89b2d9ccbd5216f86753e0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a20d074422b89b2d9ccbd5216f86753e0">pyrDown</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:a20d074422b89b2d9ccbd5216f86753e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78838a4dac65a1ae6c5caa88ef9bd149"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a78838a4dac65a1ae6c5caa88ef9bd149">pyrMeanShiftFiltering</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double sp, double sr, int maxLevel, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a> termcrit)</td></tr>
<tr class="separator:a78838a4dac65a1ae6c5caa88ef9bd149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c98c7b87159575a278472d88f51c5cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1c98c7b87159575a278472d88f51c5cd">pyrMeanShiftFiltering</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double sp, double sr, int maxLevel)</td></tr>
<tr class="separator:a1c98c7b87159575a278472d88f51c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b3281fb1f948ea9e9ef0a922a655c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8c9b3281fb1f948ea9e9ef0a922a655c">pyrMeanShiftFiltering</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, double sp, double sr)</td></tr>
<tr class="separator:a8c9b3281fb1f948ea9e9ef0a922a655c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b6a512cd3ccb5c1165e2a54e0ecee2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a58b6a512cd3ccb5c1165e2a54e0ecee2">pyrUp</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dstsize, int borderType)</td></tr>
<tr class="separator:a58b6a512cd3ccb5c1165e2a54e0ecee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07489c4023ab80a46ed4adccddae1aa5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a07489c4023ab80a46ed4adccddae1aa5">pyrUp</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dstsize)</td></tr>
<tr class="separator:a07489c4023ab80a46ed4adccddae1aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada36bb8545d8c4017480c800da8266a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aada36bb8545d8c4017480c800da8266a">pyrUp</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst)</td></tr>
<tr class="separator:aada36bb8545d8c4017480c800da8266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af305be5b7e383b14309a26c79a4de7a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af305be5b7e383b14309a26c79a4de7a2">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, int shift)</td></tr>
<tr class="separator:af305be5b7e383b14309a26c79a4de7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ef754055d88064bd7130e407aa5c87"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad5ef754055d88064bd7130e407aa5c87">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:ad5ef754055d88064bd7130e407aa5c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbced45d096fbc644a4317923dbaf4f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adbced45d096fbc644a4317923dbaf4f0">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:adbced45d096fbc644a4317923dbaf4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00587eedad371a402e892e2aa33ef51a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a00587eedad371a402e892e2aa33ef51a">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> pt2, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a00587eedad371a402e892e2aa33ef51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c11a800d85f7cc430d1a35a390d44de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0c11a800d85f7cc430d1a35a390d44de">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rec, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType, int shift)</td></tr>
<tr class="separator:a0c11a800d85f7cc430d1a35a390d44de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39097cc807c5dfebb3cd48f6cd869de0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a39097cc807c5dfebb3cd48f6cd869de0">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rec, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness, int lineType)</td></tr>
<tr class="separator:a39097cc807c5dfebb3cd48f6cd869de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad353d33e7ef513840d65c8745b09f1b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad353d33e7ef513840d65c8745b09f1b7">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rec, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color, int thickness)</td></tr>
<tr class="separator:ad353d33e7ef513840d65c8745b09f1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85da408f59ec38cdd47c227f20e699e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a85da408f59ec38cdd47c227f20e699e5">rectangle</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> img, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> rec, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> color)</td></tr>
<tr class="separator:a85da408f59ec38cdd47c227f20e699e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec52c137086f54b94e1d2b63375b71b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aec52c137086f54b94e1d2b63375b71b6">remap</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map2, int interpolation, int borderMode, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> borderValue)</td></tr>
<tr class="separator:aec52c137086f54b94e1d2b63375b71b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72178fed86c7a059d7e6b99c10bce1c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72178fed86c7a059d7e6b99c10bce1c0">remap</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map2, int interpolation, int borderMode)</td></tr>
<tr class="separator:a72178fed86c7a059d7e6b99c10bce1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6c2b9d2b03739eb7863319c2e69462"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5e6c2b9d2b03739eb7863319c2e69462">remap</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map1, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> map2, int interpolation)</td></tr>
<tr class="separator:a5e6c2b9d2b03739eb7863319c2e69462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff0030ce002733467640953ecc5b032"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7ff0030ce002733467640953ecc5b032">resize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, double fx, double fy, int interpolation)</td></tr>
<tr class="separator:a7ff0030ce002733467640953ecc5b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393a0871cd7353170aa47dc96cca13fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a393a0871cd7353170aa47dc96cca13fd">resize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, double fx, double fy)</td></tr>
<tr class="separator:a393a0871cd7353170aa47dc96cca13fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5453ae767d79b289b3ee56dfb15bd21c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5453ae767d79b289b3ee56dfb15bd21c">resize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, double fx)</td></tr>
<tr class="separator:a5453ae767d79b289b3ee56dfb15bd21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd892d0e4767ff0a3fdba7536a1ba06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6fd892d0e4767ff0a3fdba7536a1ba06">resize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize)</td></tr>
<tr class="separator:a6fd892d0e4767ff0a3fdba7536a1ba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283f8733d3d2de422385d88e70b51f19"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a283f8733d3d2de422385d88e70b51f19">sepFilter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelX, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelY, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, double delta, int borderType)</td></tr>
<tr class="separator:a283f8733d3d2de422385d88e70b51f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258308a6c84af634a7dad5a288c64a3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a258308a6c84af634a7dad5a288c64a3e">sepFilter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelX, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelY, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, double delta)</td></tr>
<tr class="separator:a258308a6c84af634a7dad5a288c64a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c4d9909ca5a59b8ad3e9e77e528e0e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a00c4d9909ca5a59b8ad3e9e77e528e0e">sepFilter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelX, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelY, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:a00c4d9909ca5a59b8ad3e9e77e528e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1762ace53f93346a490a8948a946cf0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac1762ace53f93346a490a8948a946cf0">sepFilter2D</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelX, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> kernelY)</td></tr>
<tr class="separator:ac1762ace53f93346a490a8948a946cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a69131018461ba1390bf7c31b8966e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a17a69131018461ba1390bf7c31b8966e">spatialGradient</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dy, int ksize, int borderType)</td></tr>
<tr class="separator:a17a69131018461ba1390bf7c31b8966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663bf8a7ccc7ac59ada1cf7c6b83d14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae663bf8a7ccc7ac59ada1cf7c6b83d14">spatialGradient</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dy, int ksize)</td></tr>
<tr class="separator:ae663bf8a7ccc7ac59ada1cf7c6b83d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60384a42f9d0ea9aac40bea76dfa5c8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a60384a42f9d0ea9aac40bea76dfa5c8c">spatialGradient</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dx, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dy)</td></tr>
<tr class="separator:a60384a42f9d0ea9aac40bea76dfa5c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ac9645596e3a21376519d69b57729"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad52ac9645596e3a21376519d69b57729">sqrBoxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, bool normalize, int borderType)</td></tr>
<tr class="separator:ad52ac9645596e3a21376519d69b57729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1852560876d37662a782e222f1b80e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1f1852560876d37662a782e222f1b80e">sqrBoxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor, bool normalize)</td></tr>
<tr class="separator:a1f1852560876d37662a782e222f1b80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e64eb3878dac69e291a3d873f7e1be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a06e64eb3878dac69e291a3d873f7e1be">sqrBoxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> anchor)</td></tr>
<tr class="separator:a06e64eb3878dac69e291a3d873f7e1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a46f76cfe16a69ebffe4862b6b75e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a44a46f76cfe16a69ebffe4862b6b75e9">sqrBoxFilter</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, int ddepth, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> ksize)</td></tr>
<tr class="separator:a44a46f76cfe16a69ebffe4862b6b75e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74017885add09e19513333b797acc29b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a74017885add09e19513333b797acc29b">warpAffine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, int flags, int borderMode, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> borderValue)</td></tr>
<tr class="separator:a74017885add09e19513333b797acc29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e455da67fca53faf645fbb93230bcec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8e455da67fca53faf645fbb93230bcec">warpAffine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, int flags, int borderMode)</td></tr>
<tr class="separator:a8e455da67fca53faf645fbb93230bcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc765385b9a1a5f4e886ae5f0e9be52f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acc765385b9a1a5f4e886ae5f0e9be52f">warpAffine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, int flags)</td></tr>
<tr class="separator:acc765385b9a1a5f4e886ae5f0e9be52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fce376b00ed93819988045ab996568e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4fce376b00ed93819988045ab996568e">warpAffine</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize)</td></tr>
<tr class="separator:a4fce376b00ed93819988045ab996568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4244b84548efc2bac7b546fda04c6638"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4244b84548efc2bac7b546fda04c6638">warpPerspective</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, int flags, int borderMode, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> borderValue)</td></tr>
<tr class="separator:a4244b84548efc2bac7b546fda04c6638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c7bf372363a627086c6ad8d7c4b263"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a17c7bf372363a627086c6ad8d7c4b263">warpPerspective</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, int flags, int borderMode)</td></tr>
<tr class="separator:a17c7bf372363a627086c6ad8d7c4b263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5373db668c96e38044d1fb705359085e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5373db668c96e38044d1fb705359085e">warpPerspective</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, int flags)</td></tr>
<tr class="separator:a5373db668c96e38044d1fb705359085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4428aeec0a11749cf229d7b8245d2d39"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4428aeec0a11749cf229d7b8245d2d39">warpPerspective</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> M, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize)</td></tr>
<tr class="separator:a4428aeec0a11749cf229d7b8245d2d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af8823eecb80f36056f442650de4a54ae"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af8823eecb80f36056f442650de4a54ae">CC_STAT_LEFT</a> = 0</td></tr>
<tr class="separator:af8823eecb80f36056f442650de4a54ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74ad192f15cdd0bff0baa13711bd11f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa74ad192f15cdd0bff0baa13711bd11f">CC_STAT_TOP</a> = 1</td></tr>
<tr class="separator:aa74ad192f15cdd0bff0baa13711bd11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80de013264e5228023c0d60171405ae9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a80de013264e5228023c0d60171405ae9">CC_STAT_WIDTH</a> = 2</td></tr>
<tr class="separator:a80de013264e5228023c0d60171405ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9242dfdbaf6bcb7a0f7221286e82e7f9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9242dfdbaf6bcb7a0f7221286e82e7f9">CC_STAT_HEIGHT</a> = 3</td></tr>
<tr class="separator:a9242dfdbaf6bcb7a0f7221286e82e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52fe93e89b2982913c60253561c9ab8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa52fe93e89b2982913c60253561c9ab8">CC_STAT_AREA</a> = 4</td></tr>
<tr class="separator:aa52fe93e89b2982913c60253561c9ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3192d8c1c863fe9c5b651e3ab0b7d4a7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3192d8c1c863fe9c5b651e3ab0b7d4a7">CC_STAT_MAX</a> = 5</td></tr>
<tr class="separator:a3192d8c1c863fe9c5b651e3ab0b7d4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afc05a9a7316bcb03babab27fadb2ef"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1afc05a9a7316bcb03babab27fadb2ef">CONTOURS_MATCH_I1</a> = 1</td></tr>
<tr class="separator:a1afc05a9a7316bcb03babab27fadb2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1414fe7d7173f75b67d109ece750fad6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1414fe7d7173f75b67d109ece750fad6">CONTOURS_MATCH_I2</a> = 2</td></tr>
<tr class="separator:a1414fe7d7173f75b67d109ece750fad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2a645a338ce9c6f700a217d451119e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ace2a645a338ce9c6f700a217d451119e">CONTOURS_MATCH_I3</a> = 3</td></tr>
<tr class="separator:ace2a645a338ce9c6f700a217d451119e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6641ca6f19b1584f9c2ab250e30b3213"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6641ca6f19b1584f9c2ab250e30b3213">MARKER_CROSS</a> = 0</td></tr>
<tr class="separator:a6641ca6f19b1584f9c2ab250e30b3213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa413bb807bb0f0ff7c80cee38a1aac44"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa413bb807bb0f0ff7c80cee38a1aac44">MARKER_TILTED_CROSS</a> = 1</td></tr>
<tr class="separator:aa413bb807bb0f0ff7c80cee38a1aac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1469fc468f843e6f5d0f0b0164bfa976"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1469fc468f843e6f5d0f0b0164bfa976">MARKER_STAR</a> = 2</td></tr>
<tr class="separator:a1469fc468f843e6f5d0f0b0164bfa976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af660100adaebebab45b3c9e6583e555a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af660100adaebebab45b3c9e6583e555a">MARKER_DIAMOND</a> = 3</td></tr>
<tr class="separator:af660100adaebebab45b3c9e6583e555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fc535edd572792c57be5e7ce579d1f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a53fc535edd572792c57be5e7ce579d1f">MARKER_SQUARE</a> = 4</td></tr>
<tr class="separator:a53fc535edd572792c57be5e7ce579d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e9f8f80a2289e5dc1ac25fd5c2f0b8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad4e9f8f80a2289e5dc1ac25fd5c2f0b8">MARKER_TRIANGLE_UP</a> = 5</td></tr>
<tr class="separator:ad4e9f8f80a2289e5dc1ac25fd5c2f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488695f362d183c17d1dcf1dc7b165b8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a488695f362d183c17d1dcf1dc7b165b8">MARKER_TRIANGLE_DOWN</a> = 6</td></tr>
<tr class="separator:a488695f362d183c17d1dcf1dc7b165b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1754724b0680d08d4fd1c96c63a1daa6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1754724b0680d08d4fd1c96c63a1daa6">FLOODFILL_FIXED_RANGE</a> = 1 &lt;&lt; 16</td></tr>
<tr class="separator:a1754724b0680d08d4fd1c96c63a1daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3930e0cc57d7a44255f1a926df80b2c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af3930e0cc57d7a44255f1a926df80b2c">FLOODFILL_MASK_ONLY</a> = 1 &lt;&lt; 17</td></tr>
<tr class="separator:af3930e0cc57d7a44255f1a926df80b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79ab77335a6507eef9d43279b68d561"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa79ab77335a6507eef9d43279b68d561">INTERSECT_NONE</a> = 0</td></tr>
<tr class="separator:aa79ab77335a6507eef9d43279b68d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cba858171fdb252f77b6ea0c61b7de"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a96cba858171fdb252f77b6ea0c61b7de">INTERSECT_PARTIAL</a> = 1</td></tr>
<tr class="separator:a96cba858171fdb252f77b6ea0c61b7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7fa64d95abed6c8365bb6feffb522b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aaa7fa64d95abed6c8365bb6feffb522b">INTERSECT_FULL</a> = 2</td></tr>
<tr class="separator:aaa7fa64d95abed6c8365bb6feffb522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9831b1b318dd4bccb7da7ae0af3f9e0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad9831b1b318dd4bccb7da7ae0af3f9e0">CV_SHAPE_RECT</a> = 0</td></tr>
<tr class="separator:ad9831b1b318dd4bccb7da7ae0af3f9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24295561cc4a72321041ce8c0b76c4f1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a24295561cc4a72321041ce8c0b76c4f1">CV_SHAPE_CROSS</a> = 1</td></tr>
<tr class="separator:a24295561cc4a72321041ce8c0b76c4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5ad76dbb76d20fce609928e77040d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72d5ad76dbb76d20fce609928e77040d">CV_SHAPE_ELLIPSE</a> = 2</td></tr>
<tr class="separator:a72d5ad76dbb76d20fce609928e77040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7dd4c2e3f74a9adb56402d67069794"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2f7dd4c2e3f74a9adb56402d67069794">CV_SHAPE_CUSTOM</a> = 100</td></tr>
<tr class="separator:a2f7dd4c2e3f74a9adb56402d67069794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81418ddcb76acaf6142fdeed7fa5bd96"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a81418ddcb76acaf6142fdeed7fa5bd96">LSD_REFINE_NONE</a> = 0</td></tr>
<tr class="separator:a81418ddcb76acaf6142fdeed7fa5bd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f88e74247d3f2484f28e569d159d50"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab9f88e74247d3f2484f28e569d159d50">LSD_REFINE_STD</a> = 1</td></tr>
<tr class="separator:ab9f88e74247d3f2484f28e569d159d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44217d6ecd9000c2c6b3e256fdf1caa5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a44217d6ecd9000c2c6b3e256fdf1caa5">LSD_REFINE_ADV</a> = 2</td></tr>
<tr class="separator:a44217d6ecd9000c2c6b3e256fdf1caa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e028e91805b98470871674c698bfad"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a67e028e91805b98470871674c698bfad">THRESH_BINARY</a> = 0</td></tr>
<tr class="separator:a67e028e91805b98470871674c698bfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59df462c043ae03de2521b1ba9bf7849"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a59df462c043ae03de2521b1ba9bf7849">THRESH_BINARY_INV</a> = 1</td></tr>
<tr class="separator:a59df462c043ae03de2521b1ba9bf7849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e30772c80ddae780da04e3ec6bf8e77"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8e30772c80ddae780da04e3ec6bf8e77">THRESH_TRUNC</a> = 2</td></tr>
<tr class="separator:a8e30772c80ddae780da04e3ec6bf8e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44b39b5c967a0ac76701c9da1103b93"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac44b39b5c967a0ac76701c9da1103b93">THRESH_TOZERO</a> = 3</td></tr>
<tr class="separator:ac44b39b5c967a0ac76701c9da1103b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b50dc197f4aa2478e449c7d530d3eec"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4b50dc197f4aa2478e449c7d530d3eec">THRESH_TOZERO_INV</a> = 4</td></tr>
<tr class="separator:a4b50dc197f4aa2478e449c7d530d3eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0fd382bd580af2a31a1e11edc2f49a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acc0fd382bd580af2a31a1e11edc2f49a">THRESH_MASK</a> = 7</td></tr>
<tr class="separator:acc0fd382bd580af2a31a1e11edc2f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32501a520c81dbdb6241d128abd3bba8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a32501a520c81dbdb6241d128abd3bba8">THRESH_OTSU</a> = 8</td></tr>
<tr class="separator:a32501a520c81dbdb6241d128abd3bba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b309160d855309ccdb47dd0097fa50"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae5b309160d855309ccdb47dd0097fa50">THRESH_TRIANGLE</a> = 16</td></tr>
<tr class="separator:ae5b309160d855309ccdb47dd0097fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6062f7a81793d9cd9efd09f15c3b5be"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad6062f7a81793d9cd9efd09f15c3b5be">DIST_MASK_3</a> = 3</td></tr>
<tr class="separator:ad6062f7a81793d9cd9efd09f15c3b5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3ecd8a3cd87cbcc208b79ddee6bb27"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4e3ecd8a3cd87cbcc208b79ddee6bb27">DIST_MASK_5</a> = 5</td></tr>
<tr class="separator:a4e3ecd8a3cd87cbcc208b79ddee6bb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef27846422c2eaf1ddadf0f3a8f1fc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bef27846422c2eaf1ddadf0f3a8f1fc">DIST_MASK_PRECISE</a> = 0</td></tr>
<tr class="separator:a2bef27846422c2eaf1ddadf0f3a8f1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7562c2c65f347f4c894be442bbec4515"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7562c2c65f347f4c894be442bbec4515">MORPH_RECT</a> = 0</td></tr>
<tr class="separator:a7562c2c65f347f4c894be442bbec4515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b97237c6127920090566d2c3bd06f5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a44b97237c6127920090566d2c3bd06f5">MORPH_CROSS</a> = 1</td></tr>
<tr class="separator:a44b97237c6127920090566d2c3bd06f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08cc0080628eabb3252d8fc028c181d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab08cc0080628eabb3252d8fc028c181d">MORPH_ELLIPSE</a> = 2</td></tr>
<tr class="separator:ab08cc0080628eabb3252d8fc028c181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74743d222b543bc6f12feb87f31a9c55"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a74743d222b543bc6f12feb87f31a9c55">INTER_NEAREST</a> = 0</td></tr>
<tr class="separator:a74743d222b543bc6f12feb87f31a9c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e16d35f425f556033afeef60210a02c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> = 1</td></tr>
<tr class="separator:a7e16d35f425f556033afeef60210a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8443c77973c8c7be0cfe6ac37016773f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8443c77973c8c7be0cfe6ac37016773f">INTER_CUBIC</a> = 2</td></tr>
<tr class="separator:a8443c77973c8c7be0cfe6ac37016773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8569717c58401af4a264b98bcdcb47"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> = 3</td></tr>
<tr class="separator:acd8569717c58401af4a264b98bcdcb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a72412472a5833860a5c8e7b0bcfc72"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1a72412472a5833860a5c8e7b0bcfc72">INTER_LANCZOS4</a> = 4</td></tr>
<tr class="separator:a1a72412472a5833860a5c8e7b0bcfc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac360ea8f45d858397dc8060717c5c9ab"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac360ea8f45d858397dc8060717c5c9ab">INTER_LINEAR_EXACT</a> = 5</td></tr>
<tr class="separator:ac360ea8f45d858397dc8060717c5c9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6182daf93684d7d7d7dae04a7e82fd4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac6182daf93684d7d7d7dae04a7e82fd4">INTER_NEAREST_EXACT</a> = 6</td></tr>
<tr class="separator:ac6182daf93684d7d7d7dae04a7e82fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11fdbab00115af0f1375c897662635b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad11fdbab00115af0f1375c897662635b">INTER_MAX</a> = 7</td></tr>
<tr class="separator:ad11fdbab00115af0f1375c897662635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc18f533966320534f05d32ff23d377"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5cc18f533966320534f05d32ff23d377">WARP_FILL_OUTLIERS</a> = 8</td></tr>
<tr class="separator:a5cc18f533966320534f05d32ff23d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905d5a97e2f56183b8b9140c641f27f3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> = 16</td></tr>
<tr class="separator:a905d5a97e2f56183b8b9140c641f27f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12285527b5cd3888ab35f854e1fb9ce"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab12285527b5cd3888ab35f854e1fb9ce">CCL_WU</a> = 0</td></tr>
<tr class="separator:ab12285527b5cd3888ab35f854e1fb9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbdb5c12a328965de5cd8f4b7d8a262"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5dbdb5c12a328965de5cd8f4b7d8a262">CCL_DEFAULT</a> = -1</td></tr>
<tr class="separator:a5dbdb5c12a328965de5cd8f4b7d8a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c2d43d3dd377c99f18f27ab6331486"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a13c2d43d3dd377c99f18f27ab6331486">CCL_GRANA</a> = 1</td></tr>
<tr class="separator:a13c2d43d3dd377c99f18f27ab6331486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2ac590850cc0a6d9e18dd2d663108f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acf2ac590850cc0a6d9e18dd2d663108f">CHAIN_APPROX_NONE</a> = 1</td></tr>
<tr class="separator:acf2ac590850cc0a6d9e18dd2d663108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddab97f976086adada53d09d6f4a06a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afddab97f976086adada53d09d6f4a06a">CHAIN_APPROX_SIMPLE</a> = 2</td></tr>
<tr class="separator:afddab97f976086adada53d09d6f4a06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a27c7cf4f49d4f6bab7402701661f9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab1a27c7cf4f49d4f6bab7402701661f9">CHAIN_APPROX_TC89_L1</a> = 3</td></tr>
<tr class="separator:ab1a27c7cf4f49d4f6bab7402701661f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50baf08587b17d74ee973a52e13fe8e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab50baf08587b17d74ee973a52e13fe8e">CHAIN_APPROX_TC89_KCOS</a> = 4</td></tr>
<tr class="separator:ab50baf08587b17d74ee973a52e13fe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0981db573c5f55ea0c930075d8240e7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a> = -1</td></tr>
<tr class="separator:ad0981db573c5f55ea0c930075d8240e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af310012e1cbe3bd4832d7b89bd108838"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af310012e1cbe3bd4832d7b89bd108838">LINE_4</a> = 4</td></tr>
<tr class="separator:af310012e1cbe3bd4832d7b89bd108838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92adc2426a0e2b9e74e5b027bd43be7d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a92adc2426a0e2b9e74e5b027bd43be7d">LINE_8</a> = 8</td></tr>
<tr class="separator:a92adc2426a0e2b9e74e5b027bd43be7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b7230423630026dafc311e7d8d21b8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae6b7230423630026dafc311e7d8d21b8">LINE_AA</a> = 16</td></tr>
<tr class="separator:ae6b7230423630026dafc311e7d8d21b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a4ce883d819221bff4e091aeff0cac"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a10a4ce883d819221bff4e091aeff0cac">RETR_EXTERNAL</a> = 0</td></tr>
<tr class="separator:a10a4ce883d819221bff4e091aeff0cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7d69ddc37d8e0d1dcb87c30450c73"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8be7d69ddc37d8e0d1dcb87c30450c73">RETR_LIST</a> = 1</td></tr>
<tr class="separator:a8be7d69ddc37d8e0d1dcb87c30450c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1b58bbda9a0eeb208e392db7d3dd84"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4b1b58bbda9a0eeb208e392db7d3dd84">RETR_CCOMP</a> = 2</td></tr>
<tr class="separator:a4b1b58bbda9a0eeb208e392db7d3dd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71714f725ef191cbc0954ece440c8da"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa71714f725ef191cbc0954ece440c8da">RETR_TREE</a> = 3</td></tr>
<tr class="separator:aa71714f725ef191cbc0954ece440c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593948e62f3191f39e8ba7087adda6a9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a593948e62f3191f39e8ba7087adda6a9">RETR_FLOODFILL</a> = 4</td></tr>
<tr class="separator:a593948e62f3191f39e8ba7087adda6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e72839651cb58242a8ceaf1c338f64"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a25e72839651cb58242a8ceaf1c338f64">CV_BLUR_NO_SCALE</a> = 0</td></tr>
<tr class="separator:a25e72839651cb58242a8ceaf1c338f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3b0acb224b685dd81cbd0dcadd30e6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3c3b0acb224b685dd81cbd0dcadd30e6">CV_BLUR</a> = 1</td></tr>
<tr class="separator:a3c3b0acb224b685dd81cbd0dcadd30e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310d2a7368966dd402e44bce74de6899"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a310d2a7368966dd402e44bce74de6899">CV_GAUSSIAN</a> = 2</td></tr>
<tr class="separator:a310d2a7368966dd402e44bce74de6899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3283cbe031bf1e6b462c2d04b14e40e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad3283cbe031bf1e6b462c2d04b14e40e">CV_MEDIAN</a> = 3</td></tr>
<tr class="separator:ad3283cbe031bf1e6b462c2d04b14e40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86502487ec226f58921fb82d8f1ff9fa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a86502487ec226f58921fb82d8f1ff9fa">CV_BILATERAL</a> = 4</td></tr>
<tr class="separator:a86502487ec226f58921fb82d8f1ff9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7de6327fef811bfbdc7fc5a46e333f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aeb7de6327fef811bfbdc7fc5a46e333f">WARP_POLAR_LINEAR</a> = 0</td></tr>
<tr class="separator:aeb7de6327fef811bfbdc7fc5a46e333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e5836cf9fb0f2e251dfa76e85f15fc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa2e5836cf9fb0f2e251dfa76e85f15fc">WARP_POLAR_LOG</a> = 256</td></tr>
<tr class="separator:aa2e5836cf9fb0f2e251dfa76e85f15fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af328aa050c2f0751ee81fd813682a2dd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af328aa050c2f0751ee81fd813682a2dd">HOUGH_STANDARD</a> = 0</td></tr>
<tr class="separator:af328aa050c2f0751ee81fd813682a2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835a34a667a82c5f66b8c4aa8e078852"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a835a34a667a82c5f66b8c4aa8e078852">HOUGH_PROBABILISTIC</a> = 1</td></tr>
<tr class="separator:a835a34a667a82c5f66b8c4aa8e078852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b04317ee2d5ed8eccc5014019235872"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5b04317ee2d5ed8eccc5014019235872">HOUGH_MULTI_SCALE</a> = 2</td></tr>
<tr class="separator:a5b04317ee2d5ed8eccc5014019235872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8901d713ebbcaefaa4607d79eca9ad88"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> = 3</td></tr>
<tr class="separator:a8901d713ebbcaefaa4607d79eca9ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27778f2293418e3dfcbd0eba8a63740c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> = 4</td></tr>
<tr class="separator:a27778f2293418e3dfcbd0eba8a63740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253450ffe54d8a9bf3d34c796dc27713"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a253450ffe54d8a9bf3d34c796dc27713">INTER_BITS</a> = 5</td></tr>
<tr class="separator:a253450ffe54d8a9bf3d34c796dc27713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f23c8eb9e03493ce5061d7da6fe628"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a73f23c8eb9e03493ce5061d7da6fe628">INTER_BITS2</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a253450ffe54d8a9bf3d34c796dc27713">INTER_BITS</a> * 2</td></tr>
<tr class="separator:a73f23c8eb9e03493ce5061d7da6fe628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6849f3fbbb982c2376a78126dd20c053"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6849f3fbbb982c2376a78126dd20c053">INTER_TAB_SIZE</a> = 1 &lt;&lt; <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a253450ffe54d8a9bf3d34c796dc27713">INTER_BITS</a></td></tr>
<tr class="separator:a6849f3fbbb982c2376a78126dd20c053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6969f22a03fa5da2d886d0148efeebd6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6969f22a03fa5da2d886d0148efeebd6">INTER_TAB_SIZE2</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6849f3fbbb982c2376a78126dd20c053">INTER_TAB_SIZE</a> * <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6849f3fbbb982c2376a78126dd20c053">INTER_TAB_SIZE</a></td></tr>
<tr class="separator:a6969f22a03fa5da2d886d0148efeebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8672f047da65fd78bb0f35a281fe764c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8672f047da65fd78bb0f35a281fe764c">CV_GAUSSIAN_5x5</a> = 7</td></tr>
<tr class="separator:a8672f047da65fd78bb0f35a281fe764c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01173573ab914c49684bc9bda441fb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6d01173573ab914c49684bc9bda441fb">CV_SCHARR</a> = -1</td></tr>
<tr class="separator:a6d01173573ab914c49684bc9bda441fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9150a3481c65d5e933fb9f3190228d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adb9150a3481c65d5e933fb9f3190228d">CV_MAX_SOBEL_KSIZE</a> = 7</td></tr>
<tr class="separator:adb9150a3481c65d5e933fb9f3190228d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa326180215d215f341bf36d3162954d3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa326180215d215f341bf36d3162954d3">CV_RGBA2mRGBA</a> = 125</td></tr>
<tr class="separator:aa326180215d215f341bf36d3162954d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0808d6219d27bb2cfe09ced70e38183"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac0808d6219d27bb2cfe09ced70e38183">CV_mRGBA2RGBA</a> = 126</td></tr>
<tr class="separator:ac0808d6219d27bb2cfe09ced70e38183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369d61dfa82600a9a8c5dab36c98b4db"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a369d61dfa82600a9a8c5dab36c98b4db">CV_WARP_FILL_OUTLIERS</a> = 8</td></tr>
<tr class="separator:a369d61dfa82600a9a8c5dab36c98b4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261a84c2d36325f8c7616af4f6f08026"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a261a84c2d36325f8c7616af4f6f08026">CV_WARP_INVERSE_MAP</a> = 16</td></tr>
<tr class="separator:a261a84c2d36325f8c7616af4f6f08026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d594a0aaabd97eec25e4f1ef8c2505"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac6d594a0aaabd97eec25e4f1ef8c2505">CV_CHAIN_CODE</a> = 0</td></tr>
<tr class="separator:ac6d594a0aaabd97eec25e4f1ef8c2505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d2f3b2ab4fe35adc3ecb49770ef999"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a01d2f3b2ab4fe35adc3ecb49770ef999">CV_LINK_RUNS</a> = 5</td></tr>
<tr class="separator:a01d2f3b2ab4fe35adc3ecb49770ef999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee42565a43c4ba7bbf388daf196cb49d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aee42565a43c4ba7bbf388daf196cb49d">CV_POLY_APPROX_DP</a> = 0</td></tr>
<tr class="separator:aee42565a43c4ba7bbf388daf196cb49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbfe78d2373ae57d7a25af2af071880"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adcbfe78d2373ae57d7a25af2af071880">CV_CONTOURS_MATCH_I1</a> = 1</td></tr>
<tr class="separator:adcbfe78d2373ae57d7a25af2af071880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9b4506d4321ec7454c97475328b252"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3f9b4506d4321ec7454c97475328b252">CV_CONTOURS_MATCH_I2</a> = 2</td></tr>
<tr class="separator:a3f9b4506d4321ec7454c97475328b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a56e5fccacab050014c159bf3cfeea"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a01a56e5fccacab050014c159bf3cfeea">CV_CONTOURS_MATCH_I3</a> = 3</td></tr>
<tr class="separator:a01a56e5fccacab050014c159bf3cfeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7da8df221f4fcc5e5de63a2bdc9dea"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afa7da8df221f4fcc5e5de63a2bdc9dea">CV_CLOCKWISE</a> = 1</td></tr>
<tr class="separator:afa7da8df221f4fcc5e5de63a2bdc9dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e44c3a33cfa8f1c3ea6d5b6c23e3fc8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0e44c3a33cfa8f1c3ea6d5b6c23e3fc8">CV_COUNTER_CLOCKWISE</a> = 2</td></tr>
<tr class="separator:a0e44c3a33cfa8f1c3ea6d5b6c23e3fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3371aa091c2628717b1861525d173cdc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3371aa091c2628717b1861525d173cdc">CV_COMP_CORREL</a> = 0</td></tr>
<tr class="separator:a3371aa091c2628717b1861525d173cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc00452d3a1d38401dd1404bb8845d92"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abc00452d3a1d38401dd1404bb8845d92">CV_COMP_CHISQR</a> = 1</td></tr>
<tr class="separator:abc00452d3a1d38401dd1404bb8845d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad766e8ff379c07c5e38241a516f7a7d8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad766e8ff379c07c5e38241a516f7a7d8">CV_COMP_INTERSECT</a> = 2</td></tr>
<tr class="separator:ad766e8ff379c07c5e38241a516f7a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a46ba42de6ee8ab6a378ff6b4293f6f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9a46ba42de6ee8ab6a378ff6b4293f6f">CV_COMP_BHATTACHARYYA</a> = 3</td></tr>
<tr class="separator:a9a46ba42de6ee8ab6a378ff6b4293f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4761c46a82c3c5752e42c421e44acc01"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4761c46a82c3c5752e42c421e44acc01">CV_COMP_HELLINGER</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9a46ba42de6ee8ab6a378ff6b4293f6f">CV_COMP_BHATTACHARYYA</a></td></tr>
<tr class="separator:a4761c46a82c3c5752e42c421e44acc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e907d7e481887cf48fc9467e93ae5a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a32e907d7e481887cf48fc9467e93ae5a">CV_COMP_CHISQR_ALT</a> = 4</td></tr>
<tr class="separator:a32e907d7e481887cf48fc9467e93ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e3449daca042070a990e902a9099c1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab7e3449daca042070a990e902a9099c1">CV_COMP_KL_DIV</a> = 5</td></tr>
<tr class="separator:ab7e3449daca042070a990e902a9099c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c8e61d341f80dc3cc2fd91697c33e3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a01c8e61d341f80dc3cc2fd91697c33e3">CV_DIST_MASK_3</a> = 3</td></tr>
<tr class="separator:a01c8e61d341f80dc3cc2fd91697c33e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8045d0ce84a5182b25bb223b33beff3e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8045d0ce84a5182b25bb223b33beff3e">CV_DIST_MASK_5</a> = 5</td></tr>
<tr class="separator:a8045d0ce84a5182b25bb223b33beff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a74fd9d51c0e841c58edb02985b13e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af5a74fd9d51c0e841c58edb02985b13e">CV_DIST_MASK_PRECISE</a> = 0</td></tr>
<tr class="separator:af5a74fd9d51c0e841c58edb02985b13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7928fa5eb329ee3f87c7c96b30d9da"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ade7928fa5eb329ee3f87c7c96b30d9da">CV_DIST_LABEL_CCOMP</a> = 0</td></tr>
<tr class="separator:ade7928fa5eb329ee3f87c7c96b30d9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b470353262c58c4673f8340ffd54e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aeb0b470353262c58c4673f8340ffd54e">CV_DIST_LABEL_PIXEL</a> = 1</td></tr>
<tr class="separator:aeb0b470353262c58c4673f8340ffd54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76398bd47db6108fa15b6daad4e0d4cb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a76398bd47db6108fa15b6daad4e0d4cb">CV_DIST_USER</a> = -1</td></tr>
<tr class="separator:a76398bd47db6108fa15b6daad4e0d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c12a8eda4480ab216c29900740c8e5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad5c12a8eda4480ab216c29900740c8e5">CV_DIST_L1</a> = 1</td></tr>
<tr class="separator:ad5c12a8eda4480ab216c29900740c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106fccbc805cfd3b3772e2c12a5bf1ea"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a106fccbc805cfd3b3772e2c12a5bf1ea">CV_DIST_L2</a> = 2</td></tr>
<tr class="separator:a106fccbc805cfd3b3772e2c12a5bf1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b63a48e2b8faf57044cadf7ebaaffd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a82b63a48e2b8faf57044cadf7ebaaffd">CV_DIST_C</a> = 3</td></tr>
<tr class="separator:a82b63a48e2b8faf57044cadf7ebaaffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf4908d9c4435ab3d788b09becc56ff"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bf4908d9c4435ab3d788b09becc56ff">CV_DIST_L12</a> = 4</td></tr>
<tr class="separator:a4bf4908d9c4435ab3d788b09becc56ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e932b759b71935decb880e357c1399"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a11e932b759b71935decb880e357c1399">CV_DIST_FAIR</a> = 5</td></tr>
<tr class="separator:a11e932b759b71935decb880e357c1399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad579ccd71787d39af99868e899b8e6f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aad579ccd71787d39af99868e899b8e6f">CV_DIST_WELSCH</a> = 6</td></tr>
<tr class="separator:aad579ccd71787d39af99868e899b8e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4eb7e53e04996fa2143a39eb6c6407"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6e4eb7e53e04996fa2143a39eb6c6407">CV_DIST_HUBER</a> = 7</td></tr>
<tr class="separator:a6e4eb7e53e04996fa2143a39eb6c6407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21874a18462c20ceacec7d444bcb7cf4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a21874a18462c20ceacec7d444bcb7cf4">CV_CANNY_L2_GRADIENT</a> = (1 &lt;&lt; 31)</td></tr>
<tr class="separator:a21874a18462c20ceacec7d444bcb7cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85672d58f71afdf5a20b02c97532cfdd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a85672d58f71afdf5a20b02c97532cfdd">CV_HOUGH_STANDARD</a> = 0</td></tr>
<tr class="separator:a85672d58f71afdf5a20b02c97532cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb5d02331fb1248e6e5e79335986be"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5acb5d02331fb1248e6e5e79335986be">CV_HOUGH_PROBABILISTIC</a> = 1</td></tr>
<tr class="separator:a5acb5d02331fb1248e6e5e79335986be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1383c2ff939d3521033a4b1fbd302"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9ec1383c2ff939d3521033a4b1fbd302">CV_HOUGH_MULTI_SCALE</a> = 2</td></tr>
<tr class="separator:a9ec1383c2ff939d3521033a4b1fbd302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fb74afe4f3535c7c2d33150ec08c21"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a46fb74afe4f3535c7c2d33150ec08c21">CV_HOUGH_GRADIENT</a> = 3</td></tr>
<tr class="separator:a46fb74afe4f3535c7c2d33150ec08c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fe91c0829a43ef7c60b60a774d8c2e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a73fe91c0829a43ef7c60b60a774d8c2e">HISTCMP_CORREL</a> = 0</td></tr>
<tr class="separator:a73fe91c0829a43ef7c60b60a774d8c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30e4e433931ee2758fa6950ad31e333"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad30e4e433931ee2758fa6950ad31e333">HISTCMP_CHISQR</a> = 1</td></tr>
<tr class="separator:ad30e4e433931ee2758fa6950ad31e333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54f8b853270f901098b907915b70f0c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af54f8b853270f901098b907915b70f0c">HISTCMP_INTERSECT</a> = 2</td></tr>
<tr class="separator:af54f8b853270f901098b907915b70f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf242723a012b488c23517d74c9ace2d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abf242723a012b488c23517d74c9ace2d">HISTCMP_BHATTACHARYYA</a> = 3</td></tr>
<tr class="separator:abf242723a012b488c23517d74c9ace2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa5aaa88d1d842d58740e049a3659e2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8fa5aaa88d1d842d58740e049a3659e2">HISTCMP_HELLINGER</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abf242723a012b488c23517d74c9ace2d">HISTCMP_BHATTACHARYYA</a></td></tr>
<tr class="separator:a8fa5aaa88d1d842d58740e049a3659e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac856046261e15ce7e010df23483f82b4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac856046261e15ce7e010df23483f82b4">HISTCMP_CHISQR_ALT</a> = 4</td></tr>
<tr class="separator:ac856046261e15ce7e010df23483f82b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfec529afe9bda0a7be31caf27ef77f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afbfec529afe9bda0a7be31caf27ef77f">HISTCMP_KL_DIV</a> = 5</td></tr>
<tr class="separator:afbfec529afe9bda0a7be31caf27ef77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d0e13b982b578f699542a1aed133d8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a32d0e13b982b578f699542a1aed133d8">MORPH_ERODE</a> = 0</td></tr>
<tr class="separator:a32d0e13b982b578f699542a1aed133d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f22f6c8f32339d67522be97d39021ff"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9f22f6c8f32339d67522be97d39021ff">MORPH_DILATE</a> = 1</td></tr>
<tr class="separator:a9f22f6c8f32339d67522be97d39021ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757ead360cf1d467a71d956d538a4e42"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a757ead360cf1d467a71d956d538a4e42">MORPH_OPEN</a> = 2</td></tr>
<tr class="separator:a757ead360cf1d467a71d956d538a4e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c50e2da9019c9ea9f9e9666607d3fd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a04c50e2da9019c9ea9f9e9666607d3fd">MORPH_CLOSE</a> = 3</td></tr>
<tr class="separator:a04c50e2da9019c9ea9f9e9666607d3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919cbde8a6d706840d3d21b8d57db95a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a919cbde8a6d706840d3d21b8d57db95a">MORPH_GRADIENT</a> = 4</td></tr>
<tr class="separator:a919cbde8a6d706840d3d21b8d57db95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6e45ccefa056691b433603ec39663f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9a6e45ccefa056691b433603ec39663f">MORPH_TOPHAT</a> = 5</td></tr>
<tr class="separator:a9a6e45ccefa056691b433603ec39663f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9343a52180c5843d12fa5946be689ba9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9343a52180c5843d12fa5946be689ba9">MORPH_BLACKHAT</a> = 6</td></tr>
<tr class="separator:a9343a52180c5843d12fa5946be689ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567268baa7fea26d4888d72ad5a5eb27"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a567268baa7fea26d4888d72ad5a5eb27">MORPH_HITMISS</a> = 7</td></tr>
<tr class="separator:a567268baa7fea26d4888d72ad5a5eb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae3fc73657dbbaa86c8f5f36d54de57"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4ae3fc73657dbbaa86c8f5f36d54de57">ADAPTIVE_THRESH_MEAN_C</a> = 0</td></tr>
<tr class="separator:a4ae3fc73657dbbaa86c8f5f36d54de57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25098a4ff90d87dd757b7e1f43476b07"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a25098a4ff90d87dd757b7e1f43476b07">ADAPTIVE_THRESH_GAUSSIAN_C</a> = 1</td></tr>
<tr class="separator:a25098a4ff90d87dd757b7e1f43476b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af815a3afe07216456a40346026a40015"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af815a3afe07216456a40346026a40015">GC_INIT_WITH_RECT</a> = 0</td></tr>
<tr class="separator:af815a3afe07216456a40346026a40015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4302eb4e5f105652cb8f5ab009dc00ce"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4302eb4e5f105652cb8f5ab009dc00ce">GC_INIT_WITH_MASK</a> = 1</td></tr>
<tr class="separator:a4302eb4e5f105652cb8f5ab009dc00ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bb38e8d01ab03cc46226306489be4b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a00bb38e8d01ab03cc46226306489be4b">GC_EVAL</a> = 2</td></tr>
<tr class="separator:a00bb38e8d01ab03cc46226306489be4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a756ad278437b86b4ece9a1e4b014fb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0a756ad278437b86b4ece9a1e4b014fb">GC_EVAL_FREEZE_MODEL</a> = 3</td></tr>
<tr class="separator:a0a756ad278437b86b4ece9a1e4b014fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac544e1fbb5506c450260b187e25ceda"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aac544e1fbb5506c450260b187e25ceda">GC_BGD</a> = 0</td></tr>
<tr class="separator:aac544e1fbb5506c450260b187e25ceda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e1e0f65d4222833146c44381bd85ac"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a04e1e0f65d4222833146c44381bd85ac">GC_FGD</a> = 1</td></tr>
<tr class="separator:a04e1e0f65d4222833146c44381bd85ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5583cd38f785454cfd72b7a687bc4679"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5583cd38f785454cfd72b7a687bc4679">GC_PR_BGD</a> = 2</td></tr>
<tr class="separator:a5583cd38f785454cfd72b7a687bc4679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0567861146ba7dbb0ccd7c6641b18a29"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0567861146ba7dbb0ccd7c6641b18a29">GC_PR_FGD</a> = 3</td></tr>
<tr class="separator:a0567861146ba7dbb0ccd7c6641b18a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf1162f90c793f443e484c8b15b7503"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bf1162f90c793f443e484c8b15b7503">DIST_LABEL_CCOMP</a> = 0</td></tr>
<tr class="separator:a0bf1162f90c793f443e484c8b15b7503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c35a92d0283d14951426c724eb07d9a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4c35a92d0283d14951426c724eb07d9a">DIST_LABEL_PIXEL</a> = 1</td></tr>
<tr class="separator:a4c35a92d0283d14951426c724eb07d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd19998b32f869dd2788a32f2012aaa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8bd19998b32f869dd2788a32f2012aaa">TM_SQDIFF</a> = 0</td></tr>
<tr class="separator:a8bd19998b32f869dd2788a32f2012aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae537de6f4b01aee383b35803ac343c2f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae537de6f4b01aee383b35803ac343c2f">TM_SQDIFF_NORMED</a> = 1</td></tr>
<tr class="separator:ae537de6f4b01aee383b35803ac343c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12d0027daa5192f434a783a7d1fb568"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae12d0027daa5192f434a783a7d1fb568">TM_CCORR</a> = 2</td></tr>
<tr class="separator:ae12d0027daa5192f434a783a7d1fb568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c1fa9fc6a67cdb8045fb88f257c925"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a45c1fa9fc6a67cdb8045fb88f257c925">TM_CCORR_NORMED</a> = 3</td></tr>
<tr class="separator:a45c1fa9fc6a67cdb8045fb88f257c925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0391d35422b0e4cee4de5a688438544"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0391d35422b0e4cee4de5a688438544">TM_CCOEFF</a> = 4</td></tr>
<tr class="separator:ae0391d35422b0e4cee4de5a688438544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332ff9eea011f34087d02e168b6b5f5d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a332ff9eea011f34087d02e168b6b5f5d">TM_CCOEFF_NORMED</a> = 5</td></tr>
<tr class="separator:a332ff9eea011f34087d02e168b6b5f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30b6f164c223eadacf25a34aa843180"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa30b6f164c223eadacf25a34aa843180">COLORMAP_AUTUMN</a> = 0</td></tr>
<tr class="separator:aa30b6f164c223eadacf25a34aa843180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0e3340bdf7d7d547566558117bee85"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5b0e3340bdf7d7d547566558117bee85">COLORMAP_BONE</a> = 1</td></tr>
<tr class="separator:a5b0e3340bdf7d7d547566558117bee85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aa8eedcaa8d495928fe5b54107f558"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a73aa8eedcaa8d495928fe5b54107f558">COLORMAP_JET</a> = 2</td></tr>
<tr class="separator:a73aa8eedcaa8d495928fe5b54107f558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224e8c13c60eba35535dd860869d1864"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a224e8c13c60eba35535dd860869d1864">COLORMAP_WINTER</a> = 3</td></tr>
<tr class="separator:a224e8c13c60eba35535dd860869d1864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e081c577376a2d7f0ac7e11e3bbfb6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a35e081c577376a2d7f0ac7e11e3bbfb6">COLORMAP_RAINBOW</a> = 4</td></tr>
<tr class="separator:a35e081c577376a2d7f0ac7e11e3bbfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad772eaded7bd1f67b8007cebde1b3b17"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad772eaded7bd1f67b8007cebde1b3b17">COLORMAP_OCEAN</a> = 5</td></tr>
<tr class="separator:ad772eaded7bd1f67b8007cebde1b3b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e0be0e55576b31602b867c0bed3e53"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a03e0be0e55576b31602b867c0bed3e53">COLORMAP_SUMMER</a> = 6</td></tr>
<tr class="separator:a03e0be0e55576b31602b867c0bed3e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc5ca5979c351c5f452a37efbc89922"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abbc5ca5979c351c5f452a37efbc89922">COLORMAP_SPRING</a> = 7</td></tr>
<tr class="separator:abbc5ca5979c351c5f452a37efbc89922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e5b541d5e46f51549354d6ad94fb8b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa4e5b541d5e46f51549354d6ad94fb8b">COLORMAP_COOL</a> = 8</td></tr>
<tr class="separator:aa4e5b541d5e46f51549354d6ad94fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c2cace608f758f685d17e9200ef7d8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a85c2cace608f758f685d17e9200ef7d8">COLORMAP_HSV</a> = 9</td></tr>
<tr class="separator:a85c2cace608f758f685d17e9200ef7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2e9a80893e64b9a1f3b7005c82aca0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0a2e9a80893e64b9a1f3b7005c82aca0">COLORMAP_PINK</a> = 10</td></tr>
<tr class="separator:a0a2e9a80893e64b9a1f3b7005c82aca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edbc756cd6b0e441cbb539ae3c76ad3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8edbc756cd6b0e441cbb539ae3c76ad3">COLORMAP_HOT</a> = 11</td></tr>
<tr class="separator:a8edbc756cd6b0e441cbb539ae3c76ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce1a843bbb84b9f182fe2fb7b5ccf42"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acce1a843bbb84b9f182fe2fb7b5ccf42">COLORMAP_PARULA</a> = 12</td></tr>
<tr class="separator:acce1a843bbb84b9f182fe2fb7b5ccf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3752f38c2888c1b799d967bcf9c567c2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3752f38c2888c1b799d967bcf9c567c2">COLORMAP_MAGMA</a> = 13</td></tr>
<tr class="separator:a3752f38c2888c1b799d967bcf9c567c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f59c6c81544d975d40d70ec07aaa500"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f59c6c81544d975d40d70ec07aaa500">COLORMAP_INFERNO</a> = 14</td></tr>
<tr class="separator:a0f59c6c81544d975d40d70ec07aaa500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97603a61d63a2ab6ef82092fc242bf41"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a97603a61d63a2ab6ef82092fc242bf41">COLORMAP_PLASMA</a> = 15</td></tr>
<tr class="separator:a97603a61d63a2ab6ef82092fc242bf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb4a58364e60d9eaeee5208036cb1f2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acfb4a58364e60d9eaeee5208036cb1f2">COLORMAP_VIRIDIS</a> = 16</td></tr>
<tr class="separator:acfb4a58364e60d9eaeee5208036cb1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676f001ad2feb6a1ce1bc87d1e48e310"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a676f001ad2feb6a1ce1bc87d1e48e310">COLORMAP_CIVIDIS</a> = 17</td></tr>
<tr class="separator:a676f001ad2feb6a1ce1bc87d1e48e310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5c4f00055d5145c4aeec4f4ac77d7b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aed5c4f00055d5145c4aeec4f4ac77d7b">COLORMAP_TWILIGHT</a> = 18</td></tr>
<tr class="separator:aed5c4f00055d5145c4aeec4f4ac77d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27e32c4f45de8d73cc3089110fa2ff1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad27e32c4f45de8d73cc3089110fa2ff1">COLORMAP_TWILIGHT_SHIFTED</a> = 19</td></tr>
<tr class="separator:ad27e32c4f45de8d73cc3089110fa2ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f8e45836c18101e89100c4bff126b1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a33f8e45836c18101e89100c4bff126b1">COLORMAP_TURBO</a> = 20</td></tr>
<tr class="separator:a33f8e45836c18101e89100c4bff126b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c81c7e52c3b7f873719f8e0770de87"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa0c81c7e52c3b7f873719f8e0770de87">COLORMAP_DEEPGREEN</a> = 21</td></tr>
<tr class="separator:aa0c81c7e52c3b7f873719f8e0770de87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e46baa414f6271ba5447cf9dab76b7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a10e46baa414f6271ba5447cf9dab76b7">COLOR_BGR2BGRA</a> = 0</td></tr>
<tr class="separator:a10e46baa414f6271ba5447cf9dab76b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674e8a98bbe4b9010124caf11da0fa2a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a674e8a98bbe4b9010124caf11da0fa2a">COLOR_RGB2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a10e46baa414f6271ba5447cf9dab76b7">COLOR_BGR2BGRA</a></td></tr>
<tr class="separator:a674e8a98bbe4b9010124caf11da0fa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4271616879e7356fe83218b8a3c3a3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0a4271616879e7356fe83218b8a3c3a3">COLOR_BGRA2BGR</a> = 1</td></tr>
<tr class="separator:a0a4271616879e7356fe83218b8a3c3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746332b2bef835082d566ceeac3b46af"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a746332b2bef835082d566ceeac3b46af">COLOR_RGBA2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0a4271616879e7356fe83218b8a3c3a3">COLOR_BGRA2BGR</a></td></tr>
<tr class="separator:a746332b2bef835082d566ceeac3b46af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101295561754d1738139cf92fd47d22f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a101295561754d1738139cf92fd47d22f">COLOR_BGR2RGBA</a> = 2</td></tr>
<tr class="separator:a101295561754d1738139cf92fd47d22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ca3ac02f237c63a54ef205ce2525a9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a50ca3ac02f237c63a54ef205ce2525a9">COLOR_RGB2BGRA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a101295561754d1738139cf92fd47d22f">COLOR_BGR2RGBA</a></td></tr>
<tr class="separator:a50ca3ac02f237c63a54ef205ce2525a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add37f6071b490c68c7ba8f689a80ddaa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#add37f6071b490c68c7ba8f689a80ddaa">COLOR_RGBA2BGR</a> = 3</td></tr>
<tr class="separator:add37f6071b490c68c7ba8f689a80ddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdda38f32ceafa96d9f2537eb5334834"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abdda38f32ceafa96d9f2537eb5334834">COLOR_BGRA2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#add37f6071b490c68c7ba8f689a80ddaa">COLOR_RGBA2BGR</a></td></tr>
<tr class="separator:abdda38f32ceafa96d9f2537eb5334834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac059d41f9d702ca57c7a822719760d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3ac059d41f9d702ca57c7a822719760d">COLOR_BGR2RGB</a> = 4</td></tr>
<tr class="separator:a3ac059d41f9d702ca57c7a822719760d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427cf050f387171eae656fab7cb133ed"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a427cf050f387171eae656fab7cb133ed">COLOR_RGB2BGR</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3ac059d41f9d702ca57c7a822719760d">COLOR_BGR2RGB</a></td></tr>
<tr class="separator:a427cf050f387171eae656fab7cb133ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d8591b56f56758cc107c162fd21e30"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae4d8591b56f56758cc107c162fd21e30">COLOR_BGRA2RGBA</a> = 5</td></tr>
<tr class="separator:ae4d8591b56f56758cc107c162fd21e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085a4bb6a4cccf5bb2a9eec25da4396d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a085a4bb6a4cccf5bb2a9eec25da4396d">COLOR_RGBA2BGRA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae4d8591b56f56758cc107c162fd21e30">COLOR_BGRA2RGBA</a></td></tr>
<tr class="separator:a085a4bb6a4cccf5bb2a9eec25da4396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464aaf4c654ff382e81cca815a2719cb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a464aaf4c654ff382e81cca815a2719cb">COLOR_BGR2GRAY</a> = 6</td></tr>
<tr class="separator:a464aaf4c654ff382e81cca815a2719cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d309f61d312fad87e098a49cf6c0778"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4d309f61d312fad87e098a49cf6c0778">COLOR_RGB2GRAY</a> = 7</td></tr>
<tr class="separator:a4d309f61d312fad87e098a49cf6c0778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88af4af59300538f6a290ca3ee66e5f2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a88af4af59300538f6a290ca3ee66e5f2">COLOR_GRAY2BGR</a> = 8</td></tr>
<tr class="separator:a88af4af59300538f6a290ca3ee66e5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a12de578efca2714c878a6e768f2d8d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7a12de578efca2714c878a6e768f2d8d">COLOR_GRAY2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a88af4af59300538f6a290ca3ee66e5f2">COLOR_GRAY2BGR</a></td></tr>
<tr class="separator:a7a12de578efca2714c878a6e768f2d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659f7cf920be585a68fd39b194263fcc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a659f7cf920be585a68fd39b194263fcc">COLOR_GRAY2BGRA</a> = 9</td></tr>
<tr class="separator:a659f7cf920be585a68fd39b194263fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa9fd09f8067264ad76f57a14033135"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1aa9fd09f8067264ad76f57a14033135">COLOR_GRAY2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a659f7cf920be585a68fd39b194263fcc">COLOR_GRAY2BGRA</a></td></tr>
<tr class="separator:a1aa9fd09f8067264ad76f57a14033135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925a20e45f0320e80034100ab7a53f8b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a925a20e45f0320e80034100ab7a53f8b">COLOR_BGRA2GRAY</a> = 10</td></tr>
<tr class="separator:a925a20e45f0320e80034100ab7a53f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad505ff97dd7536d73e1aae3cee2cbf4d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad505ff97dd7536d73e1aae3cee2cbf4d">COLOR_RGBA2GRAY</a> = 11</td></tr>
<tr class="separator:ad505ff97dd7536d73e1aae3cee2cbf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69281d22f6d5ed729a97fefc0f81346"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa69281d22f6d5ed729a97fefc0f81346">COLOR_BGR2BGR565</a> = 12</td></tr>
<tr class="separator:aa69281d22f6d5ed729a97fefc0f81346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3b94eb3f9c5df394581515cb562607"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1f3b94eb3f9c5df394581515cb562607">COLOR_RGB2BGR565</a> = 13</td></tr>
<tr class="separator:a1f3b94eb3f9c5df394581515cb562607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c79696aacda8d8f1dfed030604525eb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2c79696aacda8d8f1dfed030604525eb">COLOR_BGR5652BGR</a> = 14</td></tr>
<tr class="separator:a2c79696aacda8d8f1dfed030604525eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f1d487969e7c1e5274e4908ef5d80b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad4f1d487969e7c1e5274e4908ef5d80b">COLOR_BGR5652RGB</a> = 15</td></tr>
<tr class="separator:ad4f1d487969e7c1e5274e4908ef5d80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde417d40aced9503df9929d856f7013"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afde417d40aced9503df9929d856f7013">COLOR_BGRA2BGR565</a> = 16</td></tr>
<tr class="separator:afde417d40aced9503df9929d856f7013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559f100f933e0524e38a1854ab93ed0b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a559f100f933e0524e38a1854ab93ed0b">COLOR_RGBA2BGR565</a> = 17</td></tr>
<tr class="separator:a559f100f933e0524e38a1854ab93ed0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb9097eea5ee98102b6849de6b62f07"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afbb9097eea5ee98102b6849de6b62f07">COLOR_BGR5652BGRA</a> = 18</td></tr>
<tr class="separator:afbb9097eea5ee98102b6849de6b62f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c14fa4665f6cbf773eebce019d7de0d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8c14fa4665f6cbf773eebce019d7de0d">COLOR_BGR5652RGBA</a> = 19</td></tr>
<tr class="separator:a8c14fa4665f6cbf773eebce019d7de0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f0acaf0a09d742bd2bbaf10f3da9fa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a86f0acaf0a09d742bd2bbaf10f3da9fa">COLOR_GRAY2BGR565</a> = 20</td></tr>
<tr class="separator:a86f0acaf0a09d742bd2bbaf10f3da9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1ed53133719d4d4ef979865590b144"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2f1ed53133719d4d4ef979865590b144">COLOR_BGR5652GRAY</a> = 21</td></tr>
<tr class="separator:a2f1ed53133719d4d4ef979865590b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5efc705bbb0b54b83644838c4becd1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8c5efc705bbb0b54b83644838c4becd1">COLOR_BGR2BGR555</a> = 22</td></tr>
<tr class="separator:a8c5efc705bbb0b54b83644838c4becd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bd0e9f769f22e5a877c10be6eee5d1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab6bd0e9f769f22e5a877c10be6eee5d1">COLOR_RGB2BGR555</a> = 23</td></tr>
<tr class="separator:ab6bd0e9f769f22e5a877c10be6eee5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48651e34cb670d21b6e851053729efa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac48651e34cb670d21b6e851053729efa">COLOR_BGR5552BGR</a> = 24</td></tr>
<tr class="separator:ac48651e34cb670d21b6e851053729efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c13f1f2147354ecb8a571fcd574408"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79c13f1f2147354ecb8a571fcd574408">COLOR_BGR5552RGB</a> = 25</td></tr>
<tr class="separator:a79c13f1f2147354ecb8a571fcd574408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff16693f5a52f869978a9a10d97e281"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aaff16693f5a52f869978a9a10d97e281">COLOR_BGRA2BGR555</a> = 26</td></tr>
<tr class="separator:aaff16693f5a52f869978a9a10d97e281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e03b0ddddc692dff748836948cade7d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e03b0ddddc692dff748836948cade7d">COLOR_RGBA2BGR555</a> = 27</td></tr>
<tr class="separator:a7e03b0ddddc692dff748836948cade7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847066523f4117614984b9da52e78f93"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a847066523f4117614984b9da52e78f93">COLOR_BGR5552BGRA</a> = 28</td></tr>
<tr class="separator:a847066523f4117614984b9da52e78f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89f492666502c1f6e7f85f38969bad"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9e89f492666502c1f6e7f85f38969bad">COLOR_BGR5552RGBA</a> = 29</td></tr>
<tr class="separator:a9e89f492666502c1f6e7f85f38969bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698bc51610d1c86504bfad4c7ad5464a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a698bc51610d1c86504bfad4c7ad5464a">COLOR_GRAY2BGR555</a> = 30</td></tr>
<tr class="separator:a698bc51610d1c86504bfad4c7ad5464a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c358b642f100a5e18032cd7af6ce256"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9c358b642f100a5e18032cd7af6ce256">COLOR_BGR5552GRAY</a> = 31</td></tr>
<tr class="separator:a9c358b642f100a5e18032cd7af6ce256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b7fab7aabbbaf657164fe2c10e4c6c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad1b7fab7aabbbaf657164fe2c10e4c6c">COLOR_BGR2XYZ</a> = 32</td></tr>
<tr class="separator:ad1b7fab7aabbbaf657164fe2c10e4c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d392f7656317e139bc129ed8ec0c34f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9d392f7656317e139bc129ed8ec0c34f">COLOR_RGB2XYZ</a> = 33</td></tr>
<tr class="separator:a9d392f7656317e139bc129ed8ec0c34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa324633335c87a3faaa1828315a30cc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aaa324633335c87a3faaa1828315a30cc">COLOR_XYZ2BGR</a> = 34</td></tr>
<tr class="separator:aaa324633335c87a3faaa1828315a30cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17928689f567520c4b0c47879feeb843"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a17928689f567520c4b0c47879feeb843">COLOR_XYZ2RGB</a> = 35</td></tr>
<tr class="separator:a17928689f567520c4b0c47879feeb843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c9dfcb6248acee5c047ee1f817eb31"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab6c9dfcb6248acee5c047ee1f817eb31">COLOR_BGR2YCrCb</a> = 36</td></tr>
<tr class="separator:ab6c9dfcb6248acee5c047ee1f817eb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa24e846619552902e77f5748da7482d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aaa24e846619552902e77f5748da7482d">COLOR_RGB2YCrCb</a> = 37</td></tr>
<tr class="separator:aaa24e846619552902e77f5748da7482d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c03b294f7560f06b0616ba35a900bc6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2c03b294f7560f06b0616ba35a900bc6">COLOR_YCrCb2BGR</a> = 38</td></tr>
<tr class="separator:a2c03b294f7560f06b0616ba35a900bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c5076d19572cc983f4f2021fa809e3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab4c5076d19572cc983f4f2021fa809e3">COLOR_YCrCb2RGB</a> = 39</td></tr>
<tr class="separator:ab4c5076d19572cc983f4f2021fa809e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a2a263703501e1b1c2c20a50c3ff0d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a75a2a263703501e1b1c2c20a50c3ff0d">COLOR_BGR2HSV</a> = 40</td></tr>
<tr class="separator:a75a2a263703501e1b1c2c20a50c3ff0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a51f721dfc036e6ba3e66320c0ab9e3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a51f721dfc036e6ba3e66320c0ab9e3">COLOR_RGB2HSV</a> = 41</td></tr>
<tr class="separator:a8a51f721dfc036e6ba3e66320c0ab9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75906aa1bf88138d0031577ee48523d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af75906aa1bf88138d0031577ee48523d">COLOR_BGR2Lab</a> = 44</td></tr>
<tr class="separator:af75906aa1bf88138d0031577ee48523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0639f2731bdb70cd1286be1e499e70"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a0639f2731bdb70cd1286be1e499e70">COLOR_RGB2Lab</a> = 45</td></tr>
<tr class="separator:a8a0639f2731bdb70cd1286be1e499e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7addf6028350cc90df58055485e526b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab7addf6028350cc90df58055485e526b">COLOR_BGR2Luv</a> = 50</td></tr>
<tr class="separator:ab7addf6028350cc90df58055485e526b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36bd22ac2ce91d0a94dfffb7a2b5576"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa36bd22ac2ce91d0a94dfffb7a2b5576">COLOR_RGB2Luv</a> = 51</td></tr>
<tr class="separator:aa36bd22ac2ce91d0a94dfffb7a2b5576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ae14e3c04fb1b80c755ba0ee93e6f2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a04ae14e3c04fb1b80c755ba0ee93e6f2">COLOR_BGR2HLS</a> = 52</td></tr>
<tr class="separator:a04ae14e3c04fb1b80c755ba0ee93e6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5c04c062e79742ad112a1d78d3e0ec"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aaa5c04c062e79742ad112a1d78d3e0ec">COLOR_RGB2HLS</a> = 53</td></tr>
<tr class="separator:aaa5c04c062e79742ad112a1d78d3e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3765f3b94790e1e9238c6f91c475b6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aab3765f3b94790e1e9238c6f91c475b6">COLOR_HSV2BGR</a> = 54</td></tr>
<tr class="separator:aab3765f3b94790e1e9238c6f91c475b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e355ca24bdcbf1e02314b717be5a34"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a55e355ca24bdcbf1e02314b717be5a34">COLOR_HSV2RGB</a> = 55</td></tr>
<tr class="separator:a55e355ca24bdcbf1e02314b717be5a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b58c9a46645bce79aabf635c2fdbfeb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7b58c9a46645bce79aabf635c2fdbfeb">COLOR_Lab2BGR</a> = 56</td></tr>
<tr class="separator:a7b58c9a46645bce79aabf635c2fdbfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88682acb75083d8c95ec198ce040251"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae88682acb75083d8c95ec198ce040251">COLOR_Lab2RGB</a> = 57</td></tr>
<tr class="separator:ae88682acb75083d8c95ec198ce040251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcec239143bcd04afb097ce2cdc449d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7bcec239143bcd04afb097ce2cdc449d">COLOR_Luv2BGR</a> = 58</td></tr>
<tr class="separator:a7bcec239143bcd04afb097ce2cdc449d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791ec36b656d188a822fac67aaf55fe"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5791ec36b656d188a822fac67aaf55fe">COLOR_Luv2RGB</a> = 59</td></tr>
<tr class="separator:a5791ec36b656d188a822fac67aaf55fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6639937f498bf2dd083772623b8f908"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad6639937f498bf2dd083772623b8f908">COLOR_HLS2BGR</a> = 60</td></tr>
<tr class="separator:ad6639937f498bf2dd083772623b8f908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629b69a4f3c3d9e571236d6f02839f40"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a629b69a4f3c3d9e571236d6f02839f40">COLOR_HLS2RGB</a> = 61</td></tr>
<tr class="separator:a629b69a4f3c3d9e571236d6f02839f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dcfd1a9504ffc0c12a33f970930f73"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08dcfd1a9504ffc0c12a33f970930f73">COLOR_BGR2HSV_FULL</a> = 66</td></tr>
<tr class="separator:a08dcfd1a9504ffc0c12a33f970930f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761584602d331fb8fe4cea1baeb655bd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a761584602d331fb8fe4cea1baeb655bd">COLOR_RGB2HSV_FULL</a> = 67</td></tr>
<tr class="separator:a761584602d331fb8fe4cea1baeb655bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7c62a6c19ffb58fb73e5fcadac6ab7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3e7c62a6c19ffb58fb73e5fcadac6ab7">COLOR_BGR2HLS_FULL</a> = 68</td></tr>
<tr class="separator:a3e7c62a6c19ffb58fb73e5fcadac6ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498aabaf86914ee51b7f8060f1f6920e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a498aabaf86914ee51b7f8060f1f6920e">COLOR_RGB2HLS_FULL</a> = 69</td></tr>
<tr class="separator:a498aabaf86914ee51b7f8060f1f6920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074ec49b2bf764531ed8b28721bdac4c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a074ec49b2bf764531ed8b28721bdac4c">COLOR_HSV2BGR_FULL</a> = 70</td></tr>
<tr class="separator:a074ec49b2bf764531ed8b28721bdac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e25e45b888044ee8fefd99875725833"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5e25e45b888044ee8fefd99875725833">COLOR_HSV2RGB_FULL</a> = 71</td></tr>
<tr class="separator:a5e25e45b888044ee8fefd99875725833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3b67c3562b0bf10fd7513e12ec91ed"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a3b67c3562b0bf10fd7513e12ec91ed">COLOR_HLS2BGR_FULL</a> = 72</td></tr>
<tr class="separator:a8a3b67c3562b0bf10fd7513e12ec91ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88eef1c8ac525082e7a0e7dd636e562"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab88eef1c8ac525082e7a0e7dd636e562">COLOR_HLS2RGB_FULL</a> = 73</td></tr>
<tr class="separator:ab88eef1c8ac525082e7a0e7dd636e562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52fcb138109b02513f39928b133201c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad52fcb138109b02513f39928b133201c">COLOR_LBGR2Lab</a> = 74</td></tr>
<tr class="separator:ad52fcb138109b02513f39928b133201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59324f32f4c7bdb89ff65463b2b565a2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a59324f32f4c7bdb89ff65463b2b565a2">COLOR_LRGB2Lab</a> = 75</td></tr>
<tr class="separator:a59324f32f4c7bdb89ff65463b2b565a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f4da92563208c9e856d927baefe9e8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a90f4da92563208c9e856d927baefe9e8">COLOR_LBGR2Luv</a> = 76</td></tr>
<tr class="separator:a90f4da92563208c9e856d927baefe9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7052252d1a08703d5ed2a552a96d869"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad7052252d1a08703d5ed2a552a96d869">COLOR_LRGB2Luv</a> = 77</td></tr>
<tr class="separator:ad7052252d1a08703d5ed2a552a96d869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175bfc7d56cf7e2651049e348f8885d3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a175bfc7d56cf7e2651049e348f8885d3">COLOR_Lab2LBGR</a> = 78</td></tr>
<tr class="separator:a175bfc7d56cf7e2651049e348f8885d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad4d58d8e0d3e61b50b4519ac8f8d3a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2ad4d58d8e0d3e61b50b4519ac8f8d3a">COLOR_Lab2LRGB</a> = 79</td></tr>
<tr class="separator:a2ad4d58d8e0d3e61b50b4519ac8f8d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc519862f77c949c4283b42524bdbf0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abcc519862f77c949c4283b42524bdbf0">COLOR_Luv2LBGR</a> = 80</td></tr>
<tr class="separator:abcc519862f77c949c4283b42524bdbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee823353a0af0845d24bd0b27f0c37ae"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aee823353a0af0845d24bd0b27f0c37ae">COLOR_Luv2LRGB</a> = 81</td></tr>
<tr class="separator:aee823353a0af0845d24bd0b27f0c37ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca71c1a80c48be2dbac774a11a9dd80"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acca71c1a80c48be2dbac774a11a9dd80">COLOR_BGR2YUV</a> = 82</td></tr>
<tr class="separator:acca71c1a80c48be2dbac774a11a9dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57f5b69b83a58e7bcfe56717a986541"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac57f5b69b83a58e7bcfe56717a986541">COLOR_RGB2YUV</a> = 83</td></tr>
<tr class="separator:ac57f5b69b83a58e7bcfe56717a986541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab628e9f1d2a6d699380c06baebb0c19d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab628e9f1d2a6d699380c06baebb0c19d">COLOR_YUV2BGR</a> = 84</td></tr>
<tr class="separator:ab628e9f1d2a6d699380c06baebb0c19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509378fbaede245f0543760cd03e10b9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a509378fbaede245f0543760cd03e10b9">COLOR_YUV2RGB</a> = 85</td></tr>
<tr class="separator:a509378fbaede245f0543760cd03e10b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe1e59f1952e60d8318013b75ddd70a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6fe1e59f1952e60d8318013b75ddd70a">COLOR_YUV2RGB_NV12</a> = 90</td></tr>
<tr class="separator:a6fe1e59f1952e60d8318013b75ddd70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6052068d3a23fe539b125c621625dc3b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6052068d3a23fe539b125c621625dc3b">COLOR_YUV2BGR_NV12</a> = 91</td></tr>
<tr class="separator:a6052068d3a23fe539b125c621625dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af931b245acb983ace37bdecd6b9d036a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af931b245acb983ace37bdecd6b9d036a">COLOR_YUV2RGB_NV21</a> = 92</td></tr>
<tr class="separator:af931b245acb983ace37bdecd6b9d036a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad006f0f6c1c38ad4bbb0d13979aaddcc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad006f0f6c1c38ad4bbb0d13979aaddcc">COLOR_YUV2BGR_NV21</a> = 93</td></tr>
<tr class="separator:ad006f0f6c1c38ad4bbb0d13979aaddcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa253114d84795fbcf194141f24ce37e7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa253114d84795fbcf194141f24ce37e7">COLOR_YUV420sp2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af931b245acb983ace37bdecd6b9d036a">COLOR_YUV2RGB_NV21</a></td></tr>
<tr class="separator:aa253114d84795fbcf194141f24ce37e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9dfd8ec85dd3264e0c85c12243c7a8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aed9dfd8ec85dd3264e0c85c12243c7a8">COLOR_YUV420sp2BGR</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad006f0f6c1c38ad4bbb0d13979aaddcc">COLOR_YUV2BGR_NV21</a></td></tr>
<tr class="separator:aed9dfd8ec85dd3264e0c85c12243c7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da07108887c111ebdab4f2a643e874b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8da07108887c111ebdab4f2a643e874b">COLOR_YUV2RGBA_NV12</a> = 94</td></tr>
<tr class="separator:a8da07108887c111ebdab4f2a643e874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714d5a4820517a9e0a55d6eb9c5bef82"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a714d5a4820517a9e0a55d6eb9c5bef82">COLOR_YUV2BGRA_NV12</a> = 95</td></tr>
<tr class="separator:a714d5a4820517a9e0a55d6eb9c5bef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ee5d8a713ea844b27f4e6d924830e2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab6ee5d8a713ea844b27f4e6d924830e2">COLOR_YUV2RGBA_NV21</a> = 96</td></tr>
<tr class="separator:ab6ee5d8a713ea844b27f4e6d924830e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6d9728436a595824c4fc203bab2bdb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9c6d9728436a595824c4fc203bab2bdb">COLOR_YUV2BGRA_NV21</a> = 97</td></tr>
<tr class="separator:a9c6d9728436a595824c4fc203bab2bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb935b042a19ee10b0bc1cd47fc696f8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abb935b042a19ee10b0bc1cd47fc696f8">COLOR_YUV420sp2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab6ee5d8a713ea844b27f4e6d924830e2">COLOR_YUV2RGBA_NV21</a></td></tr>
<tr class="separator:abb935b042a19ee10b0bc1cd47fc696f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa497937f98d289dbff48ea4c93a2da95"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa497937f98d289dbff48ea4c93a2da95">COLOR_YUV420sp2BGRA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9c6d9728436a595824c4fc203bab2bdb">COLOR_YUV2BGRA_NV21</a></td></tr>
<tr class="separator:aa497937f98d289dbff48ea4c93a2da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad514386c338632f41e71de13beec3eb2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad514386c338632f41e71de13beec3eb2">COLOR_YUV2RGB_YV12</a> = 98</td></tr>
<tr class="separator:ad514386c338632f41e71de13beec3eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9db259000fefcc999a11c18ec77d0fe"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af9db259000fefcc999a11c18ec77d0fe">COLOR_YUV2BGR_YV12</a> = 99</td></tr>
<tr class="separator:af9db259000fefcc999a11c18ec77d0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8484b36f2e203a57bf948fe8645443e6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8484b36f2e203a57bf948fe8645443e6">COLOR_YUV2RGB_IYUV</a> = 100</td></tr>
<tr class="separator:a8484b36f2e203a57bf948fe8645443e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaa77c08db40d971caac3256fc1687a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1eaa77c08db40d971caac3256fc1687a">COLOR_YUV2BGR_IYUV</a> = 101</td></tr>
<tr class="separator:a1eaa77c08db40d971caac3256fc1687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff1d690cf571ecafd8c13cf2eb2adbe"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abff1d690cf571ecafd8c13cf2eb2adbe">COLOR_YUV2RGB_I420</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8484b36f2e203a57bf948fe8645443e6">COLOR_YUV2RGB_IYUV</a></td></tr>
<tr class="separator:abff1d690cf571ecafd8c13cf2eb2adbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214ace3bcaaaa3b32e63a2dcc634ddfa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a214ace3bcaaaa3b32e63a2dcc634ddfa">COLOR_YUV2BGR_I420</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1eaa77c08db40d971caac3256fc1687a">COLOR_YUV2BGR_IYUV</a></td></tr>
<tr class="separator:a214ace3bcaaaa3b32e63a2dcc634ddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae172c922f993652cb9bc72d8af32300f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae172c922f993652cb9bc72d8af32300f">COLOR_YUV420p2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad514386c338632f41e71de13beec3eb2">COLOR_YUV2RGB_YV12</a></td></tr>
<tr class="separator:ae172c922f993652cb9bc72d8af32300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7a7fa1f2f3e6467a85a59001a3b7a2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f7a7fa1f2f3e6467a85a59001a3b7a2">COLOR_YUV420p2BGR</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af9db259000fefcc999a11c18ec77d0fe">COLOR_YUV2BGR_YV12</a></td></tr>
<tr class="separator:a0f7a7fa1f2f3e6467a85a59001a3b7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6d947b1a255ce0bca9e395016a4c5a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7f6d947b1a255ce0bca9e395016a4c5a">COLOR_YUV2RGBA_YV12</a> = 102</td></tr>
<tr class="separator:a7f6d947b1a255ce0bca9e395016a4c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280e49359bbdc3425a0b978a26645856"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a280e49359bbdc3425a0b978a26645856">COLOR_YUV2BGRA_YV12</a> = 103</td></tr>
<tr class="separator:a280e49359bbdc3425a0b978a26645856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb2146fa1f128e5f6dcd729bb25d27"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa6bb2146fa1f128e5f6dcd729bb25d27">COLOR_YUV2RGBA_IYUV</a> = 104</td></tr>
<tr class="separator:aa6bb2146fa1f128e5f6dcd729bb25d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13bde4178ba33ad07277d6307d139ab"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af13bde4178ba33ad07277d6307d139ab">COLOR_YUV2BGRA_IYUV</a> = 105</td></tr>
<tr class="separator:af13bde4178ba33ad07277d6307d139ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36fe284acda8dd90a97d993b5dab23a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac36fe284acda8dd90a97d993b5dab23a">COLOR_YUV2RGBA_I420</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa6bb2146fa1f128e5f6dcd729bb25d27">COLOR_YUV2RGBA_IYUV</a></td></tr>
<tr class="separator:ac36fe284acda8dd90a97d993b5dab23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9131ad647a8482ec49c5018602a0098d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9131ad647a8482ec49c5018602a0098d">COLOR_YUV2BGRA_I420</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af13bde4178ba33ad07277d6307d139ab">COLOR_YUV2BGRA_IYUV</a></td></tr>
<tr class="separator:a9131ad647a8482ec49c5018602a0098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438647d0ac55fe2fe85b0fb9c93299a8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a438647d0ac55fe2fe85b0fb9c93299a8">COLOR_YUV420p2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7f6d947b1a255ce0bca9e395016a4c5a">COLOR_YUV2RGBA_YV12</a></td></tr>
<tr class="separator:a438647d0ac55fe2fe85b0fb9c93299a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b1a6bad97999b9d48c1104352b1a0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad28b1a6bad97999b9d48c1104352b1a0">COLOR_YUV420p2BGRA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a280e49359bbdc3425a0b978a26645856">COLOR_YUV2BGRA_YV12</a></td></tr>
<tr class="separator:ad28b1a6bad97999b9d48c1104352b1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34530c983fa371e744a08ba8a3a607f1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a> = 106</td></tr>
<tr class="separator:a34530c983fa371e744a08ba8a3a607f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7527676cc1740235cdbb120e763b4011"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7527676cc1740235cdbb120e763b4011">COLOR_YUV2GRAY_NV21</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td></tr>
<tr class="separator:a7527676cc1740235cdbb120e763b4011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fcc2a92fb0db759f88859ce6c6050f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5fcc2a92fb0db759f88859ce6c6050f">COLOR_YUV2GRAY_NV12</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td></tr>
<tr class="separator:ab5fcc2a92fb0db759f88859ce6c6050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe21052765136d9722d43793b54d3fd7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#afe21052765136d9722d43793b54d3fd7">COLOR_YUV2GRAY_YV12</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td></tr>
<tr class="separator:afe21052765136d9722d43793b54d3fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bae06d7bc5f71893c80783acf91f6d9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bae06d7bc5f71893c80783acf91f6d9">COLOR_YUV2GRAY_IYUV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td></tr>
<tr class="separator:a4bae06d7bc5f71893c80783acf91f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bc50ef0e5cace2eea7e6c9de56b1ae"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a33bc50ef0e5cace2eea7e6c9de56b1ae">COLOR_YUV2GRAY_I420</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td></tr>
<tr class="separator:a33bc50ef0e5cace2eea7e6c9de56b1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb103452e718ef621397b6fd06e35607"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adb103452e718ef621397b6fd06e35607">COLOR_YUV420sp2GRAY</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td></tr>
<tr class="separator:adb103452e718ef621397b6fd06e35607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde254de83d738d672736f9fb11a1782"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acde254de83d738d672736f9fb11a1782">COLOR_YUV420p2GRAY</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td></tr>
<tr class="separator:acde254de83d738d672736f9fb11a1782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31499d871eb3ca2a8d2aed08844ef38d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a31499d871eb3ca2a8d2aed08844ef38d">COLOR_YUV2RGB_UYVY</a> = 107</td></tr>
<tr class="separator:a31499d871eb3ca2a8d2aed08844ef38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf84938e0e64e9e7757be31053fefdb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adcf84938e0e64e9e7757be31053fefdb">COLOR_YUV2BGR_UYVY</a> = 108</td></tr>
<tr class="separator:adcf84938e0e64e9e7757be31053fefdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d798c93ed0646db37d2f8dc4ae7ef8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a16d798c93ed0646db37d2f8dc4ae7ef8">COLOR_YUV2RGB_Y422</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a31499d871eb3ca2a8d2aed08844ef38d">COLOR_YUV2RGB_UYVY</a></td></tr>
<tr class="separator:a16d798c93ed0646db37d2f8dc4ae7ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1a98aa93bf3bb6b5420d03be2d92ce"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abf1a98aa93bf3bb6b5420d03be2d92ce">COLOR_YUV2BGR_Y422</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adcf84938e0e64e9e7757be31053fefdb">COLOR_YUV2BGR_UYVY</a></td></tr>
<tr class="separator:abf1a98aa93bf3bb6b5420d03be2d92ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f64ae4fd0d81cae6d9f2f68071e7f6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a62f64ae4fd0d81cae6d9f2f68071e7f6">COLOR_YUV2RGB_UYNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a31499d871eb3ca2a8d2aed08844ef38d">COLOR_YUV2RGB_UYVY</a></td></tr>
<tr class="separator:a62f64ae4fd0d81cae6d9f2f68071e7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b5b9d46619cc68f6097b9b06cc6b9b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a94b5b9d46619cc68f6097b9b06cc6b9b">COLOR_YUV2BGR_UYNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adcf84938e0e64e9e7757be31053fefdb">COLOR_YUV2BGR_UYVY</a></td></tr>
<tr class="separator:a94b5b9d46619cc68f6097b9b06cc6b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7db73e8112a99da14de20ae9efed9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aebd7db73e8112a99da14de20ae9efed9">COLOR_YUV2RGBA_UYVY</a> = 111</td></tr>
<tr class="separator:aebd7db73e8112a99da14de20ae9efed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc7fc56671a5133beda501ec64c5e9d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9fc7fc56671a5133beda501ec64c5e9d">COLOR_YUV2BGRA_UYVY</a> = 112</td></tr>
<tr class="separator:a9fc7fc56671a5133beda501ec64c5e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6481c39de8de018aef034f91d021775"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af6481c39de8de018aef034f91d021775">COLOR_YUV2RGBA_Y422</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aebd7db73e8112a99da14de20ae9efed9">COLOR_YUV2RGBA_UYVY</a></td></tr>
<tr class="separator:af6481c39de8de018aef034f91d021775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34252246bf4469043581b3e32526ac2f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34252246bf4469043581b3e32526ac2f">COLOR_YUV2BGRA_Y422</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9fc7fc56671a5133beda501ec64c5e9d">COLOR_YUV2BGRA_UYVY</a></td></tr>
<tr class="separator:a34252246bf4469043581b3e32526ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61fd136a2f3d718e33b976c4f4f9082"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab61fd136a2f3d718e33b976c4f4f9082">COLOR_YUV2RGBA_UYNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aebd7db73e8112a99da14de20ae9efed9">COLOR_YUV2RGBA_UYVY</a></td></tr>
<tr class="separator:ab61fd136a2f3d718e33b976c4f4f9082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae3aee438c939255b2870642b98d90d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acae3aee438c939255b2870642b98d90d">COLOR_YUV2BGRA_UYNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9fc7fc56671a5133beda501ec64c5e9d">COLOR_YUV2BGRA_UYVY</a></td></tr>
<tr class="separator:acae3aee438c939255b2870642b98d90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fb2dfead28661e783340053a005dfa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5fb2dfead28661e783340053a005dfa">COLOR_YUV2RGB_YUY2</a> = 115</td></tr>
<tr class="separator:ab5fb2dfead28661e783340053a005dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8dc18504a7f178e4e024e97a9a8ee"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4ec8dc18504a7f178e4e024e97a9a8ee">COLOR_YUV2BGR_YUY2</a> = 116</td></tr>
<tr class="separator:a4ec8dc18504a7f178e4e024e97a9a8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac08d92249e566924b86cda8fbfbb51"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5ac08d92249e566924b86cda8fbfbb51">COLOR_YUV2RGB_YVYU</a> = 117</td></tr>
<tr class="separator:a5ac08d92249e566924b86cda8fbfbb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b97a7d0d69f73115a709076f60bc5c2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5b97a7d0d69f73115a709076f60bc5c2">COLOR_YUV2BGR_YVYU</a> = 118</td></tr>
<tr class="separator:a5b97a7d0d69f73115a709076f60bc5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fabcc33793182d7c8717618b445ef31"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0fabcc33793182d7c8717618b445ef31">COLOR_YUV2RGB_YUYV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5fb2dfead28661e783340053a005dfa">COLOR_YUV2RGB_YUY2</a></td></tr>
<tr class="separator:a0fabcc33793182d7c8717618b445ef31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545bed04b92cf21b36dffe5a77445e89"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a545bed04b92cf21b36dffe5a77445e89">COLOR_YUV2BGR_YUYV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4ec8dc18504a7f178e4e024e97a9a8ee">COLOR_YUV2BGR_YUY2</a></td></tr>
<tr class="separator:a545bed04b92cf21b36dffe5a77445e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c2468fb714b789568006d44eb2e570"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a96c2468fb714b789568006d44eb2e570">COLOR_YUV2RGB_YUNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5fb2dfead28661e783340053a005dfa">COLOR_YUV2RGB_YUY2</a></td></tr>
<tr class="separator:a96c2468fb714b789568006d44eb2e570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c6afd48e0df3d8cdd6a9ebd6e0da90"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab7c6afd48e0df3d8cdd6a9ebd6e0da90">COLOR_YUV2BGR_YUNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4ec8dc18504a7f178e4e024e97a9a8ee">COLOR_YUV2BGR_YUY2</a></td></tr>
<tr class="separator:ab7c6afd48e0df3d8cdd6a9ebd6e0da90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e915755240549a4f5c5b0e557fe342f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2e915755240549a4f5c5b0e557fe342f">COLOR_YUV2RGBA_YUY2</a> = 119</td></tr>
<tr class="separator:a2e915755240549a4f5c5b0e557fe342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25c23cda2f9a71c1e55f171c2d762f5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae25c23cda2f9a71c1e55f171c2d762f5">COLOR_YUV2BGRA_YUY2</a> = 120</td></tr>
<tr class="separator:ae25c23cda2f9a71c1e55f171c2d762f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32b87c9acd17de56d25f6fffce760ad"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab32b87c9acd17de56d25f6fffce760ad">COLOR_YUV2RGBA_YVYU</a> = 121</td></tr>
<tr class="separator:ab32b87c9acd17de56d25f6fffce760ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1127d9e657eebc2880cee15649abf2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5e1127d9e657eebc2880cee15649abf2">COLOR_YUV2BGRA_YVYU</a> = 122</td></tr>
<tr class="separator:a5e1127d9e657eebc2880cee15649abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5884e72a1b97d2b28bd611aae090a128"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5884e72a1b97d2b28bd611aae090a128">COLOR_YUV2RGBA_YUYV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2e915755240549a4f5c5b0e557fe342f">COLOR_YUV2RGBA_YUY2</a></td></tr>
<tr class="separator:a5884e72a1b97d2b28bd611aae090a128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab1afc43f94dbf48c3b808afee833da"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6ab1afc43f94dbf48c3b808afee833da">COLOR_YUV2BGRA_YUYV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae25c23cda2f9a71c1e55f171c2d762f5">COLOR_YUV2BGRA_YUY2</a></td></tr>
<tr class="separator:a6ab1afc43f94dbf48c3b808afee833da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5667827f6f329befabdfaafcb7e1fa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9b5667827f6f329befabdfaafcb7e1fa">COLOR_YUV2RGBA_YUNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2e915755240549a4f5c5b0e557fe342f">COLOR_YUV2RGBA_YUY2</a></td></tr>
<tr class="separator:a9b5667827f6f329befabdfaafcb7e1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae6ffa435eff0189a21df9a87b10de1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1ae6ffa435eff0189a21df9a87b10de1">COLOR_YUV2BGRA_YUNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae25c23cda2f9a71c1e55f171c2d762f5">COLOR_YUV2BGRA_YUY2</a></td></tr>
<tr class="separator:a1ae6ffa435eff0189a21df9a87b10de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc58d75620925938003c78a0b846c628"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adc58d75620925938003c78a0b846c628">COLOR_YUV2GRAY_UYVY</a> = 123</td></tr>
<tr class="separator:adc58d75620925938003c78a0b846c628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66082846d7c9a9326e20e6cbf7f8d92"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa66082846d7c9a9326e20e6cbf7f8d92">COLOR_YUV2GRAY_YUY2</a> = 124</td></tr>
<tr class="separator:aa66082846d7c9a9326e20e6cbf7f8d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5be6700ef5b4969803a910dfa96b083"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af5be6700ef5b4969803a910dfa96b083">COLOR_YUV2GRAY_Y422</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adc58d75620925938003c78a0b846c628">COLOR_YUV2GRAY_UYVY</a></td></tr>
<tr class="separator:af5be6700ef5b4969803a910dfa96b083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632b2ccfeddc2e6f4565d2ff52fd3463"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a632b2ccfeddc2e6f4565d2ff52fd3463">COLOR_YUV2GRAY_UYNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adc58d75620925938003c78a0b846c628">COLOR_YUV2GRAY_UYVY</a></td></tr>
<tr class="separator:a632b2ccfeddc2e6f4565d2ff52fd3463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aeca649e7f7f2c53b468d08e246838"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a77aeca649e7f7f2c53b468d08e246838">COLOR_YUV2GRAY_YVYU</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa66082846d7c9a9326e20e6cbf7f8d92">COLOR_YUV2GRAY_YUY2</a></td></tr>
<tr class="separator:a77aeca649e7f7f2c53b468d08e246838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587681a1ff2c842fb6958fa91da1b61c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a587681a1ff2c842fb6958fa91da1b61c">COLOR_YUV2GRAY_YUYV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa66082846d7c9a9326e20e6cbf7f8d92">COLOR_YUV2GRAY_YUY2</a></td></tr>
<tr class="separator:a587681a1ff2c842fb6958fa91da1b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b37db5c1d3935cb8adfefff5d4d163e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8b37db5c1d3935cb8adfefff5d4d163e">COLOR_YUV2GRAY_YUNV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa66082846d7c9a9326e20e6cbf7f8d92">COLOR_YUV2GRAY_YUY2</a></td></tr>
<tr class="separator:a8b37db5c1d3935cb8adfefff5d4d163e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab43ec0a553cd2fdec1aa26eac5ce31c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aab43ec0a553cd2fdec1aa26eac5ce31c">COLOR_RGBA2mRGBA</a> = 125</td></tr>
<tr class="separator:aab43ec0a553cd2fdec1aa26eac5ce31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278d827701793a2ef5ed773f9cbbe13a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a278d827701793a2ef5ed773f9cbbe13a">COLOR_mRGBA2RGBA</a> = 126</td></tr>
<tr class="separator:a278d827701793a2ef5ed773f9cbbe13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af89531576863f7ea636f06ccd8d873"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9af89531576863f7ea636f06ccd8d873">COLOR_RGB2YUV_I420</a> = 127</td></tr>
<tr class="separator:a9af89531576863f7ea636f06ccd8d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3c90be838a4b3addcc4ea8e399deb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a43e3c90be838a4b3addcc4ea8e399deb">COLOR_BGR2YUV_I420</a> = 128</td></tr>
<tr class="separator:a43e3c90be838a4b3addcc4ea8e399deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415315859cc86e6f1d9f682ac3010dd3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a415315859cc86e6f1d9f682ac3010dd3">COLOR_RGB2YUV_IYUV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9af89531576863f7ea636f06ccd8d873">COLOR_RGB2YUV_I420</a></td></tr>
<tr class="separator:a415315859cc86e6f1d9f682ac3010dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef650a98f06470811e95e20b8b404f7c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aef650a98f06470811e95e20b8b404f7c">COLOR_BGR2YUV_IYUV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a43e3c90be838a4b3addcc4ea8e399deb">COLOR_BGR2YUV_I420</a></td></tr>
<tr class="separator:aef650a98f06470811e95e20b8b404f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f467b97ad4eb1e2401c027e6a85563c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5f467b97ad4eb1e2401c027e6a85563c">COLOR_RGBA2YUV_I420</a> = 129</td></tr>
<tr class="separator:a5f467b97ad4eb1e2401c027e6a85563c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dab20dbb4e9f09df3dee314a8235a2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0dab20dbb4e9f09df3dee314a8235a2">COLOR_BGRA2YUV_I420</a> = 130</td></tr>
<tr class="separator:ae0dab20dbb4e9f09df3dee314a8235a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02394858448d272eab8a9ab199224742"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a02394858448d272eab8a9ab199224742">COLOR_RGBA2YUV_IYUV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5f467b97ad4eb1e2401c027e6a85563c">COLOR_RGBA2YUV_I420</a></td></tr>
<tr class="separator:a02394858448d272eab8a9ab199224742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caea108c87f17cdfef51e932c912e33"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2caea108c87f17cdfef51e932c912e33">COLOR_BGRA2YUV_IYUV</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0dab20dbb4e9f09df3dee314a8235a2">COLOR_BGRA2YUV_I420</a></td></tr>
<tr class="separator:a2caea108c87f17cdfef51e932c912e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a558c99e1660a5253b2539c55356aa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad7a558c99e1660a5253b2539c55356aa">COLOR_RGB2YUV_YV12</a> = 131</td></tr>
<tr class="separator:ad7a558c99e1660a5253b2539c55356aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6b6dad7e0617d7f80af3225bf8bd4f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f6b6dad7e0617d7f80af3225bf8bd4f">COLOR_BGR2YUV_YV12</a> = 132</td></tr>
<tr class="separator:a0f6b6dad7e0617d7f80af3225bf8bd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a2f4f768b11831bf2e87ea73b55a92"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a94a2f4f768b11831bf2e87ea73b55a92">COLOR_RGBA2YUV_YV12</a> = 133</td></tr>
<tr class="separator:a94a2f4f768b11831bf2e87ea73b55a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31e0e905ca8852151881576f5f69401"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad31e0e905ca8852151881576f5f69401">COLOR_BGRA2YUV_YV12</a> = 134</td></tr>
<tr class="separator:ad31e0e905ca8852151881576f5f69401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00455e4dd6ed254c5cd1ed192d2cb251"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a00455e4dd6ed254c5cd1ed192d2cb251">COLOR_BayerBG2BGR</a> = 46</td></tr>
<tr class="separator:a00455e4dd6ed254c5cd1ed192d2cb251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640bc9c494d309897aea3313b6e30d5c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a640bc9c494d309897aea3313b6e30d5c">COLOR_BayerGB2BGR</a> = 47</td></tr>
<tr class="separator:a640bc9c494d309897aea3313b6e30d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac938efbf5a272685313cfba5f36b128"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aac938efbf5a272685313cfba5f36b128">COLOR_BayerRG2BGR</a> = 48</td></tr>
<tr class="separator:aac938efbf5a272685313cfba5f36b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5cf921fe1c7c068eeb94bb338f7de5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ade5cf921fe1c7c068eeb94bb338f7de5">COLOR_BayerGR2BGR</a> = 49</td></tr>
<tr class="separator:ade5cf921fe1c7c068eeb94bb338f7de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b91f2092febbb98acbb2dcd545f9c90"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9b91f2092febbb98acbb2dcd545f9c90">COLOR_BayerBG2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aac938efbf5a272685313cfba5f36b128">COLOR_BayerRG2BGR</a></td></tr>
<tr class="separator:a9b91f2092febbb98acbb2dcd545f9c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d493ad5d017d13765364b1bd85625b7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8d493ad5d017d13765364b1bd85625b7">COLOR_BayerGB2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ade5cf921fe1c7c068eeb94bb338f7de5">COLOR_BayerGR2BGR</a></td></tr>
<tr class="separator:a8d493ad5d017d13765364b1bd85625b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08796489bb301a56fadf9d20c90deea6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08796489bb301a56fadf9d20c90deea6">COLOR_BayerRG2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a00455e4dd6ed254c5cd1ed192d2cb251">COLOR_BayerBG2BGR</a></td></tr>
<tr class="separator:a08796489bb301a56fadf9d20c90deea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1044e6a0769a88d66353e38885263e15"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1044e6a0769a88d66353e38885263e15">COLOR_BayerGR2RGB</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a640bc9c494d309897aea3313b6e30d5c">COLOR_BayerGB2BGR</a></td></tr>
<tr class="separator:a1044e6a0769a88d66353e38885263e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2789575f260d7c778971e5d70b987f70"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2789575f260d7c778971e5d70b987f70">COLOR_BayerBG2GRAY</a> = 86</td></tr>
<tr class="separator:a2789575f260d7c778971e5d70b987f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacec19fcf81bd927b4e0d9fad73de7e4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aacec19fcf81bd927b4e0d9fad73de7e4">COLOR_BayerGB2GRAY</a> = 87</td></tr>
<tr class="separator:aacec19fcf81bd927b4e0d9fad73de7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20617e3ea282bc30eb43c2f1f289df45"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a20617e3ea282bc30eb43c2f1f289df45">COLOR_BayerRG2GRAY</a> = 88</td></tr>
<tr class="separator:a20617e3ea282bc30eb43c2f1f289df45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261eb729f702770ff1fb469df65851f2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a261eb729f702770ff1fb469df65851f2">COLOR_BayerGR2GRAY</a> = 89</td></tr>
<tr class="separator:a261eb729f702770ff1fb469df65851f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa695747e7048fa7dbb3cff1be6cfdc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7fa695747e7048fa7dbb3cff1be6cfdc">COLOR_BayerBG2BGR_VNG</a> = 62</td></tr>
<tr class="separator:a7fa695747e7048fa7dbb3cff1be6cfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56f16ded2575b412e0b8b094bb77a74"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad56f16ded2575b412e0b8b094bb77a74">COLOR_BayerGB2BGR_VNG</a> = 63</td></tr>
<tr class="separator:ad56f16ded2575b412e0b8b094bb77a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03957ef64cdc0c120c72bf1cfb4a09e8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a03957ef64cdc0c120c72bf1cfb4a09e8">COLOR_BayerRG2BGR_VNG</a> = 64</td></tr>
<tr class="separator:a03957ef64cdc0c120c72bf1cfb4a09e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afd65cf67f7c86f3b5b05c3166af40b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7afd65cf67f7c86f3b5b05c3166af40b">COLOR_BayerGR2BGR_VNG</a> = 65</td></tr>
<tr class="separator:a7afd65cf67f7c86f3b5b05c3166af40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f212e0107a355ca8c444424265a932"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a22f212e0107a355ca8c444424265a932">COLOR_BayerBG2RGB_VNG</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a03957ef64cdc0c120c72bf1cfb4a09e8">COLOR_BayerRG2BGR_VNG</a></td></tr>
<tr class="separator:a22f212e0107a355ca8c444424265a932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1d5c8aa7bdcd835f6efb7affae247a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ace1d5c8aa7bdcd835f6efb7affae247a">COLOR_BayerGB2RGB_VNG</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7afd65cf67f7c86f3b5b05c3166af40b">COLOR_BayerGR2BGR_VNG</a></td></tr>
<tr class="separator:ace1d5c8aa7bdcd835f6efb7affae247a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d76310ba75e85c5be7e240caf05efa"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a56d76310ba75e85c5be7e240caf05efa">COLOR_BayerRG2RGB_VNG</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7fa695747e7048fa7dbb3cff1be6cfdc">COLOR_BayerBG2BGR_VNG</a></td></tr>
<tr class="separator:a56d76310ba75e85c5be7e240caf05efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ec997885f7fbba32625690fd207241"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac2ec997885f7fbba32625690fd207241">COLOR_BayerGR2RGB_VNG</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad56f16ded2575b412e0b8b094bb77a74">COLOR_BayerGB2BGR_VNG</a></td></tr>
<tr class="separator:ac2ec997885f7fbba32625690fd207241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580985395bc98c8517eabaa43293584e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a580985395bc98c8517eabaa43293584e">COLOR_BayerBG2BGR_EA</a> = 135</td></tr>
<tr class="separator:a580985395bc98c8517eabaa43293584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbee19d4cd4672c9b6988516e7850bb0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acbee19d4cd4672c9b6988516e7850bb0">COLOR_BayerGB2BGR_EA</a> = 136</td></tr>
<tr class="separator:acbee19d4cd4672c9b6988516e7850bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918cf15595fa340f586e3ad3e88f01d2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a918cf15595fa340f586e3ad3e88f01d2">COLOR_BayerRG2BGR_EA</a> = 137</td></tr>
<tr class="separator:a918cf15595fa340f586e3ad3e88f01d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57ed966fae2eec59a838a370dc82c5e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa57ed966fae2eec59a838a370dc82c5e">COLOR_BayerGR2BGR_EA</a> = 138</td></tr>
<tr class="separator:aa57ed966fae2eec59a838a370dc82c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149212dcd23d64b1044df92884948103"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a149212dcd23d64b1044df92884948103">COLOR_BayerBG2RGB_EA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a918cf15595fa340f586e3ad3e88f01d2">COLOR_BayerRG2BGR_EA</a></td></tr>
<tr class="separator:a149212dcd23d64b1044df92884948103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4cc6138e73f880dcf6ad20bfc66713"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3a4cc6138e73f880dcf6ad20bfc66713">COLOR_BayerGB2RGB_EA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa57ed966fae2eec59a838a370dc82c5e">COLOR_BayerGR2BGR_EA</a></td></tr>
<tr class="separator:a3a4cc6138e73f880dcf6ad20bfc66713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c635c4bbe115b84a6ce17e34e6cd8e4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8c635c4bbe115b84a6ce17e34e6cd8e4">COLOR_BayerRG2RGB_EA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a580985395bc98c8517eabaa43293584e">COLOR_BayerBG2BGR_EA</a></td></tr>
<tr class="separator:a8c635c4bbe115b84a6ce17e34e6cd8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b530b32e58d7de641c1ac1e2a4971f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a44b530b32e58d7de641c1ac1e2a4971f">COLOR_BayerGR2RGB_EA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acbee19d4cd4672c9b6988516e7850bb0">COLOR_BayerGB2BGR_EA</a></td></tr>
<tr class="separator:a44b530b32e58d7de641c1ac1e2a4971f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621682b6f4c6bc015c1ebc059b75f432"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a621682b6f4c6bc015c1ebc059b75f432">COLOR_BayerBG2BGRA</a> = 139</td></tr>
<tr class="separator:a621682b6f4c6bc015c1ebc059b75f432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4c1fd33e473c0621cb3a89c27b77e6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a4c1fd33e473c0621cb3a89c27b77e6">COLOR_BayerGB2BGRA</a> = 140</td></tr>
<tr class="separator:a5a4c1fd33e473c0621cb3a89c27b77e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28810c3f4d5f441fc2af12a8c3089b1"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad28810c3f4d5f441fc2af12a8c3089b1">COLOR_BayerRG2BGRA</a> = 141</td></tr>
<tr class="separator:ad28810c3f4d5f441fc2af12a8c3089b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83d821e2e5cc6a9efd23000dba73c33"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab83d821e2e5cc6a9efd23000dba73c33">COLOR_BayerGR2BGRA</a> = 142</td></tr>
<tr class="separator:ab83d821e2e5cc6a9efd23000dba73c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8147f4eb2fa4fca69586a7743b5050e8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8147f4eb2fa4fca69586a7743b5050e8">COLOR_BayerBG2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad28810c3f4d5f441fc2af12a8c3089b1">COLOR_BayerRG2BGRA</a></td></tr>
<tr class="separator:a8147f4eb2fa4fca69586a7743b5050e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005c23caeba72214b0d2400eec7982d7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a005c23caeba72214b0d2400eec7982d7">COLOR_BayerGB2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab83d821e2e5cc6a9efd23000dba73c33">COLOR_BayerGR2BGRA</a></td></tr>
<tr class="separator:a005c23caeba72214b0d2400eec7982d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1316ea9052d9281fe79b39890da65c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4d1316ea9052d9281fe79b39890da65c">COLOR_BayerRG2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a621682b6f4c6bc015c1ebc059b75f432">COLOR_BayerBG2BGRA</a></td></tr>
<tr class="separator:a4d1316ea9052d9281fe79b39890da65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763ece64f5a4ddc82069227f9fca621a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a763ece64f5a4ddc82069227f9fca621a">COLOR_BayerGR2RGBA</a> = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a4c1fd33e473c0621cb3a89c27b77e6">COLOR_BayerGB2BGRA</a></td></tr>
<tr class="separator:a763ece64f5a4ddc82069227f9fca621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e210deafcd9cfe7acbe0df85ad2124b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9e210deafcd9cfe7acbe0df85ad2124b">COLOR_COLORCVT_MAX</a> = 143</td></tr>
<tr class="separator:a9e210deafcd9cfe7acbe0df85ad2124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a347be864656deaf36444c5a95db2dc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a347be864656deaf36444c5a95db2dc">FILTER_SCHARR</a> = -1</td></tr>
<tr class="separator:a8a347be864656deaf36444c5a95db2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac517f80cb65682792ec110864490d4eb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac517f80cb65682792ec110864490d4eb">DIST_USER</a> = -1</td></tr>
<tr class="separator:ac517f80cb65682792ec110864490d4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bb7cb6ad4718189a1a0e21301db0f9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a> = 1</td></tr>
<tr class="separator:a70bb7cb6ad4718189a1a0e21301db0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f924e45d33bd7e53b2750de0d726b9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a> = 2</td></tr>
<tr class="separator:a79f924e45d33bd7e53b2750de0d726b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53efa51944b46f35adfc5e8fcd98239"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af53efa51944b46f35adfc5e8fcd98239">DIST_C</a> = 3</td></tr>
<tr class="separator:af53efa51944b46f35adfc5e8fcd98239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ed21bd40fb4b159befa421ea4ab6e9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab8ed21bd40fb4b159befa421ea4ab6e9">DIST_L12</a> = 4</td></tr>
<tr class="separator:ab8ed21bd40fb4b159befa421ea4ab6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5416ceb661cd69ed1b34a4674c65ef"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1c5416ceb661cd69ed1b34a4674c65ef">DIST_FAIR</a> = 5</td></tr>
<tr class="separator:a1c5416ceb661cd69ed1b34a4674c65ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0280258898e9271ba0a56b979faff15"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0280258898e9271ba0a56b979faff15">DIST_WELSCH</a> = 6</td></tr>
<tr class="separator:ae0280258898e9271ba0a56b979faff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169f59f9adbc674ba6e58520c18fe51"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8169f59f9adbc674ba6e58520c18fe51">DIST_HUBER</a> = 7</td></tr>
<tr class="separator:a8169f59f9adbc674ba6e58520c18fe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766f4d2bcd4a509e703a5c08b8138866"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a766f4d2bcd4a509e703a5c08b8138866">FONT_HERSHEY_SIMPLEX</a> = 0</td></tr>
<tr class="separator:a766f4d2bcd4a509e703a5c08b8138866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018089991ec3abdbc91440490adcd7eb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a018089991ec3abdbc91440490adcd7eb">FONT_HERSHEY_PLAIN</a> = 1</td></tr>
<tr class="separator:a018089991ec3abdbc91440490adcd7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac796dc4cbcb681082875bc19519a62f4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac796dc4cbcb681082875bc19519a62f4">FONT_HERSHEY_DUPLEX</a> = 2</td></tr>
<tr class="separator:ac796dc4cbcb681082875bc19519a62f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59237b65971fa7487aa0f84cc617566b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a59237b65971fa7487aa0f84cc617566b">FONT_HERSHEY_COMPLEX</a> = 3</td></tr>
<tr class="separator:a59237b65971fa7487aa0f84cc617566b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211befb2e85d8448dff6c26fabf0e7f9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a211befb2e85d8448dff6c26fabf0e7f9">FONT_HERSHEY_TRIPLEX</a> = 4</td></tr>
<tr class="separator:a211befb2e85d8448dff6c26fabf0e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2053d59fee72486e9d4006ce7bc51a4c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2053d59fee72486e9d4006ce7bc51a4c">FONT_HERSHEY_COMPLEX_SMALL</a> = 5</td></tr>
<tr class="separator:a2053d59fee72486e9d4006ce7bc51a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f74345c92c68939e811628ae05bf6c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af9f74345c92c68939e811628ae05bf6c">FONT_HERSHEY_SCRIPT_SIMPLEX</a> = 6</td></tr>
<tr class="separator:af9f74345c92c68939e811628ae05bf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8901f0dc6e71d5266bb1536db0e2c2df"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901f0dc6e71d5266bb1536db0e2c2df">FONT_HERSHEY_SCRIPT_COMPLEX</a> = 7</td></tr>
<tr class="separator:a8901f0dc6e71d5266bb1536db0e2c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea032d9bd61fad6bb7a1851d7ec02ba8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aea032d9bd61fad6bb7a1851d7ec02ba8">FONT_ITALIC</a> = 16</td></tr>
<tr class="separator:aea032d9bd61fad6bb7a1851d7ec02ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477a82bb12e39cb4e7c09059f8a9d50b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a477a82bb12e39cb4e7c09059f8a9d50b">warpPolar</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> src, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> dst, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> dsize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> center, double maxRadius, int flags)</td></tr>
<tr class="separator:a477a82bb12e39cb4e7c09059f8a9d50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9ea60d31b293a1141b609885d8c893"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aef9ea60d31b293a1141b609885d8c893">watershed</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> image, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> markers)</td></tr>
<tr class="separator:aef9ea60d31b293a1141b609885d8c893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32d35c17f9443528b2163b3d6371719"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af32d35c17f9443528b2163b3d6371719">getTextSize</a> (string text, int fontFace, double fontScale, int thickness, int[] baseLine)</td></tr>
<tr class="separator:af32d35c17f9443528b2163b3d6371719"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6f1d32ccd2ebbc5c576dd5630391f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f1d32ccd2ebbc5c576dd5630391f4f">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds an image to the accumulator image.</p>
<p>The function adds src or some of its elements to dst :</p>
<p>(\texttt{dst} (x,y) \leftarrow \texttt{dst} (x,y) + \texttt{src} (x,y) \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>The function supports multi-channel images. Each channel is processed independently.</p>
<p>The function cv::accumulate can be used, for example, to collect statistics of a scene background viewed by a still camera and for the further foreground-background segmentation.</p>
<p>param src Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer. param dst Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F. param mask Optional operation mask.</p>
<p>SEE: accumulateSquare, accumulateProduct, accumulateWeighted </p>

</div>
</div>
<a id="a845dba2cab8088ddabf2a7801931ed33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845dba2cab8088ddabf2a7801931ed33">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds an image to the accumulator image.</p>
<p>The function adds src or some of its elements to dst :</p>
<p>(\texttt{dst} (x,y) \leftarrow \texttt{dst} (x,y) + \texttt{src} (x,y) \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>The function supports multi-channel images. Each channel is processed independently.</p>
<p>The function cv::accumulate can be used, for example, to collect statistics of a scene background viewed by a still camera and for the further foreground-background segmentation.</p>
<p>param src Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer. param dst Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.</p>
<p>SEE: accumulateSquare, accumulateProduct, accumulateWeighted </p>

</div>
</div>
<a id="a8023c8b828f52a7fe7e92d26b7450f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8023c8b828f52a7fe7e92d26b7450f2b">&#9670;&nbsp;</a></span>accumulateProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulateProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the per-element product of two input images to the accumulator image.</p>
<p>The function adds the product of two images or their selected regions to the accumulator dst :</p>
<p>(\texttt{dst} (x,y) \leftarrow \texttt{dst} (x,y) + \texttt{src1} (x,y) \cdot \texttt{src2} (x,y) \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>The function supports multi-channel images. Each channel is processed independently.</p>
<p>param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating point. param src2 Second input image of the same type and the same size as src1 . param dst Accumulator image with the same number of channels as input images, 32-bit or 64-bit floating-point. param mask Optional operation mask.</p>
<p>SEE: accumulate, accumulateSquare, accumulateWeighted </p>

</div>
</div>
<a id="a327f960314676b91a1918db680cb79aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327f960314676b91a1918db680cb79aa">&#9670;&nbsp;</a></span>accumulateProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulateProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the per-element product of two input images to the accumulator image.</p>
<p>The function adds the product of two images or their selected regions to the accumulator dst :</p>
<p>(\texttt{dst} (x,y) \leftarrow \texttt{dst} (x,y) + \texttt{src1} (x,y) \cdot \texttt{src2} (x,y) \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>The function supports multi-channel images. Each channel is processed independently.</p>
<p>param src1 First input image, 1- or 3-channel, 8-bit or 32-bit floating point. param src2 Second input image of the same type and the same size as src1 . param dst Accumulator image with the same number of channels as input images, 32-bit or 64-bit floating-point.</p>
<p>SEE: accumulate, accumulateSquare, accumulateWeighted </p>

</div>
</div>
<a id="ad2b940fd90fa7419fd88a860ccc2e1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b940fd90fa7419fd88a860ccc2e1b1">&#9670;&nbsp;</a></span>accumulateSquare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulateSquare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the square of a source image to the accumulator image.</p>
<p>The function adds the input image src or its selected region, raised to a power of 2, to the accumulator dst :</p>
<p>(\texttt{dst} (x,y) \leftarrow \texttt{dst} (x,y) + \texttt{src} (x,y)^2 \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>The function supports multi-channel images. Each channel is processed independently.</p>
<p>param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point. param dst Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point. param mask Optional operation mask.</p>
<p>SEE: accumulateSquare, accumulateProduct, accumulateWeighted </p>

</div>
</div>
<a id="aa0860536e4b3007f13969311ca7c1cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0860536e4b3007f13969311ca7c1cde">&#9670;&nbsp;</a></span>accumulateSquare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulateSquare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the square of a source image to the accumulator image.</p>
<p>The function adds the input image src or its selected region, raised to a power of 2, to the accumulator dst :</p>
<p>(\texttt{dst} (x,y) \leftarrow \texttt{dst} (x,y) + \texttt{src} (x,y)^2 \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>The function supports multi-channel images. Each channel is processed independently.</p>
<p>param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point. param dst Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</p>
<p>SEE: accumulateSquare, accumulateProduct, accumulateWeighted </p>

</div>
</div>
<a id="ae9ea3ca195b1ca20dd18c2b49e1faf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ea3ca195b1ca20dd18c2b49e1faf0f">&#9670;&nbsp;</a></span>accumulateWeighted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulateWeighted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates a running average.</p>
<p>The function calculates the weighted sum of the input image src and the accumulator dst so that dst becomes a running average of a frame sequence:</p>
<p>(\texttt{dst} (x,y) \leftarrow (1- \texttt{alpha} ) \cdot \texttt{dst} (x,y) + \texttt{alpha} \cdot \texttt{src} (x,y) \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images). The function supports multi-channel images. Each channel is processed independently.</p>
<p>param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point. param dst Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point. param alpha Weight of the input image. param mask Optional operation mask.</p>
<p>SEE: accumulate, accumulateSquare, accumulateProduct </p>

</div>
</div>
<a id="a739cd11eec61fc6d9755c6b04ceb3072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739cd11eec61fc6d9755c6b04ceb3072">&#9670;&nbsp;</a></span>accumulateWeighted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.accumulateWeighted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates a running average.</p>
<p>The function calculates the weighted sum of the input image src and the accumulator dst so that dst becomes a running average of a frame sequence:</p>
<p>(\texttt{dst} (x,y) \leftarrow (1- \texttt{alpha} ) \cdot \texttt{dst} (x,y) + \texttt{alpha} \cdot \texttt{src} (x,y) \quad \text{if} \quad \texttt{mask} (x,y) \ne 0)</p>
<p>That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images). The function supports multi-channel images. Each channel is processed independently.</p>
<p>param src Input image as 1- or 3-channel, 8-bit or 32-bit floating point. param dst Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point. param alpha Weight of the input image.</p>
<p>SEE: accumulate, accumulateSquare, accumulateProduct </p>

</div>
</div>
<a id="a33679aa86f8ed5555474d6bb7ba44a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33679aa86f8ed5555474d6bb7ba44a59">&#9670;&nbsp;</a></span>adaptiveThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.adaptiveThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adaptiveMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies an adaptive threshold to an array.</p>
<p>The function transforms a grayscale image to a binary image according to the formulae: </p><ul>
<li>
<b>THRESH_BINARY</b> (dst(x,y) = \fork{\texttt{maxValue}}{if (src(x,y) &gt; T(x,y))}{0}{otherwise})  </li>
<li>
<b>THRESH_BINARY_INV</b> (dst(x,y) = \fork{0}{if (src(x,y) &gt; T(x,y))}{\texttt{maxValue}}{otherwise}) where (T(x,y)) is a threshold calculated individually for each pixel (see adaptiveMethod parameter).  </li>
</ul>
<p>The function can process the image in-place.</p>
<p>param src Source 8-bit single-channel image. param dst Destination image of the same size and the same type as src. param maxValue Non-zero value assigned to the pixels for which the condition is satisfied param adaptiveMethod Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes. The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries. param thresholdType Thresholding type that must be either <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a67e028e91805b98470871674c698bfad">THRESH_BINARY</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a59df462c043ae03de2521b1ba9bf7849">THRESH_BINARY_INV</a>, see #ThresholdTypes. param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on. param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well.</p>
<p>SEE: threshold, blur, GaussianBlur </p>

</div>
</div>
<a id="ad46fed96953c7d5c1df80679347c3c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46fed96953c7d5c1df80679347c3c66">&#9670;&nbsp;</a></span>applyColorMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.applyColorMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>userColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a user colormap on a given image.</p>
<p>param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. param dst The result is the colormapped source image. Note: Mat::create is called on dst. param userColor The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256 </p>

</div>
</div>
<a id="a2dae338d89aae9bfaf7a4dfda4658283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dae338d89aae9bfaf7a4dfda4658283">&#9670;&nbsp;</a></span>applyColorMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.applyColorMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colormap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a GNU Octave/MATLAB equivalent colormap on a given image.</p>
<p>param src The source image, grayscale or colored of type CV_8UC1 or CV_8UC3. param dst The result is the colormapped source image. Note: Mat::create is called on dst. param colormap The colormap to apply, see #ColormapTypes </p>

</div>
</div>
<a id="ae94b873e4c98e6740dfd800cfcb3036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94b873e4c98e6740dfd800cfcb3036f">&#9670;&nbsp;</a></span>approxPolyDP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.approxPolyDP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>approxCurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Approximates a polygonal curve(s) with the specified precision.</p>
<p>The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less vertices so that the distance between them is less or equal to the specified precision. It uses the Douglas-Peucker algorithm &lt;<a href="http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm&gt;">http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm&amp;gt;</a></p>
<p>param curve Input vector of a 2D point stored in std::vector or Mat param approxCurve Result of the approximation. The type should match the type of the input curve. param epsilon Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation. param closed If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed. </p>

</div>
</div>
<a id="a246113d68dafe23bcfb7fafd3c4271e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246113d68dafe23bcfb7fafd3c4271e0">&#9670;&nbsp;</a></span>arcLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.arcLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a contour perimeter or a curve length.</p>
<p>The function computes a curve length or a closed contour perimeter.</p>
<p>param curve Input vector of 2D points, stored in std::vector or Mat. param closed Flag indicating whether the curve is closed or not. return automatically generated </p>

</div>
</div>
<a id="a4de3daa90bce13936c68ebcfca983956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de3daa90bce13936c68ebcfca983956">&#9670;&nbsp;</a></span>arrowedLine() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.arrowedLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tipLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a arrow segment pointing from the first point to the second one.</p>
<p>The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08f6c6182fd1fdb9dec625a253e91eae">line</a>.</p>
<p>param img Image. param pt1 The point the arrow starts from. param pt2 The point the arrow points to. param color Line color. param thickness Line thickness. param line_type Type of the line. See #LineTypes param shift Number of fractional bits in the point coordinates. param tipLength The length of the arrow tip in relation to the arrow length </p>

</div>
</div>
<a id="a95c723992cdfada4bdf9f0ae95adcaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c723992cdfada4bdf9f0ae95adcaca">&#9670;&nbsp;</a></span>arrowedLine() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.arrowedLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a arrow segment pointing from the first point to the second one.</p>
<p>The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08f6c6182fd1fdb9dec625a253e91eae">line</a>.</p>
<p>param img Image. param pt1 The point the arrow starts from. param pt2 The point the arrow points to. param color Line color. param thickness Line thickness. param line_type Type of the line. See #LineTypes param shift Number of fractional bits in the point coordinates. </p>

</div>
</div>
<a id="a345da36c91d345594ee009d3440afb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345da36c91d345594ee009d3440afb84">&#9670;&nbsp;</a></span>arrowedLine() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.arrowedLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a arrow segment pointing from the first point to the second one.</p>
<p>The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08f6c6182fd1fdb9dec625a253e91eae">line</a>.</p>
<p>param img Image. param pt1 The point the arrow starts from. param pt2 The point the arrow points to. param color Line color. param thickness Line thickness. param line_type Type of the line. See #LineTypes </p>

</div>
</div>
<a id="a33c000cf3a68d3c1a1a9a0d9cce03bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c000cf3a68d3c1a1a9a0d9cce03bb5">&#9670;&nbsp;</a></span>arrowedLine() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.arrowedLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a arrow segment pointing from the first point to the second one.</p>
<p>The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08f6c6182fd1fdb9dec625a253e91eae">line</a>.</p>
<p>param img Image. param pt1 The point the arrow starts from. param pt2 The point the arrow points to. param color Line color. param thickness Line thickness. </p>

</div>
</div>
<a id="a923b309be9b8cc422b1c77d5ea9a4f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923b309be9b8cc422b1c77d5ea9a4f0c">&#9670;&nbsp;</a></span>arrowedLine() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.arrowedLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a arrow segment pointing from the first point to the second one.</p>
<p>The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a08f6c6182fd1fdb9dec625a253e91eae">line</a>.</p>
<p>param img Image. param pt1 The point the arrow starts from. param pt2 The point the arrow points to. param color Line color. </p>

</div>
</div>
<a id="a1910e2e5b55f6929751d2b7ce6f8a47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1910e2e5b55f6929751d2b7ce6f8a47d">&#9670;&nbsp;</a></span>bilateralFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.bilateralFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies the bilateral filter to an image.</p>
<p>The function applies bilateral filtering to the input image, as described in <a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a> bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.</p>
<p><em>Sigma values</em>: For simplicity, you can set the 2 sigma values to be the same. If they are small (&lt; 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very strong effect, making the image look "cartoonish".</p>
<p><em>Filter size</em>: Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering.</p>
<p>This filter does not work inplace. param src Source 8-bit or floating-point, 1-channel or 3-channel image. param dst Destination image of the same size and type as src . param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace. param sigmaColor Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color. param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace. param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes </p>

</div>
</div>
<a id="a7a830e5dc2747058ecc2da72301839de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a830e5dc2747058ecc2da72301839de">&#9670;&nbsp;</a></span>bilateralFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.bilateralFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies the bilateral filter to an image.</p>
<p>The function applies bilateral filtering to the input image, as described in <a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a> bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.</p>
<p><em>Sigma values</em>: For simplicity, you can set the 2 sigma values to be the same. If they are small (&lt; 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very strong effect, making the image look "cartoonish".</p>
<p><em>Filter size</em>: Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering.</p>
<p>This filter does not work inplace. param src Source 8-bit or floating-point, 1-channel or 3-channel image. param dst Destination image of the same size and type as src . param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace. param sigmaColor Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color. param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace. </p>

</div>
</div>
<a id="a9a1021eb8c0529e4062d4f3af11f1a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1021eb8c0529e4062d4f3af11f1a11">&#9670;&nbsp;</a></span>blur() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.blur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the normalized box filter.</p>
<p>The function smooths an image using the kernel:</p>
<p>(\texttt{K} = \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \hdotsfor{6} \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \end{bmatrix})</p>
<p>The call {code blur(src, dst, ksize, anchor, borderType)} is equivalent to <code>boxFilter(src, dst, src.type(), ksize, anchor, true, borderType)</code>.</p>
<p>param src input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param ksize blurring kernel size. param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. SEE: boxFilter, bilateralFilter, GaussianBlur, medianBlur </p>

</div>
</div>
<a id="a37d6ac40fd4c7949a7db9edbd6fac366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d6ac40fd4c7949a7db9edbd6fac366">&#9670;&nbsp;</a></span>blur() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.blur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the normalized box filter.</p>
<p>The function smooths an image using the kernel:</p>
<p>(\texttt{K} = \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \hdotsfor{6} \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \end{bmatrix})</p>
<p>The call {code blur(src, dst, ksize, anchor, borderType)} is equivalent to <code>boxFilter(src, dst, src.type(), ksize, anchor, true, borderType)</code>.</p>
<p>param src input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param ksize blurring kernel size. param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. SEE: boxFilter, bilateralFilter, GaussianBlur, medianBlur </p>

</div>
</div>
<a id="ab6d54406ed53289e76691f2d6a7d57c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d54406ed53289e76691f2d6a7d57c6">&#9670;&nbsp;</a></span>blur() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.blur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the normalized box filter.</p>
<p>The function smooths an image using the kernel:</p>
<p>(\texttt{K} = \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \hdotsfor{6} \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \end{bmatrix})</p>
<p>The call {code blur(src, dst, ksize, anchor, borderType)} is equivalent to <code>boxFilter(src, dst, src.type(), ksize, anchor, true, borderType)</code>.</p>
<p>param src input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param ksize blurring kernel size. center. SEE: boxFilter, bilateralFilter, GaussianBlur, medianBlur </p>

</div>
</div>
<a id="a6e82a7086668675f8ce5629741c87453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e82a7086668675f8ce5629741c87453">&#9670;&nbsp;</a></span>boundingRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> OpenCVForUnity.ImgprocModule.Imgproc.boundingRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.</p>
<p>The function calculates and returns the minimal up-right bounding rectangle for the specified point set or non-zero pixels of gray-scale image.</p>
<p>param array Input gray-scale image or 2D point set, stored in std::vector or Mat. return automatically generated </p>

</div>
</div>
<a id="a206806db2c03100470de002b5e44f8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206806db2c03100470de002b5e44f8b2">&#9670;&nbsp;</a></span>boxFilter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.boxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the box filter.</p>
<p>The function smooths an image using the kernel:</p>
<p>(\texttt{K} = \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \hdotsfor{6} \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \end{bmatrix})</p>
<p>where</p>
<p>(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true} \1 &amp; \texttt{otherwise}\end{cases})</p>
<p>Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7de47b4e016e986eb5636b4dbd0e34ba">integral</a>.</p>
<p>param src input image. param dst output image of the same size and type as src. param ddepth the output image depth (-1 to use src.depth()). param ksize blurring kernel size. param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. param normalize flag, specifying whether the kernel is normalized by its area or not. param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. SEE: blur, bilateralFilter, GaussianBlur, medianBlur, integral </p>

</div>
</div>
<a id="a88e6125323675f841e71a1afb8ce1005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e6125323675f841e71a1afb8ce1005">&#9670;&nbsp;</a></span>boxFilter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.boxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the box filter.</p>
<p>The function smooths an image using the kernel:</p>
<p>(\texttt{K} = \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \hdotsfor{6} \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \end{bmatrix})</p>
<p>where</p>
<p>(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true} \1 &amp; \texttt{otherwise}\end{cases})</p>
<p>Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7de47b4e016e986eb5636b4dbd0e34ba">integral</a>.</p>
<p>param src input image. param dst output image of the same size and type as src. param ddepth the output image depth (-1 to use src.depth()). param ksize blurring kernel size. param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. param normalize flag, specifying whether the kernel is normalized by its area or not. SEE: blur, bilateralFilter, GaussianBlur, medianBlur, integral </p>

</div>
</div>
<a id="a93063c39f4b1da7ed4fc69cc090fb776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93063c39f4b1da7ed4fc69cc090fb776">&#9670;&nbsp;</a></span>boxFilter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.boxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the box filter.</p>
<p>The function smooths an image using the kernel:</p>
<p>(\texttt{K} = \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \hdotsfor{6} \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \end{bmatrix})</p>
<p>where</p>
<p>(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true} \1 &amp; \texttt{otherwise}\end{cases})</p>
<p>Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7de47b4e016e986eb5636b4dbd0e34ba">integral</a>.</p>
<p>param src input image. param dst output image of the same size and type as src. param ddepth the output image depth (-1 to use src.depth()). param ksize blurring kernel size. param anchor anchor point; default value Point(-1,-1) means that the anchor is at the kernel center. SEE: blur, bilateralFilter, GaussianBlur, medianBlur, integral </p>

</div>
</div>
<a id="a5ba98f73a1cfbe02b1301005349bb0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba98f73a1cfbe02b1301005349bb0cd">&#9670;&nbsp;</a></span>boxFilter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.boxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the box filter.</p>
<p>The function smooths an image using the kernel:</p>
<p>(\texttt{K} = \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \ \hdotsfor{6} \ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 &amp; 1 \end{bmatrix})</p>
<p>where</p>
<p>(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true} \1 &amp; \texttt{otherwise}\end{cases})</p>
<p>Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7de47b4e016e986eb5636b4dbd0e34ba">integral</a>.</p>
<p>param src input image. param dst output image of the same size and type as src. param ddepth the output image depth (-1 to use src.depth()). param ksize blurring kernel size. center. SEE: blur, bilateralFilter, GaussianBlur, medianBlur, integral </p>

</div>
</div>
<a id="a17eb3f375ee0e72d74bb17d7eae2f04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17eb3f375ee0e72d74bb17d7eae2f04b">&#9670;&nbsp;</a></span>boxPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.boxPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.</p>
<p>The function finds the four vertices of a rotated rectangle. This function is useful to draw the rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please visit the REF: tutorial_bounding_rotated_ellipses "tutorial on Creating Bounding rotated boxes and ellipses for contours" for more information.</p>
<p>param box The input rotated rectangle. It may be the output of param points The output array of four vertices of rectangles. </p>

</div>
</div>
<a id="a424e0929cfd8869278c03b97a062df8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424e0929cfd8869278c03b97a062df8f">&#9670;&nbsp;</a></span>calcBackProject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.calcBackProject </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float.html">MatOfFloat</a>&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73e1cd1bc0ad5fb28dff3b004b769756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e1cd1bc0ad5fb28dff3b004b769756">&#9670;&nbsp;</a></span>calcHist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.calcHist </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>histSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float.html">MatOfFloat</a>&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>accumulate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0e6e9f69e14b2659739e8973f0a4b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e6e9f69e14b2659739e8973f0a4b44">&#9670;&nbsp;</a></span>calcHist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.calcHist </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> &gt;&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>histSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float.html">MatOfFloat</a>&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ae77b7fbf08a26bff1ecaed494f4bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae77b7fbf08a26bff1ecaed494f4bf1">&#9670;&nbsp;</a></span>Canny() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Canny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>L2gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Finds edges in an image using the Canny algorithm with custom image gradient.</p>
<p>param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3). param dy 16-bit y derivative of input image (same type as dx). param edges output edge map; single channels 8-bit image, which has the same size as image . param threshold1 first threshold for the hysteresis procedure. param threshold2 second threshold for the hysteresis procedure. param L2gradient a flag, indicating whether a more accurate (L_2) norm (=\sqrt{(dI/dx)^2 + (dI/dy)^2}) should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default (L_1) norm (=|dI/dx|+|dI/dy|) is enough ( L2gradient=false ). </p>

</div>
</div>
<a id="ade7f956927e1c6ccdde819f0c7a74a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7f956927e1c6ccdde819f0c7a74a79">&#9670;&nbsp;</a></span>Canny() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Canny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Finds edges in an image using the Canny algorithm with custom image gradient.</p>
<p>param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3). param dy 16-bit y derivative of input image (same type as dx). param edges output edge map; single channels 8-bit image, which has the same size as image . param threshold1 first threshold for the hysteresis procedure. param threshold2 second threshold for the hysteresis procedure. (=\sqrt{(dI/dx)^2 + (dI/dy)^2}) should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default (L_1) norm (=|dI/dx|+|dI/dy|) is enough ( L2gradient=false ). </p>

</div>
</div>
<a id="af59e10c173d149834c503119427f6bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59e10c173d149834c503119427f6bb5">&#9670;&nbsp;</a></span>Canny() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Canny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>apertureSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>L2gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds edges in an image using the Canny algorithm CITE: Canny86 .</p>
<p>The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See &lt;<a href="http://en.wikipedia.org/wiki/Canny_edge_detector&gt;">http://en.wikipedia.org/wiki/Canny_edge_detector&amp;gt;</a></p>
<p>param image 8-bit input image. param edges output edge map; single channels 8-bit image, which has the same size as image . param threshold1 first threshold for the hysteresis procedure. param threshold2 second threshold for the hysteresis procedure. param apertureSize aperture size for the Sobel operator. param L2gradient a flag, indicating whether a more accurate (L_2) norm (=\sqrt{(dI/dx)^2 + (dI/dy)^2}) should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default (L_1) norm (=|dI/dx|+|dI/dy|) is enough ( L2gradient=false ). </p>

</div>
</div>
<a id="ad056e8b351a21499110607c6670406d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad056e8b351a21499110607c6670406d0">&#9670;&nbsp;</a></span>Canny() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Canny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>apertureSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds edges in an image using the Canny algorithm CITE: Canny86 .</p>
<p>The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See &lt;<a href="http://en.wikipedia.org/wiki/Canny_edge_detector&gt;">http://en.wikipedia.org/wiki/Canny_edge_detector&amp;gt;</a></p>
<p>param image 8-bit input image. param edges output edge map; single channels 8-bit image, which has the same size as image . param threshold1 first threshold for the hysteresis procedure. param threshold2 second threshold for the hysteresis procedure. param apertureSize aperture size for the Sobel operator. (=\sqrt{(dI/dx)^2 + (dI/dy)^2}) should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default (L_1) norm (=|dI/dx|+|dI/dy|) is enough ( L2gradient=false ). </p>

</div>
</div>
<a id="a4f39feae6c58ad48d734be6ea23ad105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f39feae6c58ad48d734be6ea23ad105">&#9670;&nbsp;</a></span>Canny() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Canny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds edges in an image using the Canny algorithm CITE: Canny86 .</p>
<p>The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See &lt;<a href="http://en.wikipedia.org/wiki/Canny_edge_detector&gt;">http://en.wikipedia.org/wiki/Canny_edge_detector&amp;gt;</a></p>
<p>param image 8-bit input image. param edges output edge map; single channels 8-bit image, which has the same size as image . param threshold1 first threshold for the hysteresis procedure. param threshold2 second threshold for the hysteresis procedure. (=\sqrt{(dI/dx)^2 + (dI/dy)^2}) should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default (L_1) norm (=|dI/dx|+|dI/dy|) is enough ( L2gradient=false ). </p>

</div>
</div>
<a id="a19fcf5ff5501809e323ac7a405791863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fcf5ff5501809e323ac7a405791863">&#9670;&nbsp;</a></span>circle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.circle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a circle.</p>
<p>The function cv::circle draws a simple or filled circle with a given center and radius. param img Image where the circle is drawn. param center Center of the circle. param radius Radius of the circle. param color Circle color. param thickness Thickness of the circle outline, if positive. Negative values, like <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, mean that a filled circle is to be drawn. param lineType Type of the circle boundary. See #LineTypes param shift Number of fractional bits in the coordinates of the center and in the radius value. </p>

</div>
</div>
<a id="a03eb4ee60e6ebd9e075c164302f86f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03eb4ee60e6ebd9e075c164302f86f94">&#9670;&nbsp;</a></span>circle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.circle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a circle.</p>
<p>The function cv::circle draws a simple or filled circle with a given center and radius. param img Image where the circle is drawn. param center Center of the circle. param radius Radius of the circle. param color Circle color. param thickness Thickness of the circle outline, if positive. Negative values, like <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, mean that a filled circle is to be drawn. param lineType Type of the circle boundary. See #LineTypes </p>

</div>
</div>
<a id="a43b95f831d5acf8071fb8c97d89de990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b95f831d5acf8071fb8c97d89de990">&#9670;&nbsp;</a></span>circle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.circle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a circle.</p>
<p>The function cv::circle draws a simple or filled circle with a given center and radius. param img Image where the circle is drawn. param center Center of the circle. param radius Radius of the circle. param color Circle color. param thickness Thickness of the circle outline, if positive. Negative values, like <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, mean that a filled circle is to be drawn. </p>

</div>
</div>
<a id="a510686f2423c8f5ccce1d28c6749cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510686f2423c8f5ccce1d28c6749cbb0">&#9670;&nbsp;</a></span>circle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.circle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a circle.</p>
<p>The function cv::circle draws a simple or filled circle with a given center and radius. param img Image where the circle is drawn. param center Center of the circle. param radius Radius of the circle. param color Circle color. mean that a filled circle is to be drawn. </p>

</div>
</div>
<a id="a55ca31cea2ed3d56ffe35a9fdcc4c272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ca31cea2ed3d56ffe35a9fdcc4c272">&#9670;&nbsp;</a></span>clipLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.ImgprocModule.Imgproc.clipLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>imgRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param imgRect Image rectangle. param pt1 First line point. param pt2 Second line point. return automatically generated </p>

</div>
</div>
<a id="a5a166d5592f8b46c589b5f687281c6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a166d5592f8b46c589b5f687281c6f4">&#9670;&nbsp;</a></span>compareHist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.compareHist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>H1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>H2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two histograms.</p>
<p>The function cv::compareHist compares two dense or two sparse histograms using the specified method.</p>
<p>The function returns (d(H_1, H_2)) .</p>
<p>While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms or more general sparse configurations of weighted points, consider using the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a12c66029d7932044689e7be343d9c9f0">EMD</a> function.</p>
<p>param H1 First compared histogram. param H2 Second compared histogram of the same size as H1 . param method Comparison method, see #HistCompMethods return automatically generated </p>

</div>
</div>
<a id="a8ea44cfa83d39aaaf784575df237d997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea44cfa83d39aaaf784575df237d997">&#9670;&nbsp;</a></span>connectedComponents() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ltype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image param connectivity 8 or 4 for 8-way or 4-way connectivity respectively param ltype output image label type. Currently CV_32S and CV_16U are supported. return automatically generated </p>

</div>
</div>
<a id="a274dd0096dbfe40d3c79d3932a7c146b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274dd0096dbfe40d3c79d3932a7c146b">&#9670;&nbsp;</a></span>connectedComponents() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image param connectivity 8 or 4 for 8-way or 4-way connectivity respectively return automatically generated </p>

</div>
</div>
<a id="abe241a582151a5065c1cef47ffd8195c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe241a582151a5065c1cef47ffd8195c">&#9670;&nbsp;</a></span>connectedComponents() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image return automatically generated </p>

</div>
</div>
<a id="aa0e54afc0afa740deca4f17866133005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e54afc0afa740deca4f17866133005">&#9670;&nbsp;</a></span>connectedComponentsWithAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponentsWithAlgorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ltype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ccltype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes the connected components labeled image of boolean image</p>
<p>image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Grana (BBDT) and Wu's (SAUF) CITE: Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not. This function uses parallel version of both Grana and Wu's algorithms if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.</p>
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image param connectivity 8 or 4 for 8-way or 4-way connectivity respectively param ltype output image label type. Currently CV_32S and CV_16U are supported. param ccltype connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes). return automatically generated </p>

</div>
</div>
<a id="a7732191f1e173df1aa9e4e03bfc26051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7732191f1e173df1aa9e4e03bfc26051">&#9670;&nbsp;</a></span>connectedComponentsWithStats() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponentsWithStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ltype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image param stats statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. param centroids centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. param connectivity 8 or 4 for 8-way or 4-way connectivity respectively param ltype output image label type. Currently CV_32S and CV_16U are supported. return automatically generated </p>

</div>
</div>
<a id="a7fecd2d52b491ef21af3b6c7bc9d09c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fecd2d52b491ef21af3b6c7bc9d09c3">&#9670;&nbsp;</a></span>connectedComponentsWithStats() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponentsWithStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image param stats statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. param centroids centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. param connectivity 8 or 4 for 8-way or 4-way connectivity respectively return automatically generated </p>

</div>
</div>
<a id="a4f4b399a4172da100fa58d73b2caae0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4b399a4172da100fa58d73b2caae0a">&#9670;&nbsp;</a></span>connectedComponentsWithStats() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponentsWithStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>centroids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image param stats statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. param centroids centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. return automatically generated </p>

</div>
</div>
<a id="a50b8ca72d1087900abfdebc1bd8bbd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b8ca72d1087900abfdebc1bd8bbd9a">&#9670;&nbsp;</a></span>connectedComponentsWithStatsWithAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.connectedComponentsWithStatsWithAlgorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ltype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ccltype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes the connected components labeled image of boolean image and also produces a statistics output for each label</p>
<p>image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Grana's (BBDT) and Wu's (SAUF) CITE: Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not. This function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.</p>
<p>param image the 8-bit single-channel image to be labeled param labels destination labeled image param stats statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S. param centroids centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F. param connectivity 8 or 4 for 8-way or 4-way connectivity respectively param ltype output image label type. Currently CV_32S and CV_16U are supported. param ccltype connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes). return automatically generated </p>

</div>
</div>
<a id="afb6463ee75ae41159c2c6c2141edb5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6463ee75ae41159c2c6c2141edb5c6">&#9670;&nbsp;</a></span>contourArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.contourArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oriented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a contour area.</p>
<p>The function computes a contour area. Similarly to moments , the area is computed using the Green formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a> , can be different. Also, the function will most certainly give a wrong results for contours with self-intersections.</p>
<p>Example: <code> vector&lt;Point&gt; contour; contour.push_back(Point2f(0, 0)); contour.push_back(Point2f(10, 0)); contour.push_back(Point2f(10, 10)); contour.push_back(Point2f(5, 4));</code></p>
<p><code> double area0 = contourArea(contour); vector&lt;Point&gt; approx; approxPolyDP(contour, approx, 5, true); double area1 = contourArea(approx);</code></p>
<p><code> cout &lt;&lt; "area0 =" &lt;&lt; area0 &lt;&lt; endl &lt;&lt; "area1 =" &lt;&lt; area1 &lt;&lt; endl &lt;&lt; "approx poly vertices" &lt;&lt; approx.size() &lt;&lt; endl; </code> param contour Input vector of 2D points (contour vertices), stored in std::vector or Mat. param oriented Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is false, which means that the absolute value is returned. return automatically generated </p>

</div>
</div>
<a id="a383b889e0aaf32d2dfa0aabc09a68c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383b889e0aaf32d2dfa0aabc09a68c62">&#9670;&nbsp;</a></span>contourArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.contourArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>contour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a contour area.</p>
<p>The function computes a contour area. Similarly to moments , the area is computed using the Green formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a> , can be different. Also, the function will most certainly give a wrong results for contours with self-intersections.</p>
<p>Example: <code> vector&lt;Point&gt; contour; contour.push_back(Point2f(0, 0)); contour.push_back(Point2f(10, 0)); contour.push_back(Point2f(10, 10)); contour.push_back(Point2f(5, 4));</code></p>
<p><code> double area0 = contourArea(contour); vector&lt;Point&gt; approx; approxPolyDP(contour, approx, 5, true); double area1 = contourArea(approx);</code></p>
<p><code> cout &lt;&lt; "area0 =" &lt;&lt; area0 &lt;&lt; endl &lt;&lt; "area1 =" &lt;&lt; area1 &lt;&lt; endl &lt;&lt; "approx poly vertices" &lt;&lt; approx.size() &lt;&lt; endl; </code> param contour Input vector of 2D points (contour vertices), stored in std::vector or Mat. depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is false, which means that the absolute value is returned. return automatically generated </p>

</div>
</div>
<a id="a8f3fa4b004f499201f2d8a3e4f29736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3fa4b004f499201f2d8a3e4f29736c">&#9670;&nbsp;</a></span>convertMaps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.convertMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dstmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dstmap2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstmap1type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nninterpolation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts image transformation maps from one representation to another.</p>
<p>The function converts a pair of maps for remap from one representation to another. The following options ( (map1.type(), map2.type()) (\rightarrow) (dstmap1.type(), dstmap2.type()) ) are supported:</p>
<ul>
<li>
(\texttt{(CV_32FC1, CV_32FC1)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}). This is the most frequently used conversion operation, in which the original floating-point maps (see remap ) are converted to a more compact and much faster fixed-point representation. The first output array contains the rounded coordinates and the second array (created only when nninterpolation=false ) contains indices in the interpolation tables.  </li>
</ul>
<ul>
<li>
(\texttt{(CV_32FC2)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}). The same as above but the original maps are stored in one 2-channel matrix.  </li>
</ul>
<ul>
<li>
Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same as the originals.  </li>
</ul>
<p>param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 . param map2 The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix), respectively. param dstmap1 The first output map that has the type dstmap1type and the same size as src . param dstmap2 The second output map. param dstmap1type Type of the first output map that should be CV_16SC2, CV_32FC1, or CV_32FC2 . param nninterpolation Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.</p>
<p>SEE: remap, undistort, initUndistortRectifyMap </p>

</div>
</div>
<a id="af7a5dfdd097f276535e6bc1bb219de1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a5dfdd097f276535e6bc1bb219de1f">&#9670;&nbsp;</a></span>convertMaps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.convertMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dstmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dstmap2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstmap1type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts image transformation maps from one representation to another.</p>
<p>The function converts a pair of maps for remap from one representation to another. The following options ( (map1.type(), map2.type()) (\rightarrow) (dstmap1.type(), dstmap2.type()) ) are supported:</p>
<ul>
<li>
(\texttt{(CV_32FC1, CV_32FC1)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}). This is the most frequently used conversion operation, in which the original floating-point maps (see remap ) are converted to a more compact and much faster fixed-point representation. The first output array contains the rounded coordinates and the second array (created only when nninterpolation=false ) contains indices in the interpolation tables.  </li>
</ul>
<ul>
<li>
(\texttt{(CV_32FC2)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}). The same as above but the original maps are stored in one 2-channel matrix.  </li>
</ul>
<ul>
<li>
Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same as the originals.  </li>
</ul>
<p>param map1 The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 . param map2 The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix), respectively. param dstmap1 The first output map that has the type dstmap1type and the same size as src . param dstmap2 The second output map. param dstmap1type Type of the first output map that should be CV_16SC2, CV_32FC1, or CV_32FC2 . nearest-neighbor or for a more complex interpolation.</p>
<p>SEE: remap, undistort, initUndistortRectifyMap </p>

</div>
</div>
<a id="a8b420ddcf1093536f060a33e137441df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b420ddcf1093536f060a33e137441df">&#9670;&nbsp;</a></span>convexHull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.convexHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clockwise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the convex hull of a point set.</p>
<p>The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm CITE: Sklansky82 that has <em>O(N logN)</em> complexity in the current implementation.</p>
<p>param points Input 2D point set, stored in std::vector or Mat. param hull Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves. param clockwise Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards. returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector: std::vector&lt;int&gt; implies returnPoints=false, std::vector&lt;Point&gt; implies returnPoints=true.</p>
<p><b>Note:</b> {code points} and {code hull} should be different arrays, inplace processing isn't supported.</p>
<p>Check REF: tutorial_hull "the corresponding tutorial" for more details.</p>
<p>useful links:</p>
<p><a href="https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/">https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/</a> </p>

</div>
</div>
<a id="af7db0720f71cb64f7782e5ae44a339ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7db0720f71cb64f7782e5ae44a339ac">&#9670;&nbsp;</a></span>convexHull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.convexHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the convex hull of a point set.</p>
<p>The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm CITE: Sklansky82 that has <em>O(N logN)</em> complexity in the current implementation.</p>
<p>param points Input 2D point set, stored in std::vector or Mat. param hull Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards. returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector: std::vector&lt;int&gt; implies returnPoints=false, std::vector&lt;Point&gt; implies returnPoints=true.</p>
<p><b>Note:</b> {code points} and {code hull} should be different arrays, inplace processing isn't supported.</p>
<p>Check REF: tutorial_hull "the corresponding tutorial" for more details.</p>
<p>useful links:</p>
<p><a href="https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/">https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/</a> </p>

</div>
</div>
<a id="a1795beca8c208a75622113f715c3f1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1795beca8c208a75622113f715c3f1e7">&#9670;&nbsp;</a></span>convexityDefects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.convexityDefects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html">MatOfInt</a>&#160;</td>
          <td class="paramname"><em>convexhull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int4.html">MatOfInt4</a>&#160;</td>
          <td class="paramname"><em>convexityDefects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the convexity defects of a contour.</p>
<p>The figure below displays convexity defects of a hand contour:</p>
<img src="pics/defects.png" alt="image" class="inline"/>
<p>param contour Input contour. param convexhull Convex hull obtained using convexHull that should contain indices of the contour points that make the hull. param convexityDefects The output vector of convexity defects. In C++ and the new Python/Java interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices in the original contour of the convexity defect beginning, end and the farthest point, and fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </p>

</div>
</div>
<a id="a5a1335f3e60433b7ca5fe59fca8afbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1335f3e60433b7ca5fe59fca8afbe3">&#9670;&nbsp;</a></span>cornerEigenValsAndVecs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerEigenValsAndVecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates eigenvalues and eigenvectors of image blocks for corner detection.</p>
<p>For every pixel (p) , the function cornerEigenValsAndVecs considers a blockSize (\times) blockSize neighborhood (S(p)) . It calculates the covariation matrix of derivatives over the neighborhood as:</p>
<p>(M = \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &amp; \sum _{S(p)}dI/dx dI/dy \ \sum _{S(p)}dI/dx dI/dy &amp; \sum _{S(p)}(dI/dy)^2 \end{bmatrix})</p>
<p>where the derivatives are computed using the Sobel operator.</p>
<p>After that, it finds eigenvectors and eigenvalues of (M) and stores them in the destination image as ((\lambda_1, \lambda_2, x_1, y_1, x_2, y_2)) where</p>
<ul>
<li>
(\lambda_1, \lambda_2) are the non-sorted eigenvalues of (M)  </li>
<li>
(x_1, y_1) are the eigenvectors corresponding to (\lambda_1)  </li>
<li>
(x_2, y_2) are the eigenvectors corresponding to (\lambda_2)  </li>
</ul>
<p>The output of the function can be used for robust edge or corner detection.</p>
<p>param src Input single-channel 8-bit or floating-point image. param dst Image to store the results. It has the same size as src and the type CV_32FC(6) . param blockSize Neighborhood size (see details below). param ksize Aperture parameter for the Sobel operator. param borderType Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</p>
<p>SEE: cornerMinEigenVal, cornerHarris, preCornerDetect </p>

</div>
</div>
<a id="af2a24fecf761eb4cfcdbe68047fc6b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a24fecf761eb4cfcdbe68047fc6b34">&#9670;&nbsp;</a></span>cornerEigenValsAndVecs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerEigenValsAndVecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates eigenvalues and eigenvectors of image blocks for corner detection.</p>
<p>For every pixel (p) , the function cornerEigenValsAndVecs considers a blockSize (\times) blockSize neighborhood (S(p)) . It calculates the covariation matrix of derivatives over the neighborhood as:</p>
<p>(M = \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &amp; \sum _{S(p)}dI/dx dI/dy \ \sum _{S(p)}dI/dx dI/dy &amp; \sum _{S(p)}(dI/dy)^2 \end{bmatrix})</p>
<p>where the derivatives are computed using the Sobel operator.</p>
<p>After that, it finds eigenvectors and eigenvalues of (M) and stores them in the destination image as ((\lambda_1, \lambda_2, x_1, y_1, x_2, y_2)) where</p>
<ul>
<li>
(\lambda_1, \lambda_2) are the non-sorted eigenvalues of (M)  </li>
<li>
(x_1, y_1) are the eigenvectors corresponding to (\lambda_1)  </li>
<li>
(x_2, y_2) are the eigenvectors corresponding to (\lambda_2)  </li>
</ul>
<p>The output of the function can be used for robust edge or corner detection.</p>
<p>param src Input single-channel 8-bit or floating-point image. param dst Image to store the results. It has the same size as src and the type CV_32FC(6) . param blockSize Neighborhood size (see details below). param ksize Aperture parameter for the Sobel operator.</p>
<p>SEE: cornerMinEigenVal, cornerHarris, preCornerDetect </p>

</div>
</div>
<a id="a0f8ad0c7fab4c1f49409707163b2bc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8ad0c7fab4c1f49409707163b2bc1a">&#9670;&nbsp;</a></span>cornerHarris() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerHarris </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Harris corner detector.</p>
<p>The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and cornerEigenValsAndVecs , for each pixel ((x, y)) it calculates a (2\times2) gradient covariance matrix (M^{(x,y)}) over a (\texttt{blockSize} \times \texttt{blockSize}) neighborhood. Then, it computes the following characteristic:</p>
<p>(\texttt{dst} (x,y) = \mathrm{det} M^{(x,y)} - k \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2)</p>
<p>Corners in the image can be found as the local maxima of this response map.</p>
<p>param src Input single-channel 8-bit or floating-point image. param dst Image to store the Harris detector responses. It has the type CV_32FC1 and the same size as src . param blockSize Neighborhood size (see the details on <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a1335f3e60433b7ca5fe59fca8afbe3">cornerEigenValsAndVecs</a> ). param ksize Aperture parameter for the Sobel operator. param k Harris detector free parameter. See the formula above. param borderType Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. </p>

</div>
</div>
<a id="a8e245e4638674325ec5c618c8ab73644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e245e4638674325ec5c618c8ab73644">&#9670;&nbsp;</a></span>cornerHarris() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerHarris </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Harris corner detector.</p>
<p>The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and cornerEigenValsAndVecs , for each pixel ((x, y)) it calculates a (2\times2) gradient covariance matrix (M^{(x,y)}) over a (\texttt{blockSize} \times \texttt{blockSize}) neighborhood. Then, it computes the following characteristic:</p>
<p>(\texttt{dst} (x,y) = \mathrm{det} M^{(x,y)} - k \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2)</p>
<p>Corners in the image can be found as the local maxima of this response map.</p>
<p>param src Input single-channel 8-bit or floating-point image. param dst Image to store the Harris detector responses. It has the type CV_32FC1 and the same size as src . param blockSize Neighborhood size (see the details on <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a1335f3e60433b7ca5fe59fca8afbe3">cornerEigenValsAndVecs</a> ). param ksize Aperture parameter for the Sobel operator. param k Harris detector free parameter. See the formula above. </p>

</div>
</div>
<a id="a4bdac67e089b6ea241ca3663cee1847b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdac67e089b6ea241ca3663cee1847b">&#9670;&nbsp;</a></span>cornerMinEigenVal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerMinEigenVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the minimal eigenvalue of gradient matrices for corner detection.</p>
<p>The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, (\min(\lambda_1, \lambda_2)) in terms of the formulae in the cornerEigenValsAndVecs description.</p>
<p>param src Input single-channel 8-bit or floating-point image. param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src . param blockSize Neighborhood size (see the details on <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a1335f3e60433b7ca5fe59fca8afbe3">cornerEigenValsAndVecs</a> ). param ksize Aperture parameter for the Sobel operator. param borderType Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. </p>

</div>
</div>
<a id="aa03bb5d7ff7b7ff0f5ea8a23c5ef9062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03bb5d7ff7b7ff0f5ea8a23c5ef9062">&#9670;&nbsp;</a></span>cornerMinEigenVal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerMinEigenVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the minimal eigenvalue of gradient matrices for corner detection.</p>
<p>The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, (\min(\lambda_1, \lambda_2)) in terms of the formulae in the cornerEigenValsAndVecs description.</p>
<p>param src Input single-channel 8-bit or floating-point image. param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src . param blockSize Neighborhood size (see the details on <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a1335f3e60433b7ca5fe59fca8afbe3">cornerEigenValsAndVecs</a> ). param ksize Aperture parameter for the Sobel operator. </p>

</div>
</div>
<a id="a18f193db7694dd3b9e7a66dfbc9e8ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f193db7694dd3b9e7a66dfbc9e8ece">&#9670;&nbsp;</a></span>cornerMinEigenVal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerMinEigenVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the minimal eigenvalue of gradient matrices for corner detection.</p>
<p>The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, (\min(\lambda_1, \lambda_2)) in terms of the formulae in the cornerEigenValsAndVecs description.</p>
<p>param src Input single-channel 8-bit or floating-point image. param dst Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src . param blockSize Neighborhood size (see the details on <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a1335f3e60433b7ca5fe59fca8afbe3">cornerEigenValsAndVecs</a> ). </p>

</div>
</div>
<a id="a0e07d6d17eb513d89b93aa1f697fb7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e07d6d17eb513d89b93aa1f697fb7ce">&#9670;&nbsp;</a></span>cornerSubPix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cornerSubPix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>winSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>zeroZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refines the corner locations.</p>
<p>The function iterates to find the sub-pixel accurate location of corners or radial saddle points as described in CITE: forstner1987fast, and as shown on the figure below.</p>
<img src="pics/cornersubpix.png" alt="image" class="inline"/>
<p>Sub-pixel accurate corner locator is based on the observation that every vector from the center (q) to a point (p) located within a neighborhood of (q) is orthogonal to the image gradient at (p) subject to image and measurement noise. Consider the expression:</p>
<p>(\epsilon <em>i = {DI</em>{p_i}}^T \cdot (q - p_i))</p>
<p>where ({DI_{p_i}}) is an image gradient at one of the points (p_i) in a neighborhood of (q) . The value of (q) is to be found so that (\epsilon_i) is minimized. A system of equations may be set up with (\epsilon_i) set to zero:</p>
<p>(\sum <em>i(DI</em>{p_i} \cdot {DI_{p_i}}^T) \cdot q - \sum <em>i(DI</em>{p_i} \cdot {DI_{p_i}}^T \cdot p_i))</p>
<p>where the gradients are summed within a neighborhood ("search window") of (q) . Calling the first gradient term (G) and the second gradient term (b) gives:</p>
<p>(q = G^{-1} \cdot b)</p>
<p>The algorithm sets the center of the neighborhood window at this new center (q) and then iterates until the center stays within a set threshold.</p>
<p>param image Input single-channel, 8-bit or float image. param corners Initial coordinates of the input corners and refined coordinates provided for output. param winSize Half of the side length of the search window. For example, if winSize=Size(5,5) , then a ((5*2+1) \times (5*2+1) = 11 \times 11) search window is used. param zeroZone Half of the size of the dead region in the middle of the search zone over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size. param criteria Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after criteria.maxCount iterations or when the corner position moves by less than criteria.epsilon on some iteration. </p>

</div>
</div>
<a id="ad12298839f3019c429952194b08597aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12298839f3019c429952194b08597aa">&#9670;&nbsp;</a></span>createCLAHE() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_c_l_a_h_e.html">CLAHE</a> OpenCVForUnity.ImgprocModule.Imgproc.createCLAHE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>clipLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>tileGridSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a cv::CLAHE class and initializes it.</p>
<p>param clipLimit Threshold for contrast limiting. param tileGridSize Size of grid for histogram equalization. Input image will be divided into equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column. return automatically generated </p>

</div>
</div>
<a id="a6a3483c65bba4f0a96be8d804475b40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3483c65bba4f0a96be8d804475b40c">&#9670;&nbsp;</a></span>createCLAHE() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_c_l_a_h_e.html">CLAHE</a> OpenCVForUnity.ImgprocModule.Imgproc.createCLAHE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>clipLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a cv::CLAHE class and initializes it.</p>
<p>param clipLimit Threshold for contrast limiting. equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column. return automatically generated </p>

</div>
</div>
<a id="a539692a77803a007b6870352d37965cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539692a77803a007b6870352d37965cb">&#9670;&nbsp;</a></span>createCLAHE() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_c_l_a_h_e.html">CLAHE</a> OpenCVForUnity.ImgprocModule.Imgproc.createCLAHE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a cv::CLAHE class and initializes it.</p>
<p>equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column. return automatically generated </p>

</div>
</div>
<a id="a6a20ee191b2e601730ddb7360bf9f14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a20ee191b2e601730ddb7360bf9f14f">&#9670;&nbsp;</a></span>createGeneralizedHoughBallard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_generalized_hough_ballard.html">GeneralizedHoughBallard</a> OpenCVForUnity.ImgprocModule.Imgproc.createGeneralizedHoughBallard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a cv::GeneralizedHoughBallard class and initializes it. return automatically generated </p>

</div>
</div>
<a id="a7954c7637c07fbb812a9457aa7f79714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7954c7637c07fbb812a9457aa7f79714">&#9670;&nbsp;</a></span>createGeneralizedHoughGuil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_generalized_hough_guil.html">GeneralizedHoughGuil</a> OpenCVForUnity.ImgprocModule.Imgproc.createGeneralizedHoughGuil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a cv::GeneralizedHoughGuil class and initializes it. return automatically generated </p>

</div>
</div>
<a id="a2bfbb62171548daeca05ae48d3438ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfbb62171548daeca05ae48d3438ec3">&#9670;&nbsp;</a></span>createHanningWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.createHanningWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>winSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes a Hanning window coefficients in two dimensions.</p>
<p>See (<a href="http://en.wikipedia.org/wiki/Hann_function">http://en.wikipedia.org/wiki/Hann_function</a>) and (<a href="http://en.wikipedia.org/wiki/Window_function">http://en.wikipedia.org/wiki/Window_function</a>) for more information.</p>
<p>An example is shown below: <code> // create hanning window of size 100x100 and type CV_32F Mat hann; createHanningWindow(hann, Size(100, 100), CV_32F); </code> param dst Destination array to place Hann coefficients in param winSize The window size specifications (both width and height must be &gt; 1) param type Created array type </p>

</div>
</div>
<a id="a640a6005bb032caaa7a1f501d19690f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640a6005bb032caaa7a1f501d19690f1">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_sigma_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_quant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_ang_th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_log_eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_density_th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_n_bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes param _scale The scale of the image that will be used to find the lines. Range (0..1]. param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale. param _quant Bound to the quantization error on the gradient norm. param _ang_th Gradient angle tolerance in degrees. param _log_eps Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen. param _density_th Minimal density of aligned region points in the enclosing rectangle. param _n_bins Number of bins in pseudo-ordering of gradient modulus.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="ac1241a1de292e9ff7a80d6576f57553f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1241a1de292e9ff7a80d6576f57553f">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_sigma_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_quant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_ang_th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_log_eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_density_th</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes param _scale The scale of the image that will be used to find the lines. Range (0..1]. param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale. param _quant Bound to the quantization error on the gradient norm. param _ang_th Gradient angle tolerance in degrees. param _log_eps Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen. param _density_th Minimal density of aligned region points in the enclosing rectangle.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="a8164875fd42543ec51c68daa7323c9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8164875fd42543ec51c68daa7323c9fe">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_sigma_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_quant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_ang_th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_log_eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes param _scale The scale of the image that will be used to find the lines. Range (0..1]. param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale. param _quant Bound to the quantization error on the gradient norm. param _ang_th Gradient angle tolerance in degrees. param _log_eps Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="aff860cb81c090c94b04aeadc25bea6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff860cb81c090c94b04aeadc25bea6ae">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_sigma_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_quant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_ang_th</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes param _scale The scale of the image that will be used to find the lines. Range (0..1]. param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale. param _quant Bound to the quantization error on the gradient norm. param _ang_th Gradient angle tolerance in degrees. is chosen.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="a736c99b21e365c10676b216ee427d1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736c99b21e365c10676b216ee427d1c0">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_sigma_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_quant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes param _scale The scale of the image that will be used to find the lines. Range (0..1]. param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale. param _quant Bound to the quantization error on the gradient norm. is chosen.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="ad685393e129a061cc0130b0e329e25d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad685393e129a061cc0130b0e329e25d6">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_sigma_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes param _scale The scale of the image that will be used to find the lines. Range (0..1]. param _sigma_scale Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale. is chosen.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="a96cdc042e2d3e231b60fbe115a5c34c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cdc042e2d3e231b60fbe115a5c34c5">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes param _scale The scale of the image that will be used to find the lines. Range (0..1]. is chosen.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="ad4f36a6af6deca550a1b5fca7ba7cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f36a6af6deca550a1b5fca7ba7cc70">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>param _refine The way found lines will be refined, see #LineSegmentDetectorModes is chosen.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="abfa79220da2d281486430939a0ca2421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa79220da2d281486430939a0ca2421">&#9670;&nbsp;</a></span>createLineSegmentDetector() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> OpenCVForUnity.ImgprocModule.Imgproc.createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer to a <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> object and initializes it.</p>
<p>The <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<p>is chosen.</p>
<p><b>Note:</b> Implementation has been removed due original code license conflict return automatically generated </p>

</div>
</div>
<a id="ab5eb47c7f4f3a5faff238c3dc8a8a9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eb47c7f4f3a5faff238c3dc8a8a9e2">&#9670;&nbsp;</a></span>cvtColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cvtColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstCn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an image from one color space to another.</p>
<p>The function converts an input image from one color space to another. In case of a transformation to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.</p>
<p>The conventional ranges for R, G, and B channel values are: </p><ul>
<li>
0 to 255 for CV_8U images  </li>
<li>
0 to 65535 for CV_16U images  </li>
<li>
0 to 1 for CV_32F images  </li>
</ul>
<p>In case of linear transformations, the range does not matter. But in case of a non-linear transformation, an input RGB image should be normalized to the proper value range to get the correct results, for example, for RGB (\rightarrow) L*u*v* transformation. For example, if you have a 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5eb47c7f4f3a5faff238c3dc8a8a9e2">cvtColor</a> , you need first to scale the image down: <code> img *= 1./255; cvtColor(img, img, COLOR_BGR2Luv); </code> If you use <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5eb47c7f4f3a5faff238c3dc8a8a9e2">cvtColor</a> with 8-bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-bit images in applications that need the full range of colors or that convert an image before an operation and then convert back.</p>
<p>If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.</p>
<p>param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision floating-point. param dst output image of the same size and depth as src. param code color space conversion code (see #ColorConversionCodes). param dstCn number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code.</p>
<p>SEE: REF: imgproc_color_conversions </p>

</div>
</div>
<a id="aa6085870b4e8f1ecd8a68329c1008873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6085870b4e8f1ecd8a68329c1008873">&#9670;&nbsp;</a></span>cvtColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cvtColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an image from one color space to another.</p>
<p>The function converts an input image from one color space to another. In case of a transformation to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.</p>
<p>The conventional ranges for R, G, and B channel values are: </p><ul>
<li>
0 to 255 for CV_8U images  </li>
<li>
0 to 65535 for CV_16U images  </li>
<li>
0 to 1 for CV_32F images  </li>
</ul>
<p>In case of linear transformations, the range does not matter. But in case of a non-linear transformation, an input RGB image should be normalized to the proper value range to get the correct results, for example, for RGB (\rightarrow) L*u*v* transformation. For example, if you have a 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5eb47c7f4f3a5faff238c3dc8a8a9e2">cvtColor</a> , you need first to scale the image down: <code> img *= 1./255; cvtColor(img, img, COLOR_BGR2Luv); </code> If you use <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5eb47c7f4f3a5faff238c3dc8a8a9e2">cvtColor</a> with 8-bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-bit images in applications that need the full range of colors or that convert an image before an operation and then convert back.</p>
<p>If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.</p>
<p>param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision floating-point. param dst output image of the same size and depth as src. param code color space conversion code (see #ColorConversionCodes). channels is derived automatically from src and code.</p>
<p>SEE: REF: imgproc_color_conversions </p>

</div>
</div>
<a id="ae6d84345e62f04a96a1da2297123373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d84345e62f04a96a1da2297123373b">&#9670;&nbsp;</a></span>cvtColorTwoPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.cvtColorTwoPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an image from one color space to another where the source image is stored in two planes.</p>
<p>This function only supports YUV420 to RGB conversion as of now.</p>
<ul>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6052068d3a23fe539b125c621625dc3b">COLOR_YUV2BGR_NV12</a>  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6fe1e59f1952e60d8318013b75ddd70a">COLOR_YUV2RGB_NV12</a>  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a714d5a4820517a9e0a55d6eb9c5bef82">COLOR_YUV2BGRA_NV12</a>  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8da07108887c111ebdab4f2a643e874b">COLOR_YUV2RGBA_NV12</a>  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad006f0f6c1c38ad4bbb0d13979aaddcc">COLOR_YUV2BGR_NV21</a>  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af931b245acb983ace37bdecd6b9d036a">COLOR_YUV2RGB_NV21</a>  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9c6d9728436a595824c4fc203bab2bdb">COLOR_YUV2BGRA_NV21</a>  </li>
<li>
<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab6ee5d8a713ea844b27f4e6d924830e2">COLOR_YUV2RGBA_NV21</a>  </li>
</ul>
<p>param src1 automatically generated param src2 automatically generated param dst automatically generated param code automatically generated </p>

</div>
</div>
<a id="a8fd6b27e9616dec9b61b3f8e06f92644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd6b27e9616dec9b61b3f8e06f92644">&#9670;&nbsp;</a></span>demosaicing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.demosaicing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstCn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>main function for all demosaicing processes</p>
<p>param src input image: 8-bit unsigned or 16-bit unsigned. param dst output image of the same size and depth as src. param code Color space conversion code (see the description below). param dstCn number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code.</p>
<p>The function can do the following transformations:</p>
<ul>
<li>
Demosaicing using bilinear interpolation  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR

#COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY
</pre><ul>
<li>
Demosaicing using Variable Number of Gradients.  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG
</pre><ul>
<li>
Edge-Aware Demosaicing.  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA
</pre><ul>
<li>
Demosaicing with alpha channel  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA
</pre><p>SEE: cvtColor </p>

</div>
</div>
<a id="a99b902a939f86b6e5dfa5c081ff2093f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b902a939f86b6e5dfa5c081ff2093f">&#9670;&nbsp;</a></span>demosaicing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.demosaicing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>main function for all demosaicing processes</p>
<p>param src input image: 8-bit unsigned or 16-bit unsigned. param dst output image of the same size and depth as src. param code Color space conversion code (see the description below). channels is derived automatically from src and code.</p>
<p>The function can do the following transformations:</p>
<ul>
<li>
Demosaicing using bilinear interpolation  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR

#COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY
</pre><ul>
<li>
Demosaicing using Variable Number of Gradients.  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG
</pre><ul>
<li>
Edge-Aware Demosaicing.  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA
</pre><ul>
<li>
Demosaicing with alpha channel  </li>
</ul>
<pre class="fragment">#COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA
</pre><p>SEE: cvtColor </p>

</div>
</div>
<a id="a8132a3a849ddc6e08c26e46a74c2666d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8132a3a849ddc6e08c26e46a74c2666d">&#9670;&nbsp;</a></span>dilate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.dilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>borderValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dilates an image by using a specific structuring element.</p>
<p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: (\texttt{dst} (x,y) = \max _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a> param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. param iterations number of times dilation is applied. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported. param borderValue border value in case of a constant border SEE: erode, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="a0089380bc0cf435f41d8bad067135b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0089380bc0cf435f41d8bad067135b65">&#9670;&nbsp;</a></span>dilate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.dilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dilates an image by using a specific structuring element.</p>
<p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: (\texttt{dst} (x,y) = \max _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a> param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. param iterations number of times dilation is applied. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported. SEE: erode, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="af020278c9a054565cc3fc484b13d8e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af020278c9a054565cc3fc484b13d8e48">&#9670;&nbsp;</a></span>dilate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.dilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dilates an image by using a specific structuring element.</p>
<p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: (\texttt{dst} (x,y) = \max _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a> param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. param iterations number of times dilation is applied. SEE: erode, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="a6f44c23079faa93e660a5873f1f1859d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f44c23079faa93e660a5873f1f1859d">&#9670;&nbsp;</a></span>dilate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.dilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dilates an image by using a specific structuring element.</p>
<p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: (\texttt{dst} (x,y) = \max _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a> param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. SEE: erode, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="a8b0fd81f42025984ecfb5d6197dcd21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0fd81f42025984ecfb5d6197dcd21f">&#9670;&nbsp;</a></span>dilate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.dilate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dilates an image by using a specific structuring element.</p>
<p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: (\texttt{dst} (x,y) = \max _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a> anchor is at the element center. SEE: erode, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="a40a9a15337aebe89ae8eeca9b73e0d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a9a15337aebe89ae8eeca9b73e0d46">&#9670;&nbsp;</a></span>distanceTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.distanceTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maskSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param src 8-bit, single-channel (binary) source image. param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src . param distanceType Type of distance, see #DistanceTypes param maskSize Size of the distance transform mask, see #DistanceTransformMasks. In case of the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af53efa51944b46f35adfc5e8fcd98239">DIST_C</a> distance type, the parameter is forced to 3 because a (3\times 3) mask gives the same result as (5\times 5) or any larger aperture. param dstType Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for the first variant of the function and distanceType == <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a>. </p>

</div>
</div>
<a id="abb1d292af1f4d8af72b861826d47dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1d292af1f4d8af72b861826d47dc4c">&#9670;&nbsp;</a></span>distanceTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.distanceTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maskSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param src 8-bit, single-channel (binary) source image. param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src . param distanceType Type of distance, see #DistanceTypes param maskSize Size of the distance transform mask, see #DistanceTransformMasks. In case of the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af53efa51944b46f35adfc5e8fcd98239">DIST_C</a> distance type, the parameter is forced to 3 because a (3\times 3) mask gives the same result as (5\times 5) or any larger aperture. the first variant of the function and distanceType == <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a>. </p>

</div>
</div>
<a id="a4fb5667cefbe98eeef9dff4b1c00181b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb5667cefbe98eeef9dff4b1c00181b">&#9670;&nbsp;</a></span>distanceTransformWithLabels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.distanceTransformWithLabels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maskSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>labelType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the distance to the closest zero pixel for each pixel of the source image.</p>
<p>The function cv::distanceTransform calculates the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.</p>
<p>When maskSize == <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bef27846422c2eaf1ddadf0f3a8f1fc">DIST_MASK_PRECISE</a> and distanceType == <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a> , the function runs the algorithm described in CITE: Felzenszwalb04 . This algorithm is parallelized with the TBB library.</p>
<p>In other cases, the algorithm CITE: Borgefors86 is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical, diagonal, or knight's move (the latest is available for a (5\times 5) mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all the diagonal shifts must have the same cost (denoted as {code b}), and all knight's moves must have the same cost (denoted as {code c}). For the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af53efa51944b46f35adfc5e8fcd98239">DIST_C</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a> types, the distance is calculated precisely, whereas for <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a> (Euclidean distance) the distance can be calculated only with a relative error (a (5\times 5) mask gives more accurate results). For {code a},{code b}, and {code c}, OpenCV uses the values suggested in the original paper: </p><ul>
<li>
DIST_L1: {code a = 1, b = 2}  </li>
<li>
DIST_L2: <ul>
<li>
{code 3 x 3}: {code a=0.955, b=1.3693}  </li>
<li>
{code 5 x 5}: {code a=1, b=1.4, c=2.1969}  </li>
</ul>
</li>
<li>
DIST_C: {code a = 1, b = 1}  </li>
</ul>
<p>Typically, for a fast, coarse distance estimation <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a>, a (3\times 3) mask is used. For a more accurate distance estimation <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a>, a (5\times 5) mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels.</p>
<p>This variant of the function does not only compute the minimum distance for each pixel ((x, y)) but also identifies the nearest connected component consisting of zero pixels (labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bf1162f90c793f443e484c8b15b7503">DIST_LABEL_CCOMP</a>) or the nearest zero pixel (labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4c35a92d0283d14951426c724eb07d9a">DIST_LABEL_PIXEL</a>). Index of the component/pixel is stored in {code labels(x, y)}. When labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bf1162f90c793f443e484c8b15b7503">DIST_LABEL_CCOMP</a>, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bf1162f90c793f443e484c8b15b7503">DIST_LABEL_CCOMP</a>, the function scans through the input image and marks all the zero pixels with distinct labels.</p>
<p>In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.e. maskSize=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bef27846422c2eaf1ddadf0f3a8f1fc">DIST_MASK_PRECISE</a> is not supported yet.</p>
<p>param src 8-bit, single-channel (binary) source image. param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src. param labels Output 2D array of labels (the discrete Voronoi diagram). It has the type CV_32SC1 and the same size as src. param distanceType Type of distance, see #DistanceTypes param maskSize Size of the distance transform mask, see #DistanceTransformMasks. <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bef27846422c2eaf1ddadf0f3a8f1fc">DIST_MASK_PRECISE</a> is not supported by this variant. In case of the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af53efa51944b46f35adfc5e8fcd98239">DIST_C</a> distance type, the parameter is forced to 3 because a (3\times 3) mask gives the same result as (5\times 5) or any larger aperture. param labelType Type of the label array to build, see #DistanceTransformLabelTypes. </p>

</div>
</div>
<a id="a2c64db4e1532b13547cef3bf4c9f407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c64db4e1532b13547cef3bf4c9f407e">&#9670;&nbsp;</a></span>distanceTransformWithLabels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.distanceTransformWithLabels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distanceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maskSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the distance to the closest zero pixel for each pixel of the source image.</p>
<p>The function cv::distanceTransform calculates the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.</p>
<p>When maskSize == <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bef27846422c2eaf1ddadf0f3a8f1fc">DIST_MASK_PRECISE</a> and distanceType == <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a> , the function runs the algorithm described in CITE: Felzenszwalb04 . This algorithm is parallelized with the TBB library.</p>
<p>In other cases, the algorithm CITE: Borgefors86 is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical, diagonal, or knight's move (the latest is available for a (5\times 5) mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all the diagonal shifts must have the same cost (denoted as {code b}), and all knight's moves must have the same cost (denoted as {code c}). For the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af53efa51944b46f35adfc5e8fcd98239">DIST_C</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a> types, the distance is calculated precisely, whereas for <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a> (Euclidean distance) the distance can be calculated only with a relative error (a (5\times 5) mask gives more accurate results). For {code a},{code b}, and {code c}, OpenCV uses the values suggested in the original paper: </p><ul>
<li>
DIST_L1: {code a = 1, b = 2}  </li>
<li>
DIST_L2: <ul>
<li>
{code 3 x 3}: {code a=0.955, b=1.3693}  </li>
<li>
{code 5 x 5}: {code a=1, b=1.4, c=2.1969}  </li>
</ul>
</li>
<li>
DIST_C: {code a = 1, b = 1}  </li>
</ul>
<p>Typically, for a fast, coarse distance estimation <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a>, a (3\times 3) mask is used. For a more accurate distance estimation <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79f924e45d33bd7e53b2750de0d726b9">DIST_L2</a>, a (5\times 5) mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels.</p>
<p>This variant of the function does not only compute the minimum distance for each pixel ((x, y)) but also identifies the nearest connected component consisting of zero pixels (labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bf1162f90c793f443e484c8b15b7503">DIST_LABEL_CCOMP</a>) or the nearest zero pixel (labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4c35a92d0283d14951426c724eb07d9a">DIST_LABEL_PIXEL</a>). Index of the component/pixel is stored in {code labels(x, y)}. When labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bf1162f90c793f443e484c8b15b7503">DIST_LABEL_CCOMP</a>, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When labelType==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bf1162f90c793f443e484c8b15b7503">DIST_LABEL_CCOMP</a>, the function scans through the input image and marks all the zero pixels with distinct labels.</p>
<p>In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.e. maskSize=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bef27846422c2eaf1ddadf0f3a8f1fc">DIST_MASK_PRECISE</a> is not supported yet.</p>
<p>param src 8-bit, single-channel (binary) source image. param dst Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src. param labels Output 2D array of labels (the discrete Voronoi diagram). It has the type CV_32SC1 and the same size as src. param distanceType Type of distance, see #DistanceTypes param maskSize Size of the distance transform mask, see #DistanceTransformMasks. <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2bef27846422c2eaf1ddadf0f3a8f1fc">DIST_MASK_PRECISE</a> is not supported by this variant. In case of the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a70bb7cb6ad4718189a1a0e21301db0f9">DIST_L1</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af53efa51944b46f35adfc5e8fcd98239">DIST_C</a> distance type, the parameter is forced to 3 because a (3\times 3) mask gives the same result as (5\times 5) or any larger aperture. </p>

</div>
</div>
<a id="a598a742bf4f67b16ea1094a000a0646a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a742bf4f67b16ea1094a000a0646a">&#9670;&nbsp;</a></span>drawContours() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contourIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws contours outlines or filled contours.</p>
<p>The function draws contour outlines in the image if (\texttt{thickness} \ge 0) or fills the area bounded by the contours if (\texttt{thickness}&lt;0) . The example below shows how to retrieve connected components from the binary image and label them: : INCLUDE: snippets/imgproc_drawContours.cpp</p>
<p>param image Destination image. param contours All the input contours. Each contour is stored as a point vector. param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn. param color Color of the contours. param thickness Thickness of lines the contours are drawn with. If it is negative (for example, thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a> ), the contour interiors are drawn. param lineType Line connectivity. See #LineTypes param hierarchy Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see maxLevel ). param maxLevel Maximal level for drawn contours. If it is 0, only the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. param offset Optional contour shift parameter. Shift all the drawn contours by the specified (\texttt{offset}=(dx,dy)) . <b>Note:</b> When thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, the function is designed to handle connected components with holes correctly even when no hierarchy date is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. </p>

</div>
</div>
<a id="a26ee9de2d58e5a4619ade8811e77954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ee9de2d58e5a4619ade8811e77954b">&#9670;&nbsp;</a></span>drawContours() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contourIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws contours outlines or filled contours.</p>
<p>The function draws contour outlines in the image if (\texttt{thickness} \ge 0) or fills the area bounded by the contours if (\texttt{thickness}&lt;0) . The example below shows how to retrieve connected components from the binary image and label them: : INCLUDE: snippets/imgproc_drawContours.cpp</p>
<p>param image Destination image. param contours All the input contours. Each contour is stored as a point vector. param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn. param color Color of the contours. param thickness Thickness of lines the contours are drawn with. If it is negative (for example, thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a> ), the contour interiors are drawn. param lineType Line connectivity. See #LineTypes param hierarchy Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see maxLevel ). param maxLevel Maximal level for drawn contours. If it is 0, only the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. (\texttt{offset}=(dx,dy)) . <b>Note:</b> When thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, the function is designed to handle connected components with holes correctly even when no hierarchy date is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. </p>

</div>
</div>
<a id="afd67e0986a2b308f9e488e6d09799c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd67e0986a2b308f9e488e6d09799c8a">&#9670;&nbsp;</a></span>drawContours() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contourIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hierarchy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws contours outlines or filled contours.</p>
<p>The function draws contour outlines in the image if (\texttt{thickness} \ge 0) or fills the area bounded by the contours if (\texttt{thickness}&lt;0) . The example below shows how to retrieve connected components from the binary image and label them: : INCLUDE: snippets/imgproc_drawContours.cpp</p>
<p>param image Destination image. param contours All the input contours. Each contour is stored as a point vector. param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn. param color Color of the contours. param thickness Thickness of lines the contours are drawn with. If it is negative (for example, thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a> ), the contour interiors are drawn. param lineType Line connectivity. See #LineTypes param hierarchy Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see maxLevel ). If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. (\texttt{offset}=(dx,dy)) . <b>Note:</b> When thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, the function is designed to handle connected components with holes correctly even when no hierarchy date is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. </p>

</div>
</div>
<a id="a4a7c77135ed8e55bb5acfebe5a3b0fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7c77135ed8e55bb5acfebe5a3b0fa3">&#9670;&nbsp;</a></span>drawContours() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contourIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws contours outlines or filled contours.</p>
<p>The function draws contour outlines in the image if (\texttt{thickness} \ge 0) or fills the area bounded by the contours if (\texttt{thickness}&lt;0) . The example below shows how to retrieve connected components from the binary image and label them: : INCLUDE: snippets/imgproc_drawContours.cpp</p>
<p>param image Destination image. param contours All the input contours. Each contour is stored as a point vector. param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn. param color Color of the contours. param thickness Thickness of lines the contours are drawn with. If it is negative (for example, thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a> ), the contour interiors are drawn. param lineType Line connectivity. See #LineTypes some of the contours (see maxLevel ). If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. (\texttt{offset}=(dx,dy)) . <b>Note:</b> When thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, the function is designed to handle connected components with holes correctly even when no hierarchy date is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. </p>

</div>
</div>
<a id="a35c1427e91203acf0fa0b45f6d292592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c1427e91203acf0fa0b45f6d292592">&#9670;&nbsp;</a></span>drawContours() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contourIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws contours outlines or filled contours.</p>
<p>The function draws contour outlines in the image if (\texttt{thickness} \ge 0) or fills the area bounded by the contours if (\texttt{thickness}&lt;0) . The example below shows how to retrieve connected components from the binary image and label them: : INCLUDE: snippets/imgproc_drawContours.cpp</p>
<p>param image Destination image. param contours All the input contours. Each contour is stored as a point vector. param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn. param color Color of the contours. param thickness Thickness of lines the contours are drawn with. If it is negative (for example, thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a> ), the contour interiors are drawn. some of the contours (see maxLevel ). If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. (\texttt{offset}=(dx,dy)) . <b>Note:</b> When thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, the function is designed to handle connected components with holes correctly even when no hierarchy date is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. </p>

</div>
</div>
<a id="a852ee36feb791f6749db1fe6c6b24d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852ee36feb791f6749db1fe6c6b24d76">&#9670;&nbsp;</a></span>drawContours() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contourIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws contours outlines or filled contours.</p>
<p>The function draws contour outlines in the image if (\texttt{thickness} \ge 0) or fills the area bounded by the contours if (\texttt{thickness}&lt;0) . The example below shows how to retrieve connected components from the binary image and label them: : INCLUDE: snippets/imgproc_drawContours.cpp</p>
<p>param image Destination image. param contours All the input contours. Each contour is stored as a point vector. param contourIdx Parameter indicating a contour to draw. If it is negative, all the contours are drawn. param color Color of the contours. thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a> ), the contour interiors are drawn. some of the contours (see maxLevel ). If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available. (\texttt{offset}=(dx,dy)) . <b>Note:</b> When thickness=<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, the function is designed to handle connected components with holes correctly even when no hierarchy date is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> separately for each sub-group of contours, or iterate over the collection using contourIdx parameter. </p>

</div>
</div>
<a id="a906fcc9d312c55df41ececf0ddde7cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906fcc9d312c55df41ececf0ddde7cd3">&#9670;&nbsp;</a></span>drawMarker() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a marker on a predefined position in an image.</p>
<p>The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information.</p>
<p>param img Image. param position The point where the crosshair is positioned. param color Line color. param markerType The specific type of marker you want to use, see #MarkerTypes param thickness Line thickness. param line_type Type of the line, See #LineTypes param markerSize The length of the marker axis [default = 20 pixels] </p>

</div>
</div>
<a id="a615f2945468d056c87b3bc5e798a5b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615f2945468d056c87b3bc5e798a5b1b">&#9670;&nbsp;</a></span>drawMarker() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a marker on a predefined position in an image.</p>
<p>The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information.</p>
<p>param img Image. param position The point where the crosshair is positioned. param color Line color. param markerType The specific type of marker you want to use, see #MarkerTypes param thickness Line thickness. param markerSize The length of the marker axis [default = 20 pixels] </p>

</div>
</div>
<a id="aea11fa46912c8a695750400bb440fc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea11fa46912c8a695750400bb440fc72">&#9670;&nbsp;</a></span>drawMarker() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a marker on a predefined position in an image.</p>
<p>The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information.</p>
<p>param img Image. param position The point where the crosshair is positioned. param color Line color. param markerType The specific type of marker you want to use, see #MarkerTypes param markerSize The length of the marker axis [default = 20 pixels] </p>

</div>
</div>
<a id="a710b399600cfb48606f6cedae8316c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710b399600cfb48606f6cedae8316c61">&#9670;&nbsp;</a></span>drawMarker() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>markerType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a marker on a predefined position in an image.</p>
<p>The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information.</p>
<p>param img Image. param position The point where the crosshair is positioned. param color Line color. param markerType The specific type of marker you want to use, see #MarkerTypes </p>

</div>
</div>
<a id="a9801a5338095e635c014fba39cf95787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9801a5338095e635c014fba39cf95787">&#9670;&nbsp;</a></span>drawMarker() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.drawMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a marker on a predefined position in an image.</p>
<p>The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information.</p>
<p>param img Image. param position The point where the crosshair is positioned. param color Line color. </p>

</div>
</div>
<a id="ab3c8e6a68c31eeb83e710a22e808a3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c8e6a68c31eeb83e710a22e808a3f3">&#9670;&nbsp;</a></span>ellipse() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>
<p>The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a7a872c1660203e992237241a1f76c7">ellipse2Poly</a> and then render it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac98ed9aaf79864022c2b3d7fa2f5648c">polylines</a> or fill it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a>. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {code startAngle=0} and {code endAngle=360}. If {code startAngle} is greater than {code endAngle}, they are swapped. The figure below explains the meaning of the parameters to draw the blue arc.</p>
<object type="image/svg+xml" data="pics/ellipse.svg" alt="Parameters of Elliptic Arc"></object>
/>
<p>param img Image. param center Center of the ellipse. param axes Half of the size of the ellipse main axes. param angle Ellipse rotation angle in degrees. param startAngle Starting angle of the elliptic arc in degrees. param endAngle Ending angle of the elliptic arc in degrees. param color Ellipse color. param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. param lineType Type of the ellipse boundary. See #LineTypes param shift Number of fractional bits in the coordinates of the center and values of axes. </p>

</div>
</div>
<a id="a233d52dc944bca38b23167ba376a484d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233d52dc944bca38b23167ba376a484d">&#9670;&nbsp;</a></span>ellipse() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>
<p>The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a7a872c1660203e992237241a1f76c7">ellipse2Poly</a> and then render it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac98ed9aaf79864022c2b3d7fa2f5648c">polylines</a> or fill it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a>. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {code startAngle=0} and {code endAngle=360}. If {code startAngle} is greater than {code endAngle}, they are swapped. The figure below explains the meaning of the parameters to draw the blue arc.</p>
<object type="image/svg+xml" data="pics/ellipse.svg" alt="Parameters of Elliptic Arc"></object>
/>
<p>param img Image. param center Center of the ellipse. param axes Half of the size of the ellipse main axes. param angle Ellipse rotation angle in degrees. param startAngle Starting angle of the elliptic arc in degrees. param endAngle Ending angle of the elliptic arc in degrees. param color Ellipse color. param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. param lineType Type of the ellipse boundary. See #LineTypes </p>

</div>
</div>
<a id="a1f590e8200e98d7ad793c625a9c0686f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f590e8200e98d7ad793c625a9c0686f">&#9670;&nbsp;</a></span>ellipse() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>
<p>The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a7a872c1660203e992237241a1f76c7">ellipse2Poly</a> and then render it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac98ed9aaf79864022c2b3d7fa2f5648c">polylines</a> or fill it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a>. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {code startAngle=0} and {code endAngle=360}. If {code startAngle} is greater than {code endAngle}, they are swapped. The figure below explains the meaning of the parameters to draw the blue arc.</p>
<object type="image/svg+xml" data="pics/ellipse.svg" alt="Parameters of Elliptic Arc"></object>
/>
<p>param img Image. param center Center of the ellipse. param axes Half of the size of the ellipse main axes. param angle Ellipse rotation angle in degrees. param startAngle Starting angle of the elliptic arc in degrees. param endAngle Ending angle of the elliptic arc in degrees. param color Ellipse color. param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. </p>

</div>
</div>
<a id="a21725f465a2d1db4857038253431d90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21725f465a2d1db4857038253431d90a">&#9670;&nbsp;</a></span>ellipse() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>
<p>The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a7a872c1660203e992237241a1f76c7">ellipse2Poly</a> and then render it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ac98ed9aaf79864022c2b3d7fa2f5648c">polylines</a> or fill it with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a>. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {code startAngle=0} and {code endAngle=360}. If {code startAngle} is greater than {code endAngle}, they are swapped. The figure below explains the meaning of the parameters to draw the blue arc.</p>
<object type="image/svg+xml" data="pics/ellipse.svg" alt="Parameters of Elliptic Arc"></object>
/>
<p>param img Image. param center Center of the ellipse. param axes Half of the size of the ellipse main axes. param angle Ellipse rotation angle in degrees. param startAngle Starting angle of the elliptic arc in degrees. param endAngle Ending angle of the elliptic arc in degrees. param color Ellipse color. a filled ellipse sector is to be drawn. </p>

</div>
</div>
<a id="a09c6f8e7069cc4ed3b4f40497e6a320c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c6f8e7069cc4ed3b4f40497e6a320c">&#9670;&nbsp;</a></span>ellipse() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param img Image. param box Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle. param color Ellipse color. param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. param lineType Type of the ellipse boundary. See #LineTypes </p>

</div>
</div>
<a id="ab1a17033ab94731170443aa02e40e2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a17033ab94731170443aa02e40e2b6">&#9670;&nbsp;</a></span>ellipse() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param img Image. param box Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle. param color Ellipse color. param thickness Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. </p>

</div>
</div>
<a id="a1813fadcecde7e54fa97259b37efdc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1813fadcecde7e54fa97259b37efdc7f">&#9670;&nbsp;</a></span>ellipse() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>param img Image. param box Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle. param color Ellipse color. a filled ellipse sector is to be drawn. </p>

</div>
</div>
<a id="a8a7a872c1660203e992237241a1f76c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7a872c1660203e992237241a1f76c7">&#9670;&nbsp;</a></span>ellipse2Poly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.ellipse2Poly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Approximates an elliptic arc with a polyline.</p>
<p>The function ellipse2Poly computes the vertices of a polyline that approximates the specified elliptic arc. It is used by <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab3c8e6a68c31eeb83e710a22e808a3f3">ellipse</a>. If {code arcStart} is greater than {code arcEnd}, they are swapped.</p>
<p>param center Center of the arc. param axes Half of the size of the ellipse main axes. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab3c8e6a68c31eeb83e710a22e808a3f3">ellipse</a> for details. param angle Rotation angle of the ellipse in degrees. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab3c8e6a68c31eeb83e710a22e808a3f3">ellipse</a> for details. param arcStart Starting angle of the elliptic arc in degrees. param arcEnd Ending angle of the elliptic arc in degrees. param delta Angle between the subsequent polyline vertices. It defines the approximation accuracy. param pts Output vector of polyline vertices. </p>

</div>
</div>
<a id="a12c66029d7932044689e7be343d9c9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c66029d7932044689e7be343d9c9f0">&#9670;&nbsp;</a></span>EMD() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float OpenCVForUnity.ImgprocModule.Imgproc.EMD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>signature1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>signature2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the "minimal work" distance between two weighted point configurations.</p>
<p>The function computes the earth mover distance and/or a lower boundary of the distance between the two weighted point configurations. One of the applications described in CITE: RubnerSept98, CITE: Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation problem that is solved using some modification of a simplex algorithm, thus the complexity is exponential in the worst case, though, on average it is much faster. In the case of a real metric the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used to determine roughly whether the two signatures are far enough so that they cannot relate to the same object.</p>
<p>param signature1 First signature, a (\texttt{size1}\times \texttt{dims}+1) floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used. The weights must be non-negative and have at least one non-zero value. param signature2 Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra "dummy" point is added to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value. param distType Used metric. See #DistanceTypes. param cost User-defined (\texttt{size1}\times \texttt{size2}) cost matrix. Also, if a cost matrix is used, lower boundary lowerBound cannot be calculated because it needs a metric function. signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). You <b>must</b> initialize *lowerBound . If the calculated distance between mass centers is greater or equal to *lowerBound (it means that the signatures are far enough), the function does not calculate EMD. In any case *lowerBound is set to the calculated distance between mass centers on return. Thus, if you want to calculate both distance between mass centers and EMD, *lowerBound should be set to 0. param flow Resultant (\texttt{size1} \times \texttt{size2}) flow matrix: (\texttt{flow}_{i,j}) is a flow from (i) -th point of signature1 to (j) -th point of signature2 . return automatically generated </p>

</div>
</div>
<a id="a0403253123f4ac11f8faa14667e4d479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0403253123f4ac11f8faa14667e4d479">&#9670;&nbsp;</a></span>EMD() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float OpenCVForUnity.ImgprocModule.Imgproc.EMD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>signature1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>signature2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the "minimal work" distance between two weighted point configurations.</p>
<p>The function computes the earth mover distance and/or a lower boundary of the distance between the two weighted point configurations. One of the applications described in CITE: RubnerSept98, CITE: Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation problem that is solved using some modification of a simplex algorithm, thus the complexity is exponential in the worst case, though, on average it is much faster. In the case of a real metric the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used to determine roughly whether the two signatures are far enough so that they cannot relate to the same object.</p>
<p>param signature1 First signature, a (\texttt{size1}\times \texttt{dims}+1) floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used. The weights must be non-negative and have at least one non-zero value. param signature2 Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra "dummy" point is added to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value. param distType Used metric. See #DistanceTypes. param cost User-defined (\texttt{size1}\times \texttt{size2}) cost matrix. Also, if a cost matrix is used, lower boundary lowerBound cannot be calculated because it needs a metric function. signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). You <b>must</b> initialize *lowerBound . If the calculated distance between mass centers is greater or equal to *lowerBound (it means that the signatures are far enough), the function does not calculate EMD. In any case *lowerBound is set to the calculated distance between mass centers on return. Thus, if you want to calculate both distance between mass centers and EMD, *lowerBound should be set to 0. a flow from (i) -th point of signature1 to (j) -th point of signature2 . return automatically generated </p>

</div>
</div>
<a id="a172de0251df42d02cb65f84b502cedeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172de0251df42d02cb65f84b502cedeb">&#9670;&nbsp;</a></span>EMD() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float OpenCVForUnity.ImgprocModule.Imgproc.EMD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>signature1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>signature2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the "minimal work" distance between two weighted point configurations.</p>
<p>The function computes the earth mover distance and/or a lower boundary of the distance between the two weighted point configurations. One of the applications described in CITE: RubnerSept98, CITE: Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation problem that is solved using some modification of a simplex algorithm, thus the complexity is exponential in the worst case, though, on average it is much faster. In the case of a real metric the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used to determine roughly whether the two signatures are far enough so that they cannot relate to the same object.</p>
<p>param signature1 First signature, a (\texttt{size1}\times \texttt{dims}+1) floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used. The weights must be non-negative and have at least one non-zero value. param signature2 Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra "dummy" point is added to either signature1 or signature2. The weights must be non-negative and have at least one non-zero value. param distType Used metric. See #DistanceTypes. is used, lower boundary lowerBound cannot be calculated because it needs a metric function. signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). You <b>must</b> initialize *lowerBound . If the calculated distance between mass centers is greater or equal to *lowerBound (it means that the signatures are far enough), the function does not calculate EMD. In any case *lowerBound is set to the calculated distance between mass centers on return. Thus, if you want to calculate both distance between mass centers and EMD, *lowerBound should be set to 0. a flow from (i) -th point of signature1 to (j) -th point of signature2 . return automatically generated </p>

</div>
</div>
<a id="ad249c9fa6bcde1e21f7ea7c227558987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad249c9fa6bcde1e21f7ea7c227558987">&#9670;&nbsp;</a></span>equalizeHist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.equalizeHist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equalizes the histogram of a grayscale image.</p>
<p>The function equalizes the histogram of the input image using the following algorithm:</p>
<ul>
<li>
Calculate the histogram (H) for src .  </li>
<li>
Normalize the histogram so that the sum of histogram bins is 255.  </li>
<li>
Compute the integral of the histogram: (H'_i = \sum _{0 \le j &lt; i} H(j))  </li>
<li>
Transform the image using (H') as a look-up table: (\texttt{dst}(x,y) = H'(\texttt{src}(x,y)))  </li>
</ul>
<p>The algorithm normalizes the brightness and increases the contrast of the image.</p>
<p>param src Source 8-bit single channel image. param dst Destination image of the same size and type as src . </p>

</div>
</div>
<a id="aec3d8a9c0378980731f7520977a7baeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d8a9c0378980731f7520977a7baeb">&#9670;&nbsp;</a></span>erode() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.erode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>borderValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erodes an image by using a specific structuring element.</p>
<p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<p>(\texttt{dst} (x,y) = \min _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for erosion; if {code element=Mat()}, a {code 3 x 3} rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. param iterations number of times erosion is applied. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. param borderValue border value in case of a constant border SEE: dilate, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="ac2b63bd3af8f276538704bed25bf3e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b63bd3af8f276538704bed25bf3e0d">&#9670;&nbsp;</a></span>erode() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.erode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erodes an image by using a specific structuring element.</p>
<p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<p>(\texttt{dst} (x,y) = \min _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for erosion; if {code element=Mat()}, a {code 3 x 3} rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. param iterations number of times erosion is applied. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. SEE: dilate, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="a5c649ecb1f1977836b1ade1e202fff0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c649ecb1f1977836b1ade1e202fff0f">&#9670;&nbsp;</a></span>erode() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.erode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erodes an image by using a specific structuring element.</p>
<p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<p>(\texttt{dst} (x,y) = \min _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for erosion; if {code element=Mat()}, a {code 3 x 3} rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. param iterations number of times erosion is applied. SEE: dilate, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="aa92e5d5dc06c6074bf1e780b349f4715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92e5d5dc06c6074bf1e780b349f4715">&#9670;&nbsp;</a></span>erode() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.erode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erodes an image by using a specific structuring element.</p>
<p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<p>(\texttt{dst} (x,y) = \min _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for erosion; if {code element=Mat()}, a {code 3 x 3} rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center. SEE: dilate, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="a637819bd4e1951afc87800380c8c0f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637819bd4e1951afc87800380c8c0f69">&#9670;&nbsp;</a></span>erode() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.erode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erodes an image by using a specific structuring element.</p>
<p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<p>(\texttt{dst} (x,y) = \min _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y'))</p>
<p>The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p>
<p>param src input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param kernel structuring element used for erosion; if {code element=Mat()}, a {code 3 x 3} rectangular structuring element is used. Kernel can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. anchor is at the element center. SEE: dilate, morphologyEx, getStructuringElement </p>

</div>
</div>
<a id="abe78037c39ca5ef1e98e621a6ac38116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe78037c39ca5ef1e98e621a6ac38116">&#9670;&nbsp;</a></span>fillConvexPoly() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fillConvexPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a convex polygon.</p>
<p>The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the function <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a> . It can fill not only convex polygons but any monotonic polygon without self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-most and/or the bottom edge could be horizontal).</p>
<p>param img Image. param points Polygon vertices. param color Polygon color. param lineType Type of the polygon boundaries. See #LineTypes param shift Number of fractional bits in the vertex coordinates. </p>

</div>
</div>
<a id="a4ff50d208a28121e54d227e5fd181554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff50d208a28121e54d227e5fd181554">&#9670;&nbsp;</a></span>fillConvexPoly() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fillConvexPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a convex polygon.</p>
<p>The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the function <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a> . It can fill not only convex polygons but any monotonic polygon without self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-most and/or the bottom edge could be horizontal).</p>
<p>param img Image. param points Polygon vertices. param color Polygon color. param lineType Type of the polygon boundaries. See #LineTypes </p>

</div>
</div>
<a id="a78fb61d36061044cc793bb34320aa03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fb61d36061044cc793bb34320aa03b">&#9670;&nbsp;</a></span>fillConvexPoly() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fillConvexPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a convex polygon.</p>
<p>The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the function <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a345500dfd93fc1ec89d567c883c50bc3">fillPoly</a> . It can fill not only convex polygons but any monotonic polygon without self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-most and/or the bottom edge could be horizontal).</p>
<p>param img Image. param points Polygon vertices. param color Polygon color. </p>

</div>
</div>
<a id="a345500dfd93fc1ec89d567c883c50bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345500dfd93fc1ec89d567c883c50bc3">&#9670;&nbsp;</a></span>fillPoly() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fillPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the area bounded by one or more polygons.</p>
<p>The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-intersections (some of their parts), and so forth.</p>
<p>param img Image. param pts Array of polygons where each polygon is represented as an array of points. param color Polygon color. param lineType Type of the polygon boundaries. See #LineTypes param shift Number of fractional bits in the vertex coordinates. param offset Optional offset of all points of the contours. </p>

</div>
</div>
<a id="aad807352623eace94a8437d9513fa1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad807352623eace94a8437d9513fa1f7">&#9670;&nbsp;</a></span>fillPoly() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fillPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the area bounded by one or more polygons.</p>
<p>The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-intersections (some of their parts), and so forth.</p>
<p>param img Image. param pts Array of polygons where each polygon is represented as an array of points. param color Polygon color. param lineType Type of the polygon boundaries. See #LineTypes param shift Number of fractional bits in the vertex coordinates. </p>

</div>
</div>
<a id="ad73179cfef9db2f7e11a9cd8628fc46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73179cfef9db2f7e11a9cd8628fc46f">&#9670;&nbsp;</a></span>fillPoly() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fillPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the area bounded by one or more polygons.</p>
<p>The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-intersections (some of their parts), and so forth.</p>
<p>param img Image. param pts Array of polygons where each polygon is represented as an array of points. param color Polygon color. param lineType Type of the polygon boundaries. See #LineTypes </p>

</div>
</div>
<a id="a8d573989468bd4912c9e4641ab53756b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d573989468bd4912c9e4641ab53756b">&#9670;&nbsp;</a></span>fillPoly() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fillPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the area bounded by one or more polygons.</p>
<p>The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-intersections (some of their parts), and so forth.</p>
<p>param img Image. param pts Array of polygons where each polygon is represented as an array of points. param color Polygon color. </p>

</div>
</div>
<a id="ad22a21837035da2a35e853f9e8725fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22a21837035da2a35e853f9e8725fd9">&#9670;&nbsp;</a></span>filter2D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.filter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convolves an image with the kernel.</p>
<p>The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.</p>
<p>The function does actually compute correlation, not the convolution:</p>
<p>(\texttt{dst} (x,y) = \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\{0\leq y' &lt; \texttt{kernel.rows}}}} \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} ))</p>
<p>That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using #flip and set the new anchor to <code>(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)</code>.</p>
<p>The function uses the DFT-based algorithm in case of sufficiently large kernels (~{code 11 x 11} or larger) and the direct algorithm for small kernels.</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth desired depth of the destination image, see REF: filter_depths "combinations" param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. param anchor anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center. param delta optional value added to the filtered pixels before storing them in dst. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. SEE: sepFilter2D, dft, matchTemplate </p>

</div>
</div>
<a id="af5317c87bd4446426581d2e6ad7858d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5317c87bd4446426581d2e6ad7858d8">&#9670;&nbsp;</a></span>filter2D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.filter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convolves an image with the kernel.</p>
<p>The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.</p>
<p>The function does actually compute correlation, not the convolution:</p>
<p>(\texttt{dst} (x,y) = \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\{0\leq y' &lt; \texttt{kernel.rows}}}} \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} ))</p>
<p>That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using #flip and set the new anchor to <code>(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)</code>.</p>
<p>The function uses the DFT-based algorithm in case of sufficiently large kernels (~{code 11 x 11} or larger) and the direct algorithm for small kernels.</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth desired depth of the destination image, see REF: filter_depths "combinations" param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. param anchor anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center. param delta optional value added to the filtered pixels before storing them in dst. SEE: sepFilter2D, dft, matchTemplate </p>

</div>
</div>
<a id="ac507f61d73e13a7b393d55c0083bc8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac507f61d73e13a7b393d55c0083bc8f0">&#9670;&nbsp;</a></span>filter2D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.filter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convolves an image with the kernel.</p>
<p>The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.</p>
<p>The function does actually compute correlation, not the convolution:</p>
<p>(\texttt{dst} (x,y) = \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\{0\leq y' &lt; \texttt{kernel.rows}}}} \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} ))</p>
<p>That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using #flip and set the new anchor to <code>(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)</code>.</p>
<p>The function uses the DFT-based algorithm in case of sufficiently large kernels (~{code 11 x 11} or larger) and the direct algorithm for small kernels.</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth desired depth of the destination image, see REF: filter_depths "combinations" param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. param anchor anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center. SEE: sepFilter2D, dft, matchTemplate </p>

</div>
</div>
<a id="ad9199038849974109ad76d212d753fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9199038849974109ad76d212d753fe8">&#9670;&nbsp;</a></span>filter2D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.filter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convolves an image with the kernel.</p>
<p>The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.</p>
<p>The function does actually compute correlation, not the convolution:</p>
<p>(\texttt{dst} (x,y) = \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\{0\leq y' &lt; \texttt{kernel.rows}}}} \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} ))</p>
<p>That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using #flip and set the new anchor to <code>(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)</code>.</p>
<p>The function uses the DFT-based algorithm in case of sufficiently large kernels (~{code 11 x 11} or larger) and the direct algorithm for small kernels.</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth desired depth of the destination image, see REF: filter_depths "combinations" param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center. SEE: sepFilter2D, dft, matchTemplate </p>

</div>
</div>
<a id="a0a3fe471f679fa851ffce18e751d8625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3fe471f679fa851ffce18e751d8625">&#9670;&nbsp;</a></span>findContours() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.findContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds contours in a binary image.</p>
<p>The function retrieves contours from the binary image using the algorithm CITE: Suzuki85 . The contours are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the OpenCV sample directory. <b>Note:</b> Since opencv 3.2 source image is not modified by this function.</p>
<p>param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a> , <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a33679aa86f8ed5555474d6bb7ba44a59">adaptiveThreshold</a>, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5ae77b7fbf08a26bff1ecaed494f4bf1">Canny</a>, and others to create a binary image out of a grayscale or color one. If mode equals to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4b1b58bbda9a0eeb208e392db7d3dd84">RETR_CCOMP</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a593948e62f3191f39e8ba7087adda6a9">RETR_FLOODFILL</a>, the input can also be a 32-bit integer image of labels (CV_32SC1). param contours Detected contours. Each contour is stored as a vector of points (e.g. std::vector&lt;std::vector&lt;cv::Point&gt; &gt;). param hierarchy Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has as many elements as the number of contours. For each i-th contour contours[i], the elements hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices in contours of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative. param mode Contour retrieval mode, see #RetrievalModes param method Contour approximation method, see #ContourApproximationModes param offset Optional offset by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context. </p>

</div>
</div>
<a id="a86b13506d50ef4ad9a6c909cdb95cd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b13506d50ef4ad9a6c909cdb95cd82">&#9670;&nbsp;</a></span>findContours() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.findContours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds contours in a binary image.</p>
<p>The function retrieves contours from the binary image using the algorithm CITE: Suzuki85 . The contours are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the OpenCV sample directory. <b>Note:</b> Since opencv 3.2 source image is not modified by this function.</p>
<p>param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0bddd2f479a606944d19b3bca2dd208a">threshold</a> , <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a33679aa86f8ed5555474d6bb7ba44a59">adaptiveThreshold</a>, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5ae77b7fbf08a26bff1ecaed494f4bf1">Canny</a>, and others to create a binary image out of a grayscale or color one. If mode equals to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4b1b58bbda9a0eeb208e392db7d3dd84">RETR_CCOMP</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a593948e62f3191f39e8ba7087adda6a9">RETR_FLOODFILL</a>, the input can also be a 32-bit integer image of labels (CV_32SC1). param contours Detected contours. Each contour is stored as a vector of points (e.g. std::vector&lt;std::vector&lt;cv::Point&gt; &gt;). param hierarchy Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has as many elements as the number of contours. For each i-th contour contours[i], the elements hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices in contours of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative. param mode Contour retrieval mode, see #RetrievalModes param method Contour approximation method, see #ContourApproximationModes contours are extracted from the image ROI and then they should be analyzed in the whole image context. </p>

</div>
</div>
<a id="a79126d22a79e182b46fd010ac3351bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79126d22a79e182b46fd010ac3351bba">&#9670;&nbsp;</a></span>fitEllipse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> OpenCVForUnity.ImgprocModule.Imgproc.fitEllipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits an ellipse around a set of 2D points.</p>
<p>The function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by CITE: Fitzgibbon95 is used. Developer should keep in mind that it is possible that the returned ellipse/rotatedRect data contains negative indices, due to the data points being close to the border of the containing Mat element.</p>
<p>param points Input 2D point set, stored in std::vector&lt;&gt; or Mat return automatically generated </p>

</div>
</div>
<a id="a1c6a956510a12870ec69920b99ef4d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6a956510a12870ec69920b99ef4d68">&#9670;&nbsp;</a></span>fitEllipseAMS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> OpenCVForUnity.ImgprocModule.Imgproc.fitEllipseAMS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits an ellipse around a set of 2D points.</p>
<p>The function calculates the ellipse that fits a set of 2D points. It returns the rotated rectangle in which the ellipse is inscribed. The Approximate Mean Square (AMS) proposed by CITE: Taubin1991 is used.</p>
<p>For an ellipse, this basis set is ( \chi= \left(x^2, x y, y^2, x, y, 1\right) ), which is a set of six free coefficients ( A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} ). However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths ( (a,b) ), the position ( (x_0,y_0) ), and the orientation ( \theta ). This is because the basis set includes lines, quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits. If the fit is found to be a parabolic or hyperbolic function then the standard <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a79126d22a79e182b46fd010ac3351bba">fitEllipse</a> method is used. The AMS method restricts the fit to parabolic, hyperbolic and elliptical curves by imposing the condition that ( A^T ( D_x^T D_x + D_y^T D_y) A = 1 ) where the matrices ( Dx ) and ( Dy ) are the partial derivatives of the design matrix ( D ) with respect to x and y. The matrices are formed row by row applying the following to each of the points in the set: (align*}{ D(i,:)&amp;=\left\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\right\} &amp; D_x(i,:)&amp;=\left\{2 x_i,y_i,0,1,0,0\right\} &amp; D_y(i,:)&amp;=\left\{0,x_i,2 y_i,0,1,0\right\} ) The AMS method minimizes the cost function (equation*}{ \epsilon ^2=\frac{ A^T D^T D A }{ A^T (D_x^T D_x + D_y^T D_y) A^T } )</p>
<p>The minimum cost is found by solving the generalized eigenvalue problem.</p>
<p>(equation*}{ D^T D A = \lambda \left( D_x^T D_x + D_y^T D_y\right) A )</p>
<p>param points Input 2D point set, stored in std::vector&lt;&gt; or Mat return automatically generated </p>

</div>
</div>
<a id="a624e098bb2b1f8a4be1ce83cd0c04ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624e098bb2b1f8a4be1ce83cd0c04ddf">&#9670;&nbsp;</a></span>fitEllipseDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> OpenCVForUnity.ImgprocModule.Imgproc.fitEllipseDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits an ellipse around a set of 2D points.</p>
<p>The function calculates the ellipse that fits a set of 2D points. It returns the rotated rectangle in which the ellipse is inscribed. The Direct least square (Direct) method by CITE: Fitzgibbon1999 is used.</p>
<p>For an ellipse, this basis set is ( \chi= \left(x^2, x y, y^2, x, y, 1\right) ), which is a set of six free coefficients ( A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} ). However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths ( (a,b) ), the position ( (x_0,y_0) ), and the orientation ( \theta ). This is because the basis set includes lines, quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits. The Direct method confines the fit to ellipses by ensuring that ( 4 A_{xx} A_{yy}- A_{xy}^2 &gt; 0 ). The condition imposed is that ( 4 A_{xx} A_{yy}- A_{xy}^2=1 ) which satisfies the inequality and as the coefficients can be arbitrarily scaled is not overly restrictive.</p>
<p>(equation*}{ \epsilon ^2= A^T D^T D A \quad \text{with} \quad A^T C A =1 \quad \text{and} \quad C=\left(\begin{matrix} 0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{matrix} \right) )</p>
<p>The minimum cost is found by solving the generalized eigenvalue problem.</p>
<p>(equation*}{ D^T D A = \lambda \left( C\right) A )</p>
<p>The system produces only one positive eigenvalue ( \lambda) which is chosen as the solution with its eigenvector (\mathbf{u}). These are used to find the coefficients</p>
<p>(equation*}{ A = \sqrt{\frac{1}{\mathbf{u}^T C \mathbf{u}}} \mathbf{u} ) The scaling factor guarantees that (A^T C A =1).</p>
<p>param points Input 2D point set, stored in std::vector&lt;&gt; or Mat return automatically generated </p>

</div>
</div>
<a id="ac6753e91a584383f93134b16b332e75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6753e91a584383f93134b16b332e75f">&#9670;&nbsp;</a></span>fitLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.fitLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>aeps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits a line to a 2D or 3D point set.</p>
<p>The function fitLine fits a line to a 2D or 3D point set by minimizing (\sum_i \rho(r_i)) where (r_i) is a distance between the (i^{th}) point, the line and (\rho(r)) is a distance function, one of the following: </p><ul>
<li>
DIST_L2 (\rho (r) = r^2/2 \quad \text{(the simplest and the fastest least-squares method)})  </li>
<li>
DIST_L1 (\rho (r) = r)  </li>
<li>
DIST_L12 (\rho (r) = 2 \cdot ( \sqrt{1 + \frac{r^2}{2}} - 1))  </li>
<li>
DIST_FAIR (\rho \left (r \right ) = C^2 \cdot \left ( \frac{r}{C} - \log{\left(1 + \frac{r}{C}\right)} \right ) \quad \text{where} \quad C=1.3998)  </li>
<li>
DIST_WELSCH (\rho \left (r \right ) = \frac{C^2}{2} \cdot \left ( 1 - \exp{\left(-\left(\frac{r}{C}\right)^2\right)} \right ) \quad \text{where} \quad C=2.9846)  </li>
<li>
DIST_HUBER (\rho (r) = \fork{r^2/2}{if (r &lt; C)}{C \cdot (r-C/2)}{otherwise} \quad \text{where} \quad C=1.345)  </li>
</ul>
<p>The algorithm is based on the M-estimator ( &lt;<a href="http://en.wikipedia.org/wiki/M-estimator&gt;">http://en.wikipedia.org/wiki/M-estimator&amp;gt;</a> ) technique that iteratively fits the line using the weighted least-squares algorithm. After each iteration the weights (w_i) are adjusted to be inversely proportional to (\rho(r_i)) .</p>
<p>param points Input vector of 2D or 3D points, stored in std::vector&lt;&gt; or Mat. param line Output line parameters. In case of 2D fitting, it should be a vector of 4 elements (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line and (x0, y0, z0) is a point on the line. param distType Distance used by the M-estimator, see #DistanceTypes param param Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value is chosen. param reps Sufficient accuracy for the radius (distance between the coordinate origin and the line). param aeps Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps. </p>

</div>
</div>
<a id="ac051fa7176259d8f39bcd92025f35863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac051fa7176259d8f39bcd92025f35863">&#9670;&nbsp;</a></span>floodFill() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.floodFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>seedPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>newVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>loDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>upDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a connected component with the given color.</p>
<p>The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at ((x,y)) is considered to belong to the repainted domain if:</p>
<ul>
<li>
in case of a grayscale image and floating range (\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} (x',y')+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a grayscale image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a color image and floating range (\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,) (\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g) and (\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b)  </li>
</ul>
<ul>
<li>
in case of a color image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,) (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g) and (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b)  </li>
</ul>
<p>where (src(x',y')) is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to: </p><ul>
<li>
Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range.  </li>
<li>
Color/brightness of the seed point in case of a fixed range.  </li>
</ul>
<p>Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on.</p>
<p>param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af3930e0cc57d7a44255f1a926df80b2c">FLOODFILL_MASK_ONLY</a> flag is set in the second variant of the function. See the details below. param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap. param seedPoint Starting point. param newVal New value of the repainted domain pixels. param loDiff Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. param upDiff Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. param rect Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain. param flags Operation flags. The first 8 bits contain a connectivity value. The default value of 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags.</p>
<p><b>Note:</b> Since the mask is larger than the filled image, a pixel ((x, y)) in image corresponds to the pixel ((x+1, y+1)) in the mask .</p>
<p>SEE: findContours return automatically generated </p>

</div>
</div>
<a id="ac17115e3322933420ee5fc5844774dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17115e3322933420ee5fc5844774dac">&#9670;&nbsp;</a></span>floodFill() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.floodFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>seedPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>newVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>loDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>upDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a connected component with the given color.</p>
<p>The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at ((x,y)) is considered to belong to the repainted domain if:</p>
<ul>
<li>
in case of a grayscale image and floating range (\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} (x',y')+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a grayscale image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a color image and floating range (\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,) (\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g) and (\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b)  </li>
</ul>
<ul>
<li>
in case of a color image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,) (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g) and (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b)  </li>
</ul>
<p>where (src(x',y')) is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to: </p><ul>
<li>
Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range.  </li>
<li>
Color/brightness of the seed point in case of a fixed range.  </li>
</ul>
<p>Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on.</p>
<p>param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af3930e0cc57d7a44255f1a926df80b2c">FLOODFILL_MASK_ONLY</a> flag is set in the second variant of the function. See the details below. param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap. param seedPoint Starting point. param newVal New value of the repainted domain pixels. param loDiff Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. param upDiff Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. param rect Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain. 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags.</p>
<p><b>Note:</b> Since the mask is larger than the filled image, a pixel ((x, y)) in image corresponds to the pixel ((x+1, y+1)) in the mask .</p>
<p>SEE: findContours return automatically generated </p>

</div>
</div>
<a id="afe49012732735c97f74831fa07efc043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe49012732735c97f74831fa07efc043">&#9670;&nbsp;</a></span>floodFill() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.floodFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>seedPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>newVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>loDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a connected component with the given color.</p>
<p>The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at ((x,y)) is considered to belong to the repainted domain if:</p>
<ul>
<li>
in case of a grayscale image and floating range (\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} (x',y')+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a grayscale image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a color image and floating range (\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,) (\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g) and (\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b)  </li>
</ul>
<ul>
<li>
in case of a color image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,) (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g) and (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b)  </li>
</ul>
<p>where (src(x',y')) is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to: </p><ul>
<li>
Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range.  </li>
<li>
Color/brightness of the seed point in case of a fixed range.  </li>
</ul>
<p>Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on.</p>
<p>param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af3930e0cc57d7a44255f1a926df80b2c">FLOODFILL_MASK_ONLY</a> flag is set in the second variant of the function. See the details below. param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap. param seedPoint Starting point. param newVal New value of the repainted domain pixels. param loDiff Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. one of its neighbors belonging to the component, or a seed pixel being added to the component. param rect Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain. 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags.</p>
<p><b>Note:</b> Since the mask is larger than the filled image, a pixel ((x, y)) in image corresponds to the pixel ((x+1, y+1)) in the mask .</p>
<p>SEE: findContours return automatically generated </p>

</div>
</div>
<a id="a5542c5b87acfa905d37358d2481da8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5542c5b87acfa905d37358d2481da8df">&#9670;&nbsp;</a></span>floodFill() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.floodFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>seedPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>newVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a connected component with the given color.</p>
<p>The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at ((x,y)) is considered to belong to the repainted domain if:</p>
<ul>
<li>
in case of a grayscale image and floating range (\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} (x',y')+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a grayscale image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a color image and floating range (\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,) (\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g) and (\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b)  </li>
</ul>
<ul>
<li>
in case of a color image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,) (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g) and (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b)  </li>
</ul>
<p>where (src(x',y')) is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to: </p><ul>
<li>
Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range.  </li>
<li>
Color/brightness of the seed point in case of a fixed range.  </li>
</ul>
<p>Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on.</p>
<p>param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af3930e0cc57d7a44255f1a926df80b2c">FLOODFILL_MASK_ONLY</a> flag is set in the second variant of the function. See the details below. param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap. param seedPoint Starting point. param newVal New value of the repainted domain pixels. one of its neighbors belonging to the component, or a seed pixel being added to the component. one of its neighbors belonging to the component, or a seed pixel being added to the component. param rect Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain. 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags.</p>
<p><b>Note:</b> Since the mask is larger than the filled image, a pixel ((x, y)) in image corresponds to the pixel ((x+1, y+1)) in the mask .</p>
<p>SEE: findContours return automatically generated </p>

</div>
</div>
<a id="a5f7060ea714f0797a5873241e59620ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7060ea714f0797a5873241e59620ae">&#9670;&nbsp;</a></span>floodFill() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.floodFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>seedPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>newVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills a connected component with the given color.</p>
<p>The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at ((x,y)) is considered to belong to the repainted domain if:</p>
<ul>
<li>
in case of a grayscale image and floating range (\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} (x',y')+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a grayscale image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y) \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff})  </li>
</ul>
<ul>
<li>
in case of a color image and floating range (\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,) (\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g) and (\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b)  </li>
</ul>
<ul>
<li>
in case of a color image and fixed range (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,) (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g) and (\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b)  </li>
</ul>
<p>where (src(x',y')) is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to: </p><ul>
<li>
Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range.  </li>
<li>
Color/brightness of the seed point in case of a fixed range.  </li>
</ul>
<p>Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on.</p>
<p>param image Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af3930e0cc57d7a44255f1a926df80b2c">FLOODFILL_MASK_ONLY</a> flag is set in the second variant of the function. See the details below. param mask Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap. param seedPoint Starting point. param newVal New value of the repainted domain pixels. one of its neighbors belonging to the component, or a seed pixel being added to the component. one of its neighbors belonging to the component, or a seed pixel being added to the component. repainted domain. 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags.</p>
<p><b>Note:</b> Since the mask is larger than the filled image, a pixel ((x, y)) in image corresponds to the pixel ((x+1, y+1)) in the mask .</p>
<p>SEE: findContours return automatically generated </p>

</div>
</div>
<a id="a95192392e5ce830d79efa0d66da4f2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95192392e5ce830d79efa0d66da4f2a6">&#9670;&nbsp;</a></span>GaussianBlur() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.GaussianBlur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using a Gaussian filter.</p>
<p>The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported.</p>
<p>param src input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma. param sigmaX Gaussian kernel standard deviation in X direction. param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a726835f6a190b95bb46f3a966f035d39">getGaussianKernel</a> for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.</p>
<p>SEE: sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur </p>

</div>
</div>
<a id="ae32914f3b2bc9be6625aad93968d1b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32914f3b2bc9be6625aad93968d1b7d">&#9670;&nbsp;</a></span>GaussianBlur() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.GaussianBlur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using a Gaussian filter.</p>
<p>The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported.</p>
<p>param src input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma. param sigmaX Gaussian kernel standard deviation in X direction. param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a726835f6a190b95bb46f3a966f035d39">getGaussianKernel</a> for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</p>
<p>SEE: sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur </p>

</div>
</div>
<a id="a6ba7835286e1ce1289ba3a268da493c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba7835286e1ce1289ba3a268da493c0">&#9670;&nbsp;</a></span>GaussianBlur() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.GaussianBlur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmaX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using a Gaussian filter.</p>
<p>The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported.</p>
<p>param src input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst output image of the same size and type as src. param ksize Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma. param sigmaX Gaussian kernel standard deviation in X direction. equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a726835f6a190b95bb46f3a966f035d39">getGaussianKernel</a> for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</p>
<p>SEE: sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur </p>

</div>
</div>
<a id="adc1ff2e2b2365ea9b27d454b9ea43dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1ff2e2b2365ea9b27d454b9ea43dcb">&#9670;&nbsp;</a></span>getAffineTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getAffineTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae449bb66300f367c5c3efef85954520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae449bb66300f367c5c3efef85954520a">&#9670;&nbsp;</a></span>getDerivKernels() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.getDerivKernels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ktype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns filter coefficients for computing spatial image derivatives.</p>
<p>The function computes and returns the filter coefficients for spatial image derivatives. When {code ksize=FILTER_SCHARR}, the Scharr (3 \times 3) kernels are generated (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a>). Otherwise, Sobel kernels are generated (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aedc11d47ee5206e9b6b56ae0796e1c88">Sobel</a>). The filters are normally passed to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a283f8733d3d2de422385d88e70b51f19">sepFilter2D</a> or to</p>
<p>param kx Output matrix of row filter coefficients. It has the type ktype . param ky Output matrix of column filter coefficients. It has the type ktype . param dx Derivative order in respect of x. param dy Derivative order in respect of y. param ksize Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7. param normalize Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator (=2^{ksize*2-dx-dy-2}). If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set normalize=false . param ktype Type of filter coefficients. It can be CV_32f or CV_64F . </p>

</div>
</div>
<a id="a9233ff67ebbf9a924af8c5ca70e92aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9233ff67ebbf9a924af8c5ca70e92aa9">&#9670;&nbsp;</a></span>getDerivKernels() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.getDerivKernels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns filter coefficients for computing spatial image derivatives.</p>
<p>The function computes and returns the filter coefficients for spatial image derivatives. When {code ksize=FILTER_SCHARR}, the Scharr (3 \times 3) kernels are generated (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a>). Otherwise, Sobel kernels are generated (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aedc11d47ee5206e9b6b56ae0796e1c88">Sobel</a>). The filters are normally passed to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a283f8733d3d2de422385d88e70b51f19">sepFilter2D</a> or to</p>
<p>param kx Output matrix of row filter coefficients. It has the type ktype . param ky Output matrix of column filter coefficients. It has the type ktype . param dx Derivative order in respect of x. param dy Derivative order in respect of y. param ksize Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7. param normalize Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator (=2^{ksize*2-dx-dy-2}). If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set normalize=false . </p>

</div>
</div>
<a id="ae4014e40fc997a265bcad9f7070068a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4014e40fc997a265bcad9f7070068a6">&#9670;&nbsp;</a></span>getDerivKernels() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.getDerivKernels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns filter coefficients for computing spatial image derivatives.</p>
<p>The function computes and returns the filter coefficients for spatial image derivatives. When {code ksize=FILTER_SCHARR}, the Scharr (3 \times 3) kernels are generated (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a>). Otherwise, Sobel kernels are generated (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aedc11d47ee5206e9b6b56ae0796e1c88">Sobel</a>). The filters are normally passed to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a283f8733d3d2de422385d88e70b51f19">sepFilter2D</a> or to</p>
<p>param kx Output matrix of row filter coefficients. It has the type ktype . param ky Output matrix of column filter coefficients. It has the type ktype . param dx Derivative order in respect of x. param dy Derivative order in respect of y. param ksize Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7. Theoretically, the coefficients should have the denominator (=2^{ksize*2-dx-dy-2}). If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set normalize=false . </p>

</div>
</div>
<a id="af246acc054ac86da2286edb7fe47d577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af246acc054ac86da2286edb7fe47d577">&#9670;&nbsp;</a></span>getFontScaleFromHeight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.getFontScaleFromHeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixelHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the font-specific size to use to achieve a given height in pixels.</p>
<p>param fontFace Font to use, see cv::HersheyFonts. param pixelHeight Pixel height to compute the fontScale for param thickness Thickness of lines used to render the text.See putText for details. return The fontSize to use for cv::putText</p>
<p>SEE: cv::putText </p>

</div>
</div>
<a id="ac34b90b1c25d3d4b3cf287f6aa9beb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34b90b1c25d3d4b3cf287f6aa9beb33">&#9670;&nbsp;</a></span>getFontScaleFromHeight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.getFontScaleFromHeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixelHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the font-specific size to use to achieve a given height in pixels.</p>
<p>param fontFace Font to use, see cv::HersheyFonts. param pixelHeight Pixel height to compute the fontScale for return The fontSize to use for cv::putText</p>
<p>SEE: cv::putText </p>

</div>
</div>
<a id="a0037fbccf78b7eb59440abfdbe03fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0037fbccf78b7eb59440abfdbe03fa4d">&#9670;&nbsp;</a></span>getGaborKernel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getGaborKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ktype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns Gabor filter coefficients.</p>
<p>For more details about gabor filter equations and parameters, see: <a href="http://en.wikipedia.org/wiki/Gabor_filter">Gabor Filter</a>.</p>
<p>param ksize Size of the filter returned. param sigma Standard deviation of the gaussian envelope. param theta Orientation of the normal to the parallel stripes of a Gabor function. param lambd Wavelength of the sinusoidal factor. param gamma Spatial aspect ratio. param psi Phase offset. param ktype Type of filter coefficients. It can be CV_32F or CV_64F . return automatically generated </p>

</div>
</div>
<a id="af20ef06bcd2915b36809ad9f87a66b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20ef06bcd2915b36809ad9f87a66b3c">&#9670;&nbsp;</a></span>getGaborKernel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getGaborKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns Gabor filter coefficients.</p>
<p>For more details about gabor filter equations and parameters, see: <a href="http://en.wikipedia.org/wiki/Gabor_filter">Gabor Filter</a>.</p>
<p>param ksize Size of the filter returned. param sigma Standard deviation of the gaussian envelope. param theta Orientation of the normal to the parallel stripes of a Gabor function. param lambd Wavelength of the sinusoidal factor. param gamma Spatial aspect ratio. param psi Phase offset. return automatically generated </p>

</div>
</div>
<a id="ae281c70dcc8d11418cdd8f43f909c97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae281c70dcc8d11418cdd8f43f909c97a">&#9670;&nbsp;</a></span>getGaborKernel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getGaborKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns Gabor filter coefficients.</p>
<p>For more details about gabor filter equations and parameters, see: <a href="http://en.wikipedia.org/wiki/Gabor_filter">Gabor Filter</a>.</p>
<p>param ksize Size of the filter returned. param sigma Standard deviation of the gaussian envelope. param theta Orientation of the normal to the parallel stripes of a Gabor function. param lambd Wavelength of the sinusoidal factor. param gamma Spatial aspect ratio. return automatically generated </p>

</div>
</div>
<a id="a726835f6a190b95bb46f3a966f035d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726835f6a190b95bb46f3a966f035d39">&#9670;&nbsp;</a></span>getGaussianKernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getGaussianKernel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ktype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns Gaussian filter coefficients.</p>
<p>The function computes and returns the (\texttt{ksize} \times 1) matrix of Gaussian filter coefficients:</p>
<p>(G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},)</p>
<p>where (i=0..\texttt{ksize}-1) and (\alpha) is the scale factor chosen so that (\sum_i G_i=1).</p>
<p>Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-level GaussianBlur. param ksize Aperture size. It should be odd ( (\texttt{ksize} \mod 2 = 1) ) and positive. param sigma Gaussian standard deviation. If it is non-positive, it is computed from ksize as {code sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8}. param ktype Type of filter coefficients. It can be CV_32F or CV_64F . SEE: sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur return automatically generated </p>

</div>
</div>
<a id="a7ebaf09bcdbefd36deb09efb0675badc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebaf09bcdbefd36deb09efb0675badc">&#9670;&nbsp;</a></span>getGaussianKernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getGaussianKernel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns Gaussian filter coefficients.</p>
<p>The function computes and returns the (\texttt{ksize} \times 1) matrix of Gaussian filter coefficients:</p>
<p>(G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},)</p>
<p>where (i=0..\texttt{ksize}-1) and (\alpha) is the scale factor chosen so that (\sum_i G_i=1).</p>
<p>Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-level GaussianBlur. param ksize Aperture size. It should be odd ( (\texttt{ksize} \mod 2 = 1) ) and positive. param sigma Gaussian standard deviation. If it is non-positive, it is computed from ksize as {code sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8}. SEE: sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur return automatically generated </p>

</div>
</div>
<a id="a7771bcc929549ce912d17fab419c7241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7771bcc929549ce912d17fab419c7241">&#9670;&nbsp;</a></span>getPerspectiveTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getPerspectiveTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>solveMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a perspective transform from four pairs of the corresponding points.</p>
<p>The function calculates the (3 \times 3) matrix of a perspective transform so that:</p>
<p>(\begin{bmatrix} t_i x'_i \ t_i y'_i \ t_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \ y_i \ 1 \end{bmatrix})</p>
<p>where</p>
<p>(dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3)</p>
<p>param src Coordinates of quadrangle vertices in the source image. param dst Coordinates of the corresponding quadrangle vertices in the destination image. param solveMethod method passed to cv::solve (#DecompTypes)</p>
<p>SEE: findHomography, warpPerspective, perspectiveTransform return automatically generated </p>

</div>
</div>
<a id="acde9ae771e86f43c9c45e4bed3687843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde9ae771e86f43c9c45e4bed3687843">&#9670;&nbsp;</a></span>getPerspectiveTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getPerspectiveTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a perspective transform from four pairs of the corresponding points.</p>
<p>The function calculates the (3 \times 3) matrix of a perspective transform so that:</p>
<p>(\begin{bmatrix} t_i x'_i \ t_i y'_i \ t_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \ y_i \ 1 \end{bmatrix})</p>
<p>where</p>
<p>(dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3)</p>
<p>param src Coordinates of quadrangle vertices in the source image. param dst Coordinates of the corresponding quadrangle vertices in the destination image.</p>
<p>SEE: findHomography, warpPerspective, perspectiveTransform return automatically generated </p>

</div>
</div>
<a id="a2e0138aec67899d4c27984b0ed6768c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0138aec67899d4c27984b0ed6768c7">&#9670;&nbsp;</a></span>getRectSubPix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.getRectSubPix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>patchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>patchType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves a pixel rectangle from an image with sub-pixel accuracy.</p>
<p>The function getRectSubPix extracts pixels from src:</p>
<p>(patch(x, y) = src(x + \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y + \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5))</p>
<p>where the values of the pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multi-channel images is processed independently. Also the image should be a single channel or three channel image. While the center of the rectangle must be inside the image, parts of the rectangle may be outside.</p>
<p>param image Source image. param patchSize Size of the extracted patch. param center Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image. param patch Extracted patch that has the size patchSize and the same number of channels as src . param patchType Depth of the extracted pixels. By default, they have the same depth as src .</p>
<p>SEE: warpAffine, warpPerspective </p>

</div>
</div>
<a id="a23fc1408818b57adeaa85bd1098ab202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fc1408818b57adeaa85bd1098ab202">&#9670;&nbsp;</a></span>getRectSubPix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.getRectSubPix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>patchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves a pixel rectangle from an image with sub-pixel accuracy.</p>
<p>The function getRectSubPix extracts pixels from src:</p>
<p>(patch(x, y) = src(x + \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y + \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5))</p>
<p>where the values of the pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multi-channel images is processed independently. Also the image should be a single channel or three channel image. While the center of the rectangle must be inside the image, parts of the rectangle may be outside.</p>
<p>param image Source image. param patchSize Size of the extracted patch. param center Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image. param patch Extracted patch that has the size patchSize and the same number of channels as src .</p>
<p>SEE: warpAffine, warpPerspective </p>

</div>
</div>
<a id="ab9b8b89051891d37da62abf9bd0dfb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b8b89051891d37da62abf9bd0dfb5a">&#9670;&nbsp;</a></span>getRotationMatrix2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getRotationMatrix2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates an affine matrix of 2D rotation.</p>
<p>The function calculates the following matrix:</p>
<p>(\begin{bmatrix} \alpha &amp; \beta &amp; (1- \alpha ) \cdot \texttt{center.x} - \beta \cdot \texttt{center.y} \ - \beta &amp; \alpha &amp; \beta \cdot \texttt{center.x} + (1- \alpha ) \cdot \texttt{center.y} \end{bmatrix})</p>
<p>where</p>
<p>(\begin{array}{l} \alpha = \texttt{scale} \cdot \cos \texttt{angle} , \ \beta = \texttt{scale} \cdot \sin \texttt{angle} \end{array})</p>
<p>The transformation maps the rotation center to itself. If this is not the target, adjust the shift.</p>
<p>param center Center of the rotation in the source image. param angle Rotation angle in degrees. Positive values mean counter-clockwise rotation (the coordinate origin is assumed to be the top-left corner). param scale Isotropic scale factor.</p>
<p>SEE: getAffineTransform, warpAffine, transform return automatically generated </p>

</div>
</div>
<a id="a72818a59ccc8afaa8ec04c4da2024205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72818a59ccc8afaa8ec04c4da2024205">&#9670;&nbsp;</a></span>getStructuringElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getStructuringElement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a structuring element of the specified size and shape for morphological operations.</p>
<p>The function constructs and returns the structuring element that can be further passed to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aec3d8a9c0378980731f7520977a7baeb">erode</a>, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8132a3a849ddc6e08c26e46a74c2666d">dilate</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a83b3c848d39e08401daf8f1ee005348b">morphologyEx</a>. But you can also construct an arbitrary binary mask yourself and use it as the structuring element.</p>
<p>param shape Element shape that could be one of #MorphShapes param ksize Size of the structuring element. param anchor Anchor position within the element. The default value ((-1, -1)) means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted. return automatically generated </p>

</div>
</div>
<a id="ab185de8772a80f01b14ba1bab3f0a537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab185de8772a80f01b14ba1bab3f0a537">&#9670;&nbsp;</a></span>getStructuringElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.ImgprocModule.Imgproc.getStructuringElement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a structuring element of the specified size and shape for morphological operations.</p>
<p>The function constructs and returns the structuring element that can be further passed to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aec3d8a9c0378980731f7520977a7baeb">erode</a>, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8132a3a849ddc6e08c26e46a74c2666d">dilate</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a83b3c848d39e08401daf8f1ee005348b">morphologyEx</a>. But you can also construct an arbitrary binary mask yourself and use it as the structuring element.</p>
<p>param shape Element shape that could be one of #MorphShapes param ksize Size of the structuring element. anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted. return automatically generated </p>

</div>
</div>
<a id="af32d35c17f9443528b2163b3d6371719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32d35c17f9443528b2163b3d6371719">&#9670;&nbsp;</a></span>getTextSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> OpenCVForUnity.ImgprocModule.Imgproc.getTextSize </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fontScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int []&#160;</td>
          <td class="paramname"><em>baseLine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab695f38150588aa30eb476bd590bdd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab695f38150588aa30eb476bd590bdd47">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gradientSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHarrisDetector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7de9aa4f2af6e36499aaf607fcb51f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7de9aa4f2af6e36499aaf607fcb51f7">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gradientSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHarrisDetector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a179279ba725050549a3ee51f1c1e96ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179279ba725050549a3ee51f1c1e96ba">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gradientSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8104c378c7a9978d3cdd23cb7be13be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8104c378c7a9978d3cdd23cb7be13be">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHarrisDetector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines strong corners on an image.</p>
<p>The function finds the most prominent corners in the image or in the specified image region, as described in CITE: Shi94</p>
<ul>
<li>
Function calculates the corner quality measure at every source image pixel using the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> .  </li>
<li>
Function performs a non-maximum suppression (the local maximums in <em>3 x 3</em> neighborhood are retained).  </li>
<li>
The corners with the minimal eigenvalue less than (\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)) are rejected.  </li>
<li>
The remaining corners are sorted by the quality measure in the descending order.  </li>
<li>
Function throws away each corner for which there is a stronger corner at a distance less than maxDistance.  </li>
</ul>
<p>The function can be used to initialize a point-based tracker of an object.</p>
<p><b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B .</p>
<p>param image Input 8-bit or floating-point 32-bit, single-channel image. param corners Output vector of detected corners. param maxCorners Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. {code maxCorners &lt;= 0} implies that no limit on the maximum is set and all detected corners are returned. param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> ) or the Harris function response (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. param minDistance Minimum possible Euclidean distance between the returned corners. param mask Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. param blockSize Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . param useHarrisDetector Parameter indicating whether to use a Harris detector (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a>) or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a>. param k Free parameter of the Harris detector.</p>
<p>SEE: cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform, </p>

</div>
</div>
<a id="ac1a9982aa926182fa6c23c0f195732a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a9982aa926182fa6c23c0f195732a4">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHarrisDetector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines strong corners on an image.</p>
<p>The function finds the most prominent corners in the image or in the specified image region, as described in CITE: Shi94</p>
<ul>
<li>
Function calculates the corner quality measure at every source image pixel using the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> .  </li>
<li>
Function performs a non-maximum suppression (the local maximums in <em>3 x 3</em> neighborhood are retained).  </li>
<li>
The corners with the minimal eigenvalue less than (\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)) are rejected.  </li>
<li>
The remaining corners are sorted by the quality measure in the descending order.  </li>
<li>
Function throws away each corner for which there is a stronger corner at a distance less than maxDistance.  </li>
</ul>
<p>The function can be used to initialize a point-based tracker of an object.</p>
<p><b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B .</p>
<p>param image Input 8-bit or floating-point 32-bit, single-channel image. param corners Output vector of detected corners. param maxCorners Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. {code maxCorners &lt;= 0} implies that no limit on the maximum is set and all detected corners are returned. param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> ) or the Harris function response (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. param minDistance Minimum possible Euclidean distance between the returned corners. param mask Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. param blockSize Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . param useHarrisDetector Parameter indicating whether to use a Harris detector (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a>) or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a>.</p>
<p>SEE: cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform, </p>

</div>
</div>
<a id="a8c2ffdacdb79e78682d75c262d01ccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2ffdacdb79e78682d75c262d01ccb4">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines strong corners on an image.</p>
<p>The function finds the most prominent corners in the image or in the specified image region, as described in CITE: Shi94</p>
<ul>
<li>
Function calculates the corner quality measure at every source image pixel using the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> .  </li>
<li>
Function performs a non-maximum suppression (the local maximums in <em>3 x 3</em> neighborhood are retained).  </li>
<li>
The corners with the minimal eigenvalue less than (\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)) are rejected.  </li>
<li>
The remaining corners are sorted by the quality measure in the descending order.  </li>
<li>
Function throws away each corner for which there is a stronger corner at a distance less than maxDistance.  </li>
</ul>
<p>The function can be used to initialize a point-based tracker of an object.</p>
<p><b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B .</p>
<p>param image Input 8-bit or floating-point 32-bit, single-channel image. param corners Output vector of detected corners. param maxCorners Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. {code maxCorners &lt;= 0} implies that no limit on the maximum is set and all detected corners are returned. param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> ) or the Harris function response (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. param minDistance Minimum possible Euclidean distance between the returned corners. param mask Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. param blockSize Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a>.</p>
<p>SEE: cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform, </p>

</div>
</div>
<a id="ad4fe76978f8adf7a3d4575683ef12cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fe76978f8adf7a3d4575683ef12cda">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines strong corners on an image.</p>
<p>The function finds the most prominent corners in the image or in the specified image region, as described in CITE: Shi94</p>
<ul>
<li>
Function calculates the corner quality measure at every source image pixel using the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> .  </li>
<li>
Function performs a non-maximum suppression (the local maximums in <em>3 x 3</em> neighborhood are retained).  </li>
<li>
The corners with the minimal eigenvalue less than (\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)) are rejected.  </li>
<li>
The remaining corners are sorted by the quality measure in the descending order.  </li>
<li>
Function throws away each corner for which there is a stronger corner at a distance less than maxDistance.  </li>
</ul>
<p>The function can be used to initialize a point-based tracker of an object.</p>
<p><b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B .</p>
<p>param image Input 8-bit or floating-point 32-bit, single-channel image. param corners Output vector of detected corners. param maxCorners Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. {code maxCorners &lt;= 0} implies that no limit on the maximum is set and all detected corners are returned. param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> ) or the Harris function response (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. param minDistance Minimum possible Euclidean distance between the returned corners. param mask Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. pixel neighborhood. See cornerEigenValsAndVecs . or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a>.</p>
<p>SEE: cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform, </p>

</div>
</div>
<a id="ab4af3356b35847561e1655eb2faf1340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4af3356b35847561e1655eb2faf1340">&#9670;&nbsp;</a></span>goodFeaturesToTrack() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines strong corners on an image.</p>
<p>The function finds the most prominent corners in the image or in the specified image region, as described in CITE: Shi94</p>
<ul>
<li>
Function calculates the corner quality measure at every source image pixel using the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> .  </li>
<li>
Function performs a non-maximum suppression (the local maximums in <em>3 x 3</em> neighborhood are retained).  </li>
<li>
The corners with the minimal eigenvalue less than (\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)) are rejected.  </li>
<li>
The remaining corners are sorted by the quality measure in the descending order.  </li>
<li>
Function throws away each corner for which there is a stronger corner at a distance less than maxDistance.  </li>
</ul>
<p>The function can be used to initialize a point-based tracker of an object.</p>
<p><b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B .</p>
<p>param image Input 8-bit or floating-point 32-bit, single-channel image. param corners Output vector of detected corners. param maxCorners Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. {code maxCorners &lt;= 0} implies that no limit on the maximum is set and all detected corners are returned. param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a> ) or the Harris function response (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0f8ad0c7fab4c1f49409707163b2bc1a">cornerHarris</a> ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. param minDistance Minimum possible Euclidean distance between the returned corners. CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. pixel neighborhood. See cornerEigenValsAndVecs . or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4bdac67e089b6ea241ca3663cee1847b">cornerMinEigenVal</a>.</p>
<p>SEE: cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform, </p>

</div>
</div>
<a id="a8ae28998c34224bf8348f317f879f97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae28998c34224bf8348f317f879f97f">&#9670;&nbsp;</a></span>grabCut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.grabCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>bgdModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>fgdModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the GrabCut algorithm.</p>
<p>The function implements the <a href="http://en.wikipedia.org/wiki/GrabCut">GrabCut image segmentation algorithm</a>.</p>
<p>param img Input 8-bit 3-channel image. param mask Input/output 8-bit single-channel mask. The mask is initialized by the function when mode is set to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af815a3afe07216456a40346026a40015">GC_INIT_WITH_RECT</a>. Its elements may have one of the #GrabCutClasses. param rect ROI containing a segmented object. The pixels outside of the ROI are marked as "obvious background". The parameter is only used when mode==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af815a3afe07216456a40346026a40015">GC_INIT_WITH_RECT</a> . param bgdModel Temporary array for the background model. Do not modify it while you are processing the same image. param fgdModel Temporary arrays for the foreground model. Do not modify it while you are processing the same image. param iterCount Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with mode==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4302eb4e5f105652cb8f5ab009dc00ce">GC_INIT_WITH_MASK</a> or mode==GC_EVAL . param mode Operation mode that could be one of the #GrabCutModes </p>

</div>
</div>
<a id="aa30d08f93c5d646ec7326866294c982e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30d08f93c5d646ec7326866294c982e">&#9670;&nbsp;</a></span>grabCut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.grabCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>bgdModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>fgdModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs the GrabCut algorithm.</p>
<p>The function implements the <a href="http://en.wikipedia.org/wiki/GrabCut">GrabCut image segmentation algorithm</a>.</p>
<p>param img Input 8-bit 3-channel image. param mask Input/output 8-bit single-channel mask. The mask is initialized by the function when mode is set to <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af815a3afe07216456a40346026a40015">GC_INIT_WITH_RECT</a>. Its elements may have one of the #GrabCutClasses. param rect ROI containing a segmented object. The pixels outside of the ROI are marked as "obvious background". The parameter is only used when mode==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af815a3afe07216456a40346026a40015">GC_INIT_WITH_RECT</a> . param bgdModel Temporary array for the background model. Do not modify it while you are processing the same image. param fgdModel Temporary arrays for the foreground model. Do not modify it while you are processing the same image. param iterCount Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with mode==<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4302eb4e5f105652cb8f5ab009dc00ce">GC_INIT_WITH_MASK</a> or mode==GC_EVAL . </p>

</div>
</div>
<a id="a3729184115d8f750969754fa1c93cc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3729184115d8f750969754fa1c93cc50">&#9670;&nbsp;</a></span>HoughCircles() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughCircles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>circles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds circles in a grayscale image using the Hough transform.</p>
<p>The function finds circles in a grayscale image using a modification of the Hough transform.</p>
<p>Example: : INCLUDE: snippets/imgproc_HoughLinesCircles.cpp</p>
<p><b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure.</p>
<p>It also helps to smooth image a bit unless it's already soft. For example, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a95192392e5ce830d79efa0d66da4f2a6">GaussianBlur()</a> with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</p>
<p>param image 8-bit, single-channel, grayscale input image. param circles Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector ((x, y, radius)) or ((x, y, radius, votes)) . param method Detection method, see #HoughModes. The available methods are <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>. param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> the recommended value is dp=1.5, unless some small very circles need to be detected. param minDist Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. param param1 First method-specific parameter. In case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>, it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> uses <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a> algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images. param param2 Second method-specific parameter. In case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a>, it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> algorithm, this is the circle "perfectness" measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles. param minRadius Minimum circle radius. param maxRadius Maximum circle radius. If &lt;= 0, uses the maximum image dimension. If &lt; 0, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> returns centers without finding the radius. <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> always computes circle radiuses.</p>
<p>SEE: fitEllipse, minEnclosingCircle </p>

</div>
</div>
<a id="ab550320a1153f8b3f9b4dc689bbc3425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab550320a1153f8b3f9b4dc689bbc3425">&#9670;&nbsp;</a></span>HoughCircles() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughCircles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>circles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds circles in a grayscale image using the Hough transform.</p>
<p>The function finds circles in a grayscale image using a modification of the Hough transform.</p>
<p>Example: : INCLUDE: snippets/imgproc_HoughLinesCircles.cpp</p>
<p><b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure.</p>
<p>It also helps to smooth image a bit unless it's already soft. For example, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a95192392e5ce830d79efa0d66da4f2a6">GaussianBlur()</a> with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</p>
<p>param image 8-bit, single-channel, grayscale input image. param circles Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector ((x, y, radius)) or ((x, y, radius, votes)) . param method Detection method, see #HoughModes. The available methods are <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>. param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> the recommended value is dp=1.5, unless some small very circles need to be detected. param minDist Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. param param1 First method-specific parameter. In case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>, it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> uses <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a> algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images. param param2 Second method-specific parameter. In case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a>, it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> algorithm, this is the circle "perfectness" measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles. param minRadius Minimum circle radius. centers without finding the radius. <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> always computes circle radiuses.</p>
<p>SEE: fitEllipse, minEnclosingCircle </p>

</div>
</div>
<a id="a4030205c6e9cd949ed0248133e0b5d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4030205c6e9cd949ed0248133e0b5d49">&#9670;&nbsp;</a></span>HoughCircles() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughCircles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>circles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds circles in a grayscale image using the Hough transform.</p>
<p>The function finds circles in a grayscale image using a modification of the Hough transform.</p>
<p>Example: : INCLUDE: snippets/imgproc_HoughLinesCircles.cpp</p>
<p><b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure.</p>
<p>It also helps to smooth image a bit unless it's already soft. For example, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a95192392e5ce830d79efa0d66da4f2a6">GaussianBlur()</a> with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</p>
<p>param image 8-bit, single-channel, grayscale input image. param circles Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector ((x, y, radius)) or ((x, y, radius, votes)) . param method Detection method, see #HoughModes. The available methods are <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>. param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> the recommended value is dp=1.5, unless some small very circles need to be detected. param minDist Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. param param1 First method-specific parameter. In case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>, it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> uses <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a> algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images. param param2 Second method-specific parameter. In case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a>, it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> algorithm, this is the circle "perfectness" measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles. centers without finding the radius. <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> always computes circle radiuses.</p>
<p>SEE: fitEllipse, minEnclosingCircle </p>

</div>
</div>
<a id="ae0138a4f04075ffb7cfe220ee385cbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0138a4f04075ffb7cfe220ee385cbee">&#9670;&nbsp;</a></span>HoughCircles() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughCircles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>circles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds circles in a grayscale image using the Hough transform.</p>
<p>The function finds circles in a grayscale image using a modification of the Hough transform.</p>
<p>Example: : INCLUDE: snippets/imgproc_HoughLinesCircles.cpp</p>
<p><b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure.</p>
<p>It also helps to smooth image a bit unless it's already soft. For example, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a95192392e5ce830d79efa0d66da4f2a6">GaussianBlur()</a> with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</p>
<p>param image 8-bit, single-channel, grayscale input image. param circles Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector ((x, y, radius)) or ((x, y, radius, votes)) . param method Detection method, see #HoughModes. The available methods are <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>. param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> the recommended value is dp=1.5, unless some small very circles need to be detected. param minDist Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. param param1 First method-specific parameter. In case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>, it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> uses <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a> algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images. accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> algorithm, this is the circle "perfectness" measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles. centers without finding the radius. <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> always computes circle radiuses.</p>
<p>SEE: fitEllipse, minEnclosingCircle </p>

</div>
</div>
<a id="a91802acba604a33a5ce7329f80fb18b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91802acba604a33a5ce7329f80fb18b2">&#9670;&nbsp;</a></span>HoughCircles() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughCircles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>circles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds circles in a grayscale image using the Hough transform.</p>
<p>The function finds circles in a grayscale image using a modification of the Hough transform.</p>
<p>Example: : INCLUDE: snippets/imgproc_HoughLinesCircles.cpp</p>
<p><b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure.</p>
<p>It also helps to smooth image a bit unless it's already soft. For example, <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a95192392e5ce830d79efa0d66da4f2a6">GaussianBlur()</a> with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</p>
<p>param image 8-bit, single-channel, grayscale input image. param circles Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector ((x, y, radius)) or ((x, y, radius, votes)) . param method Detection method, see #HoughModes. The available methods are <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8901d713ebbcaefaa4607d79eca9ad88">HOUGH_GRADIENT</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a>. param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> the recommended value is dp=1.5, unless some small very circles need to be detected. param minDist Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> uses <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a516aaaa89b458b067978906a54f358a9">Scharr</a> algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images. accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> algorithm, this is the circle "perfectness" measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles. centers without finding the radius. <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a27778f2293418e3dfcbd0eba8a63740c">HOUGH_GRADIENT_ALT</a> always computes circle radiuses.</p>
<p>SEE: fitEllipse, minEnclosingCircle </p>

</div>
</div>
<a id="a19c216f3a4af7dd304a02710f9f05d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c216f3a4af7dd304a02710f9f05d42">&#9670;&nbsp;</a></span>HoughLines() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds lines in a binary image using the standard Hough transform.</p>
<p>The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See &lt;<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt;">http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&amp;gt;</a> for a good explanation of Hough transform.</p>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 2 or 3 element vector ((\rho, \theta)) or ((\rho, \theta, \textrm{votes})) . (\rho) is the distance from the coordinate origin ((0,0)) (top-left corner of the image). (\theta) is the line rotation angle in radians ( (0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}) ). (\textrm{votes}) is the value of accumulator. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ). param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. param stn For the multi-scale Hough transform, it is a divisor for the distance resolution theta. param min_theta For standard and multi-scale Hough transform, minimum angle to check for lines. Must fall between 0 and max_theta. param max_theta For standard and multi-scale Hough transform, maximum angle to check for lines. Must fall between min_theta and CV_PI. </p>

</div>
</div>
<a id="a5f0e740e23c0731541f859168cf2db42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0e740e23c0731541f859168cf2db42">&#9670;&nbsp;</a></span>HoughLines() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds lines in a binary image using the standard Hough transform.</p>
<p>The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See &lt;<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt;">http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&amp;gt;</a> for a good explanation of Hough transform.</p>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 2 or 3 element vector ((\rho, \theta)) or ((\rho, \theta, \textrm{votes})) . (\rho) is the distance from the coordinate origin ((0,0)) (top-left corner of the image). (\theta) is the line rotation angle in radians ( (0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}) ). (\textrm{votes}) is the value of accumulator. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ). param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. param stn For the multi-scale Hough transform, it is a divisor for the distance resolution theta. param min_theta For standard and multi-scale Hough transform, minimum angle to check for lines. Must fall between 0 and max_theta. Must fall between min_theta and CV_PI. </p>

</div>
</div>
<a id="a9921989f5714701220fcba97932696ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9921989f5714701220fcba97932696ac">&#9670;&nbsp;</a></span>HoughLines() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds lines in a binary image using the standard Hough transform.</p>
<p>The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See &lt;<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt;">http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&amp;gt;</a> for a good explanation of Hough transform.</p>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 2 or 3 element vector ((\rho, \theta)) or ((\rho, \theta, \textrm{votes})) . (\rho) is the distance from the coordinate origin ((0,0)) (top-left corner of the image). (\theta) is the line rotation angle in radians ( (0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}) ). (\textrm{votes}) is the value of accumulator. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ). param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. param stn For the multi-scale Hough transform, it is a divisor for the distance resolution theta. Must fall between 0 and max_theta. Must fall between min_theta and CV_PI. </p>

</div>
</div>
<a id="a345a7b4f2e8c1d852f86480e601c7f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345a7b4f2e8c1d852f86480e601c7f4e">&#9670;&nbsp;</a></span>HoughLines() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds lines in a binary image using the standard Hough transform.</p>
<p>The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See &lt;<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt;">http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&amp;gt;</a> for a good explanation of Hough transform.</p>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 2 or 3 element vector ((\rho, \theta)) or ((\rho, \theta, \textrm{votes})) . (\rho) is the distance from the coordinate origin ((0,0)) (top-left corner of the image). (\theta) is the line rotation angle in radians ( (0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}) ). (\textrm{votes}) is the value of accumulator. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ). param srn For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. Must fall between 0 and max_theta. Must fall between min_theta and CV_PI. </p>

</div>
</div>
<a id="ad2c2054eb1cbf029ef6ee5e05be10e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c2054eb1cbf029ef6ee5e05be10e26">&#9670;&nbsp;</a></span>HoughLines() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds lines in a binary image using the standard Hough transform.</p>
<p>The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See &lt;<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt;">http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&amp;gt;</a> for a good explanation of Hough transform.</p>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 2 or 3 element vector ((\rho, \theta)) or ((\rho, \theta, \textrm{votes})) . (\rho) is the distance from the coordinate origin ((0,0)) (top-left corner of the image). (\theta) is the line rotation angle in radians ( (0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}) ). (\textrm{votes}) is the value of accumulator. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ). The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. Must fall between 0 and max_theta. Must fall between min_theta and CV_PI. </p>

</div>
</div>
<a id="abcd8ba49f26a5dfd22d8235e9165176e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd8ba49f26a5dfd22d8235e9165176e">&#9670;&nbsp;</a></span>HoughLinesP() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLinesP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minLineLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxLineGap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds line segments in a binary image using the probabilistic Hough transform.</p>
<p>The function implements the probabilistic Hough transform algorithm for line detection, described in CITE: Matas00</p>
<p>See the line detection example below: INCLUDE: snippets/imgproc_HoughLinesP.cpp This is a sample picture the function parameters have been tuned for:</p>
<img src="pics/building.jpg" alt="image" class="inline"/>
<p>And this is the output of the above program in case of the probabilistic Hough transform:</p>
<img src="pics/houghp.png" alt="image" class="inline"/>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 4-element vector ((x_1, y_1, x_2, y_2)) , where ((x_1,y_1)) and ((x_2, y_2)) are the ending points of each detected line segment. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ). param minLineLength Minimum line length. Line segments shorter than that are rejected. param maxLineGap Maximum allowed gap between points on the same line to link them.</p>
<p>SEE: <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> </p>

</div>
</div>
<a id="a268e324c177041662dae3c7eff9ff50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268e324c177041662dae3c7eff9ff50e">&#9670;&nbsp;</a></span>HoughLinesP() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLinesP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minLineLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds line segments in a binary image using the probabilistic Hough transform.</p>
<p>The function implements the probabilistic Hough transform algorithm for line detection, described in CITE: Matas00</p>
<p>See the line detection example below: INCLUDE: snippets/imgproc_HoughLinesP.cpp This is a sample picture the function parameters have been tuned for:</p>
<img src="pics/building.jpg" alt="image" class="inline"/>
<p>And this is the output of the above program in case of the probabilistic Hough transform:</p>
<img src="pics/houghp.png" alt="image" class="inline"/>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 4-element vector ((x_1, y_1, x_2, y_2)) , where ((x_1,y_1)) and ((x_2, y_2)) are the ending points of each detected line segment. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ). param minLineLength Minimum line length. Line segments shorter than that are rejected.</p>
<p>SEE: <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> </p>

</div>
</div>
<a id="a1d1ba9753e9dbd139039df7b343d3605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1ba9753e9dbd139039df7b343d3605">&#9670;&nbsp;</a></span>HoughLinesP() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLinesP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds line segments in a binary image using the probabilistic Hough transform.</p>
<p>The function implements the probabilistic Hough transform algorithm for line detection, described in CITE: Matas00</p>
<p>See the line detection example below: INCLUDE: snippets/imgproc_HoughLinesP.cpp This is a sample picture the function parameters have been tuned for:</p>
<img src="pics/building.jpg" alt="image" class="inline"/>
<p>And this is the output of the above program in case of the probabilistic Hough transform:</p>
<img src="pics/houghp.png" alt="image" class="inline"/>
<p>param image 8-bit, single-channel binary source image. The image may be modified by the function. param lines Output vector of lines. Each line is represented by a 4-element vector ((x_1, y_1, x_2, y_2)) , where ((x_1,y_1)) and ((x_2, y_2)) are the ending points of each detected line segment. param rho Distance resolution of the accumulator in pixels. param theta Angle resolution of the accumulator in radians. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ).</p>
<p>SEE: <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_line_segment_detector.html">LineSegmentDetector</a> </p>

</div>
</div>
<a id="ab626e3f5cc2fc109553bff1a0aa145da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab626e3f5cc2fc109553bff1a0aa145da">&#9670;&nbsp;</a></span>HoughLinesPointSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HoughLinesPointSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lines_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds lines in a set of points using the standard Hough transform.</p>
<p>The function finds lines in a set of points using a modification of the Hough transform. INCLUDE: snippets/imgproc_HoughLinesPointSet.cpp param _point Input vector of points. Each vector must be encoded as a Point vector ((x,y)). Type must be CV_32FC2 or CV_32SC2. param _lines Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt; ((votes, rho, theta)). The larger the value of 'votes', the higher the reliability of the Hough line. param lines_max Max count of hough lines. param threshold Accumulator threshold parameter. Only those lines are returned that get enough votes ( (&gt;\texttt{threshold}) ) param min_rho Minimum Distance value of the accumulator in pixels. param max_rho Maximum Distance value of the accumulator in pixels. param rho_step Distance resolution of the accumulator in pixels. param min_theta Minimum angle value of the accumulator in radians. param max_theta Maximum angle value of the accumulator in radians. param theta_step Angle resolution of the accumulator in radians. </p>

</div>
</div>
<a id="ad0cced1df97e47fe7b5a8aa26fce6318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cced1df97e47fe7b5a8aa26fce6318">&#9670;&nbsp;</a></span>HuMoments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.HuMoments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_moments.html">Moments</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>hu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7de47b4e016e986eb5636b4dbd0e34ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de47b4e016e986eb5636b4dbd0e34ba">&#9670;&nbsp;</a></span>integral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61d91c3655547c49e7ab285b42046313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d91c3655547c49e7ab285b42046313">&#9670;&nbsp;</a></span>integral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad357280d311b6cd6a724d846f378d2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad357280d311b6cd6a724d846f378d2ff">&#9670;&nbsp;</a></span>integral2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sqsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sqdepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ce8dcdac5a8affc068e14c2d6c90951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce8dcdac5a8affc068e14c2d6c90951">&#9670;&nbsp;</a></span>integral2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sqsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30160f0c5c0bc652fffe8c4e29706479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30160f0c5c0bc652fffe8c4e29706479">&#9670;&nbsp;</a></span>integral2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sqsum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41eb4556cf9ec83c9c5010ac233e57f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eb4556cf9ec83c9c5010ac233e57f7">&#9670;&nbsp;</a></span>integral3() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sqsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>tilted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sqdepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the integral of an image.</p>
<p>The function calculates one or more integral images for the source image as follows:</p>
<p>(\texttt{sum} (X,Y) = \sum _{x&lt;X,y&lt;Y} \texttt{image} (x,y))</p>
<p>(\texttt{sqsum} (X,Y) = \sum _{x&lt;X,y&lt;Y} \texttt{image} (x,y)^2)</p>
<p>(\texttt{tilted} (X,Y) = \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1} \texttt{image} (x,y))</p>
<p>Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-right or rotated rectangular region of the image in a constant time, for example:</p>
<p>(\sum _{x_1 \leq x &lt; x_2, \, y_1 \leq y &lt; y_2} \texttt{image} (x,y) = \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1))</p>
<p>It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-channel images, sums for each channel are accumulated independently.</p>
<p>As a practical example, the next figure shows the calculation of the integral of a straight rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the original image are shown, as well as the relative pixels in the integral images sum and tilted .</p>
<img src="pics/integral.png" alt="integral calculation example" class="inline"/>
<p>param src input image as (W \times H), 8-bit or floating-point (32f or 64f). param sum integral image as ((W+1)\times (H+1)) , 32-bit integer or floating-point (32f or 64f). param sqsum integral image for squared pixel values; it is ((W+1)\times (H+1)), double-precision floating-point (64f) array. param tilted integral for the image rotated by 45 degrees; it is ((W+1)\times (H+1)) array with the same data type as sum. param sdepth desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F. param sqdepth desired depth of the integral image of squared pixel values, CV_32F or CV_64F. </p>

</div>
</div>
<a id="ad2cacdf642be42bbd52701d887ea58f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cacdf642be42bbd52701d887ea58f1">&#9670;&nbsp;</a></span>integral3() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sqsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>tilted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the integral of an image.</p>
<p>The function calculates one or more integral images for the source image as follows:</p>
<p>(\texttt{sum} (X,Y) = \sum _{x&lt;X,y&lt;Y} \texttt{image} (x,y))</p>
<p>(\texttt{sqsum} (X,Y) = \sum _{x&lt;X,y&lt;Y} \texttt{image} (x,y)^2)</p>
<p>(\texttt{tilted} (X,Y) = \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1} \texttt{image} (x,y))</p>
<p>Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-right or rotated rectangular region of the image in a constant time, for example:</p>
<p>(\sum _{x_1 \leq x &lt; x_2, \, y_1 \leq y &lt; y_2} \texttt{image} (x,y) = \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1))</p>
<p>It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-channel images, sums for each channel are accumulated independently.</p>
<p>As a practical example, the next figure shows the calculation of the integral of a straight rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the original image are shown, as well as the relative pixels in the integral images sum and tilted .</p>
<img src="pics/integral.png" alt="integral calculation example" class="inline"/>
<p>param src input image as (W \times H), 8-bit or floating-point (32f or 64f). param sum integral image as ((W+1)\times (H+1)) , 32-bit integer or floating-point (32f or 64f). param sqsum integral image for squared pixel values; it is ((W+1)\times (H+1)), double-precision floating-point (64f) array. param tilted integral for the image rotated by 45 degrees; it is ((W+1)\times (H+1)) array with the same data type as sum. param sdepth desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F. </p>

</div>
</div>
<a id="ab9ac2dd520f6993fee65004cae03c633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ac2dd520f6993fee65004cae03c633">&#9670;&nbsp;</a></span>integral3() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.integral3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>sqsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>tilted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the integral of an image.</p>
<p>The function calculates one or more integral images for the source image as follows:</p>
<p>(\texttt{sum} (X,Y) = \sum _{x&lt;X,y&lt;Y} \texttt{image} (x,y))</p>
<p>(\texttt{sqsum} (X,Y) = \sum _{x&lt;X,y&lt;Y} \texttt{image} (x,y)^2)</p>
<p>(\texttt{tilted} (X,Y) = \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1} \texttt{image} (x,y))</p>
<p>Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-right or rotated rectangular region of the image in a constant time, for example:</p>
<p>(\sum _{x_1 \leq x &lt; x_2, \, y_1 \leq y &lt; y_2} \texttt{image} (x,y) = \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1))</p>
<p>It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-channel images, sums for each channel are accumulated independently.</p>
<p>As a practical example, the next figure shows the calculation of the integral of a straight rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the original image are shown, as well as the relative pixels in the integral images sum and tilted .</p>
<img src="pics/integral.png" alt="integral calculation example" class="inline"/>
<p>param src input image as (W \times H), 8-bit or floating-point (32f or 64f). param sum integral image as ((W+1)\times (H+1)) , 32-bit integer or floating-point (32f or 64f). param sqsum integral image for squared pixel values; it is ((W+1)\times (H+1)), double-precision floating-point (64f) array. param tilted integral for the image rotated by 45 degrees; it is ((W+1)\times (H+1)) array with the same data type as sum. CV_64F. </p>

</div>
</div>
<a id="a5d510e341245f6c0e578e697f6a08708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d510e341245f6c0e578e697f6a08708">&#9670;&nbsp;</a></span>intersectConvexConvex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float OpenCVForUnity.ImgprocModule.Imgproc.intersectConvexConvex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_p12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>handleNested</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds intersection of two convex polygons</p>
<p>param _p1 First polygon param _p2 Second polygon param _p12 Output polygon describing the intersecting area param handleNested When true, an intersection is found if one of the polygons is fully enclosed in the other. When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.</p>
<p>return Absolute value of area of intersecting polygon</p>
<p><b>Note:</b> intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't. </p>

</div>
</div>
<a id="aa1226246d1169bc77e10e20096f4097d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1226246d1169bc77e10e20096f4097d">&#9670;&nbsp;</a></span>intersectConvexConvex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float OpenCVForUnity.ImgprocModule.Imgproc.intersectConvexConvex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>_p12</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds intersection of two convex polygons</p>
<p>param _p1 First polygon param _p2 Second polygon param _p12 Output polygon describing the intersecting area When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.</p>
<p>return Absolute value of area of intersecting polygon</p>
<p><b>Note:</b> intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't. </p>

</div>
</div>
<a id="ad80e5dd8a074d21e406024b8e6352a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80e5dd8a074d21e406024b8e6352a60">&#9670;&nbsp;</a></span>invertAffineTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.invertAffineTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>iM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts an affine transformation.</p>
<p>The function computes an inverse affine transformation represented by (2 \times 3) matrix M:</p>
<p>(\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1 \ a_{21} &amp; a_{22} &amp; b_2 \end{bmatrix})</p>
<p>The result is also a (2 \times 3) matrix of the same type as M.</p>
<p>param M Original affine transformation. param iM Output reverse affine transformation. </p>

</div>
</div>
<a id="a75bef198abdf2513529a7479ac216327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bef198abdf2513529a7479ac216327">&#9670;&nbsp;</a></span>isContourConvex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.ImgprocModule.Imgproc.isContourConvex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a>&#160;</td>
          <td class="paramname"><em>contour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests a contour convexity.</p>
<p>The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-intersections. Otherwise, the function output is undefined.</p>
<p>param contour Input vector of 2D points, stored in std::vector&lt;&gt; or Mat return automatically generated </p>

</div>
</div>
<a id="a5509b3da4dae1501415b58701ae73b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5509b3da4dae1501415b58701ae73b27">&#9670;&nbsp;</a></span>Laplacian() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the Laplacian of an image.</p>
<p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p>
<p>(\texttt{dst} = \Delta \texttt{src} = \frac{\partial^2 \texttt{src}}{\partial x^2} + \frac{\partial^2 \texttt{src}}{\partial y^2})</p>
<p>This is done when {code ksize &gt; 1}. When {code ksize == 1}, the Laplacian is computed by filtering the image with the following (3 \times 3) aperture:</p>
<p>(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0})</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Desired depth of the destination image. param ksize Aperture size used to compute the second-derivative filters. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. The size must be positive and odd. param scale Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. param delta Optional delta value that is added to the results prior to storing them in dst . param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. SEE: Sobel, Scharr </p>

</div>
</div>
<a id="ac7d75ac69937ec4e8cbac46dced11564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d75ac69937ec4e8cbac46dced11564">&#9670;&nbsp;</a></span>Laplacian() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the Laplacian of an image.</p>
<p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p>
<p>(\texttt{dst} = \Delta \texttt{src} = \frac{\partial^2 \texttt{src}}{\partial x^2} + \frac{\partial^2 \texttt{src}}{\partial y^2})</p>
<p>This is done when {code ksize &gt; 1}. When {code ksize == 1}, the Laplacian is computed by filtering the image with the following (3 \times 3) aperture:</p>
<p>(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0})</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Desired depth of the destination image. param ksize Aperture size used to compute the second-derivative filters. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. The size must be positive and odd. param scale Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. param delta Optional delta value that is added to the results prior to storing them in dst . SEE: Sobel, Scharr </p>

</div>
</div>
<a id="a0197f22227786c0b30a202be6c11d998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0197f22227786c0b30a202be6c11d998">&#9670;&nbsp;</a></span>Laplacian() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the Laplacian of an image.</p>
<p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p>
<p>(\texttt{dst} = \Delta \texttt{src} = \frac{\partial^2 \texttt{src}}{\partial x^2} + \frac{\partial^2 \texttt{src}}{\partial y^2})</p>
<p>This is done when {code ksize &gt; 1}. When {code ksize == 1}, the Laplacian is computed by filtering the image with the following (3 \times 3) aperture:</p>
<p>(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0})</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Desired depth of the destination image. param ksize Aperture size used to compute the second-derivative filters. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. The size must be positive and odd. param scale Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. SEE: Sobel, Scharr </p>

</div>
</div>
<a id="a7a9764cdd0c3e7b0f5fa94d1c4a12641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9764cdd0c3e7b0f5fa94d1c4a12641">&#9670;&nbsp;</a></span>Laplacian() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the Laplacian of an image.</p>
<p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p>
<p>(\texttt{dst} = \Delta \texttt{src} = \frac{\partial^2 \texttt{src}}{\partial x^2} + \frac{\partial^2 \texttt{src}}{\partial y^2})</p>
<p>This is done when {code ksize &gt; 1}. When {code ksize == 1}, the Laplacian is computed by filtering the image with the following (3 \times 3) aperture:</p>
<p>(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0})</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Desired depth of the destination image. param ksize Aperture size used to compute the second-derivative filters. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. The size must be positive and odd. applied. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. SEE: Sobel, Scharr </p>

</div>
</div>
<a id="a8966c8f326f84067685422b32f53f210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8966c8f326f84067685422b32f53f210">&#9670;&nbsp;</a></span>Laplacian() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Laplacian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the Laplacian of an image.</p>
<p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p>
<p>(\texttt{dst} = \Delta \texttt{src} = \frac{\partial^2 \texttt{src}}{\partial x^2} + \frac{\partial^2 \texttt{src}}{\partial y^2})</p>
<p>This is done when {code ksize &gt; 1}. When {code ksize == 1}, the Laplacian is computed by filtering the image with the following (3 \times 3) aperture:</p>
<p>(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0})</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Desired depth of the destination image. details. The size must be positive and odd. applied. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details. SEE: Sobel, Scharr </p>

</div>
</div>
<a id="a08f6c6182fd1fdb9dec625a253e91eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f6c6182fd1fdb9dec625a253e91eae">&#9670;&nbsp;</a></span>line() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a line segment connecting two points.</p>
<p>The function line draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.</p>
<p>param img Image. param pt1 First point of the line segment. param pt2 Second point of the line segment. param color Line color. param thickness Line thickness. param lineType Type of the line. See #LineTypes. param shift Number of fractional bits in the point coordinates. </p>

</div>
</div>
<a id="a9ff7606a57c910d7e791fb8480bb630f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff7606a57c910d7e791fb8480bb630f">&#9670;&nbsp;</a></span>line() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a line segment connecting two points.</p>
<p>The function line draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.</p>
<p>param img Image. param pt1 First point of the line segment. param pt2 Second point of the line segment. param color Line color. param thickness Line thickness. param lineType Type of the line. See #LineTypes. </p>

</div>
</div>
<a id="a50cef8c19c760a97bb4fa7bca49530f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cef8c19c760a97bb4fa7bca49530f0">&#9670;&nbsp;</a></span>line() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a line segment connecting two points.</p>
<p>The function line draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.</p>
<p>param img Image. param pt1 First point of the line segment. param pt2 Second point of the line segment. param color Line color. param thickness Line thickness. </p>

</div>
</div>
<a id="ae7f4b3c012c42f450f7fa5dda374e16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f4b3c012c42f450f7fa5dda374e16d">&#9670;&nbsp;</a></span>line() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a line segment connecting two points.</p>
<p>The function line draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.</p>
<p>param img Image. param pt1 First point of the line segment. param pt2 Second point of the line segment. param color Line color. </p>

</div>
</div>
<a id="abf8dafda0dc522e6cf5d1625c44b56d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8dafda0dc522e6cf5d1625c44b56d2">&#9670;&nbsp;</a></span>linearPolar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.linearPolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remaps an image to polar coordinates space.</p>
<p>deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags)</p>
<p>Transform the source image using the following transformation (See REF: polar_remaps_reference_image "Polar remaps reference image c)"): (\begin{array}{l} dst( \rho , \phi ) = src(x,y) \ dst.size() \leftarrow src.size() \end{array})</p>
<p>where (\begin{array}{l} I = (dx,dy) = (x - center.x,y - center.y) \ \rho = Kmag \cdot \texttt{magnitude} (I) ,\ \phi = angle \cdot \texttt{angle} (I) \end{array})</p>
<p>and (\begin{array}{l} Kx = src.cols / maxRadius \ Ky = src.rows / 2\Pi \end{array})</p>
<p>param src Source image param dst Destination image. It will have same size and type as src. param center The transformation center; param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too. param flags A combination of interpolation methods, see #InterpolationFlags</p>
<p><b>Note:</b> </p><ul>
<li>
The function can not operate in-place.  </li>
<li>
To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.  </li>
</ul>
<p>SEE: cv::logPolar </p>

</div>
</div>
<a id="a7ec385e49d7fdd3b9a225b3bae24a4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec385e49d7fdd3b9a225b3bae24a4d5">&#9670;&nbsp;</a></span>logPolar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.logPolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remaps an image to semilog-polar coordinates space.</p>
<p>deprecated This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG);</p>
<p>Transform the source image using the following transformation (See REF: polar_remaps_reference_image "Polar remaps reference image d)"): (\begin{array}{l} dst( \rho , \phi ) = src(x,y) \ dst.size() \leftarrow src.size() \end{array})</p>
<p>where (\begin{array}{l} I = (dx,dy) = (x - center.x,y - center.y) \ \rho = M \cdot log_e(\texttt{magnitude} (I)) ,\ \phi = Kangle \cdot \texttt{angle} (I) \ \end{array})</p>
<p>and (\begin{array}{l} M = src.cols / log_e(maxRadius) \ Kangle = src.rows / 2\Pi \ \end{array})</p>
<p>The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking and so forth. param src Source image param dst Destination image. It will have same size and type as src. param center The transformation center; where the output precision is maximal param M Magnitude scale parameter. It determines the radius of the bounding circle to transform too. param flags A combination of interpolation methods, see #InterpolationFlags</p>
<p><b>Note:</b> </p><ul>
<li>
The function can not operate in-place.  </li>
<li>
To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.  </li>
</ul>
<p>SEE: cv::linearPolar </p>

</div>
</div>
<a id="ad4a8652398eacb0d6ee5fdc59cbaa1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a8652398eacb0d6ee5fdc59cbaa1b8">&#9670;&nbsp;</a></span>matchShapes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.matchShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>contour1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>contour2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two shapes.</p>
<p>The function compares two shapes. All three implemented methods use the Hu invariants (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0cced1df97e47fe7b5a8aa26fce6318">HuMoments</a>)</p>
<p>param contour1 First contour or grayscale image. param contour2 Second contour or grayscale image. param method Comparison method, see #ShapeMatchModes param parameter Method-specific parameter (not supported now). return automatically generated </p>

</div>
</div>
<a id="ab3e0eb0521e4f8a96b776fbb5a06c098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e0eb0521e4f8a96b776fbb5a06c098">&#9670;&nbsp;</a></span>matchTemplate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.matchTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a template against overlapped image regions.</p>
<p>The function slides through image , compares the overlapped patches of size (w \times h) against templ using the specified method and stores the comparison results in result . #TemplateMatchModes describes the formulae for the available comparison methods ( (I) denotes image, (T) template, (R) result, (M) the optional mask ). The summation is done over template and/or the image patch: (x' = 0...w-1, y' = 0...h-1)</p>
<p>After the function finishes the comparison, the best matches can be found as global minimums (when <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8bd19998b32f869dd2788a32f2012aaa">TM_SQDIFF</a> was used) or maximums (when <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae12d0027daa5192f434a783a7d1fb568">TM_CCORR</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0391d35422b0e4cee4de5a688438544">TM_CCOEFF</a> was used) using the #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in the denominator is done over all of the channels and separate mean values are used for each channel. That is, the function can take a color template and a color image. The result will still be a single-channel image, which is easier to analyze.</p>
<p>param image Image where the search is running. It must be 8-bit or 32-bit floating-point. param templ Searched template. It must be not greater than the source image and have the same data type. param result Map of comparison results. It must be single-channel 32-bit floating-point. If image is (W \times H) and templ is (w \times h) , then result is ((W-w+1) \times (H-h+1)) . param method Parameter specifying the comparison method, see #TemplateMatchModes param mask Optional mask. It must have the same size as templ. It must either have the same number of channels as template or only one channel, which is then used for all template and image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask, meaning only elements where mask is nonzero are used and are kept unchanged independent of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are used as weights. The exact formulas are documented in #TemplateMatchModes. </p>

</div>
</div>
<a id="a69ac353db3f9a9bc26440af123e1e9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ac353db3f9a9bc26440af123e1e9ad">&#9670;&nbsp;</a></span>matchTemplate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.matchTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a template against overlapped image regions.</p>
<p>The function slides through image , compares the overlapped patches of size (w \times h) against templ using the specified method and stores the comparison results in result . #TemplateMatchModes describes the formulae for the available comparison methods ( (I) denotes image, (T) template, (R) result, (M) the optional mask ). The summation is done over template and/or the image patch: (x' = 0...w-1, y' = 0...h-1)</p>
<p>After the function finishes the comparison, the best matches can be found as global minimums (when <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8bd19998b32f869dd2788a32f2012aaa">TM_SQDIFF</a> was used) or maximums (when <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae12d0027daa5192f434a783a7d1fb568">TM_CCORR</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0391d35422b0e4cee4de5a688438544">TM_CCOEFF</a> was used) using the #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in the denominator is done over all of the channels and separate mean values are used for each channel. That is, the function can take a color template and a color image. The result will still be a single-channel image, which is easier to analyze.</p>
<p>param image Image where the search is running. It must be 8-bit or 32-bit floating-point. param templ Searched template. It must be not greater than the source image and have the same data type. param result Map of comparison results. It must be single-channel 32-bit floating-point. If image is (W \times H) and templ is (w \times h) , then result is ((W-w+1) \times (H-h+1)) . param method Parameter specifying the comparison method, see #TemplateMatchModes of channels as template or only one channel, which is then used for all template and image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask, meaning only elements where mask is nonzero are used and are kept unchanged independent of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are used as weights. The exact formulas are documented in #TemplateMatchModes. </p>

</div>
</div>
<a id="a3b5be8e1cb647bad739ff9bd81d85d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5be8e1cb647bad739ff9bd81d85d4e">&#9670;&nbsp;</a></span>medianBlur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.medianBlur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image using the median filter.</p>
<p>The function smoothes an image using the median filter with the (\texttt{ksize} \times \texttt{ksize}) aperture. Each channel of a multi-channel image is processed independently. In-place operation is supported.</p>
<p><b>Note:</b> The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes</p>
<p>param src input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U. param dst destination array of the same size and type as src. param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ... SEE: bilateralFilter, blur, boxFilter, GaussianBlur </p>

</div>
</div>
<a id="ac4befd98bf52847f7b5efe47550402d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4befd98bf52847f7b5efe47550402d9">&#9670;&nbsp;</a></span>minAreaRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a> OpenCVForUnity.ImgprocModule.Imgproc.minAreaRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds a rotated rectangle of the minimum area enclosing the input 2D point set.</p>
<p>The function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a specified point set. Developer should keep in mind that the returned RotatedRect can contain negative indices when data is close to the containing Mat element boundary.</p>
<p>param points Input vector of 2D points, stored in std::vector&lt;&gt; or Mat return automatically generated </p>

</div>
</div>
<a id="a5fd84df0afa4b362123ca5dc2e7e9a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd84df0afa4b362123ca5dc2e7e9a58">&#9670;&nbsp;</a></span>minEnclosingCircle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.minEnclosingCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float []&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds a circle of the minimum area enclosing a 2D point set.</p>
<p>The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.</p>
<p>param points Input vector of 2D points, stored in std::vector&lt;&gt; or Mat param center Output center of the circle. param radius Output radius of the circle. </p>

</div>
</div>
<a id="a66d8f3c432501f896ab18b5962a38b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d8f3c432501f896ab18b5962a38b8d">&#9670;&nbsp;</a></span>minEnclosingTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.minEnclosingTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>triangle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds a triangle of minimum area enclosing a 2D point set and returns its area.</p>
<p>The function finds a triangle of minimum area enclosing the given set of 2D points and returns its area. The output for a given 2D point set is shown in the image below. 2D points are depicted in red* and the enclosing triangle in <em>yellow</em>.</p>
<img src="pics/minenclosingtriangle.png" alt="Sample output of the minimum enclosing triangle function" class="inline"/>
<p>The implementation of the algorithm is based on O'Rourke's CITE: ORourke86 and Klee and Laskowski's CITE: KleeLaskowski85 papers. O'Rourke provides a (\theta(n)) algorithm for finding the minimal enclosing triangle of a 2D convex polygon with n vertices. Since the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a66d8f3c432501f896ab18b5962a38b8d">minEnclosingTriangle</a> function takes a 2D point set as input an additional preprocessing step of computing the convex hull of the 2D point set is required. The complexity of the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8b420ddcf1093536f060a33e137441df">convexHull</a> function is (O(n log(n))) which is higher than (\theta(n)). Thus the overall complexity of the function is (O(n log(n))).</p>
<p>param points Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector&lt;&gt; or Mat param triangle Output vector of three 2D points defining the vertices of the triangle. The depth of the OutputArray must be CV_32F. return automatically generated </p>

</div>
</div>
<a id="aaa8f0e5b7acaddcc22ea310a284ef31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8f0e5b7acaddcc22ea310a284ef31b">&#9670;&nbsp;</a></span>moments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_moments.html">Moments</a> OpenCVForUnity.ImgprocModule.Imgproc.moments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binaryImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates all of the moments up to the third order of a polygon or rasterized shape.</p>
<p>The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The results are returned in the structure cv::Moments.</p>
<p>param array Raster image (single-channel, 8-bit or floating-point 2D array) or an array ( (1 \times N) or (N \times 1) ) of 2D points (Point or Point2f ). param binaryImage If it is true, all non-zero image pixels are treated as 1's. The parameter is used for images only. return moments.</p>
<p><b>Note:</b> Only applicable to contour moments calculations from Python bindings: Note that the numpy type for the input array should be either np.int32 or np.float32.</p>
<p>SEE: contourArea, arcLength </p>

</div>
</div>
<a id="a63e2391f9647076d893b6a29c340d498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e2391f9647076d893b6a29c340d498">&#9670;&nbsp;</a></span>moments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_moments.html">Moments</a> OpenCVForUnity.ImgprocModule.Imgproc.moments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates all of the moments up to the third order of a polygon or rasterized shape.</p>
<p>The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The results are returned in the structure cv::Moments.</p>
<p>param array Raster image (single-channel, 8-bit or floating-point 2D array) or an array ( (1 \times N) or (N \times 1) ) of 2D points (Point or Point2f ). used for images only. return moments.</p>
<p><b>Note:</b> Only applicable to contour moments calculations from Python bindings: Note that the numpy type for the input array should be either np.int32 or np.float32.</p>
<p>SEE: contourArea, arcLength </p>

</div>
</div>
<a id="a83b3c848d39e08401daf8f1ee005348b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b3c848d39e08401daf8f1ee005348b">&#9670;&nbsp;</a></span>morphologyEx() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.morphologyEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>borderValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs advanced morphological transformations.</p>
<p>The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations.</p>
<p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p>
<p>param src Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst Destination image of the same size and type as source image. param op Type of a morphological operation, see #MorphTypes param kernel Structuring element. It can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor Anchor position with the kernel. Negative values mean that the anchor is at the kernel center. param iterations Number of times erosion and dilation are applied. param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. param borderValue Border value in case of a constant border. The default value has a special meaning. SEE: dilate, erode, getStructuringElement <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a757ead360cf1d467a71d956d538a4e42">MORPH_OPEN</a>) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). </p>

</div>
</div>
<a id="a2b45c49e0e80ac980726b85c26eb810a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b45c49e0e80ac980726b85c26eb810a">&#9670;&nbsp;</a></span>morphologyEx() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.morphologyEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs advanced morphological transformations.</p>
<p>The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations.</p>
<p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p>
<p>param src Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst Destination image of the same size and type as source image. param op Type of a morphological operation, see #MorphTypes param kernel Structuring element. It can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor Anchor position with the kernel. Negative values mean that the anchor is at the kernel center. param iterations Number of times erosion and dilation are applied. param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. meaning. SEE: dilate, erode, getStructuringElement <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a757ead360cf1d467a71d956d538a4e42">MORPH_OPEN</a>) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). </p>

</div>
</div>
<a id="ab3c8810646f7b3986bd787fc3e38ba87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c8810646f7b3986bd787fc3e38ba87">&#9670;&nbsp;</a></span>morphologyEx() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.morphologyEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs advanced morphological transformations.</p>
<p>The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations.</p>
<p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p>
<p>param src Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst Destination image of the same size and type as source image. param op Type of a morphological operation, see #MorphTypes param kernel Structuring element. It can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor Anchor position with the kernel. Negative values mean that the anchor is at the kernel center. param iterations Number of times erosion and dilation are applied. meaning. SEE: dilate, erode, getStructuringElement <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a757ead360cf1d467a71d956d538a4e42">MORPH_OPEN</a>) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). </p>

</div>
</div>
<a id="aeaad4b1047a205e9c0cdc8eb4bb551d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaad4b1047a205e9c0cdc8eb4bb551d3">&#9670;&nbsp;</a></span>morphologyEx() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.morphologyEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs advanced morphological transformations.</p>
<p>The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations.</p>
<p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p>
<p>param src Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst Destination image of the same size and type as source image. param op Type of a morphological operation, see #MorphTypes param kernel Structuring element. It can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. param anchor Anchor position with the kernel. Negative values mean that the anchor is at the kernel center. meaning. SEE: dilate, erode, getStructuringElement <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a757ead360cf1d467a71d956d538a4e42">MORPH_OPEN</a>) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). </p>

</div>
</div>
<a id="aa8530a9fb1785da7e3c1c2d1374fc3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8530a9fb1785da7e3c1c2d1374fc3c2">&#9670;&nbsp;</a></span>morphologyEx() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.morphologyEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs advanced morphological transformations.</p>
<p>The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations.</p>
<p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p>
<p>param src Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. param dst Destination image of the same size and type as source image. param op Type of a morphological operation, see #MorphTypes param kernel Structuring element. It can be created using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a72818a59ccc8afaa8ec04c4da2024205">getStructuringElement</a>. kernel center. meaning. SEE: dilate, erode, getStructuringElement <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a757ead360cf1d467a71d956d538a4e42">MORPH_OPEN</a>) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). </p>

</div>
</div>
<a id="a3fde3b2a54d0e8711c3d7846c5463002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fde3b2a54d0e8711c3d7846c5463002">&#9670;&nbsp;</a></span>phaseCorrelate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> OpenCVForUnity.ImgprocModule.Imgproc.phaseCorrelate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>)   If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks.  </p>
<p>param src1 Source floating point array (CV_32FC1 or CV_64FC1) param src2 Source floating point array (CV_32FC1 or CV_64FC1) param window Floating point array with windowing coefficients to reduce edge effects (optional). param response Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional). return detected phase shift (sub-pixel) between the two arrays.</p>
<p>SEE: dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow </p>

</div>
</div>
<a id="a007ff489328f5a0d15d637054b5596a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007ff489328f5a0d15d637054b5596a2">&#9670;&nbsp;</a></span>phaseCorrelate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> OpenCVForUnity.ImgprocModule.Imgproc.phaseCorrelate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>)   If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks.  </p>
<p>param src1 Source floating point array (CV_32FC1 or CV_64FC1) param src2 Source floating point array (CV_32FC1 or CV_64FC1) param window Floating point array with windowing coefficients to reduce edge effects (optional). return detected phase shift (sub-pixel) between the two arrays.</p>
<p>SEE: dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow </p>

</div>
</div>
<a id="ab8993032331a3ad7f177d315c0f958d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8993032331a3ad7f177d315c0f958d0">&#9670;&nbsp;</a></span>phaseCorrelate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> OpenCVForUnity.ImgprocModule.Imgproc.phaseCorrelate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>)   If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks.  </p>
<p>param src1 Source floating point array (CV_32FC1 or CV_64FC1) param src2 Source floating point array (CV_32FC1 or CV_64FC1) return detected phase shift (sub-pixel) between the two arrays.</p>
<p>SEE: dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow </p>

</div>
</div>
<a id="a09fb74437c933d324569d069b5245230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fb74437c933d324569d069b5245230">&#9670;&nbsp;</a></span>pointPolygonTest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.pointPolygonTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html">MatOfPoint2f</a>&#160;</td>
          <td class="paramname"><em>contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>measureDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a point-in-contour test.</p>
<p>The function determines whether the point is inside a contour, outside, or lies on an edge (or coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge) value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively. Otherwise, the return value is a signed distance between the point and the nearest contour edge.</p>
<p>See below a sample output of the function where each image pixel is tested against the contour:</p>
<img src="pics/pointpolygon.png" alt="sample output" class="inline"/>
<p>param contour Input contour. param pt Point tested against the contour. param measureDist If true, the function estimates the signed distance from the point to the nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not. return automatically generated </p>

</div>
</div>
<a id="ac98ed9aaf79864022c2b3d7fa2f5648c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98ed9aaf79864022c2b3d7fa2f5648c">&#9670;&nbsp;</a></span>polylines() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.polylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws several polygonal curves.</p>
<p>param img Image. param pts Array of polygonal curves. param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. param color Polyline color. param thickness Thickness of the polyline edges. param lineType Type of the line segments. See #LineTypes param shift Number of fractional bits in the vertex coordinates.</p>
<p>The function cv::polylines draws one or more polygonal curves. </p>

</div>
</div>
<a id="aec6ffa373b44b2871ff79ab47f7c92f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6ffa373b44b2871ff79ab47f7c92f4">&#9670;&nbsp;</a></span>polylines() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.polylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws several polygonal curves.</p>
<p>param img Image. param pts Array of polygonal curves. param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. param color Polyline color. param thickness Thickness of the polyline edges. param lineType Type of the line segments. See #LineTypes</p>
<p>The function cv::polylines draws one or more polygonal curves. </p>

</div>
</div>
<a id="a3d85a545d08db9a55cb5f1b9c3fb5bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d85a545d08db9a55cb5f1b9c3fb5bfd">&#9670;&nbsp;</a></span>polylines() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.polylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws several polygonal curves.</p>
<p>param img Image. param pts Array of polygonal curves. param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. param color Polyline color. param thickness Thickness of the polyline edges.</p>
<p>The function cv::polylines draws one or more polygonal curves. </p>

</div>
</div>
<a id="a471a843f77bb16367448538afdad6471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471a843f77bb16367448538afdad6471">&#9670;&nbsp;</a></span>polylines() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.polylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html">MatOfPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws several polygonal curves.</p>
<p>param img Image. param pts Array of polygonal curves. param isClosed Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. param color Polyline color.</p>
<p>The function cv::polylines draws one or more polygonal curves. </p>

</div>
</div>
<a id="aaba7b2fc9dec529238c58205dc6969c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba7b2fc9dec529238c58205dc6969c4">&#9670;&nbsp;</a></span>preCornerDetect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.preCornerDetect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a feature map for corner detection.</p>
<p>The function calculates the complex spatial derivative-based function of the source image</p>
<p>(\texttt{dst} = (D_x \texttt{src} )^2 \cdot D_{yy} \texttt{src} + (D_y \texttt{src} )^2 \cdot D_{xx} \texttt{src} - 2 D_x \texttt{src} \cdot D_y \texttt{src} \cdot D_{xy} \texttt{src})</p>
<p>where (D_x),(D_y) are the first image derivatives, (D_{xx}),(D_{yy}) are the second image derivatives, and (D_{xy}) is the mixed derivative.</p>
<p>The corners can be found as local maximums of the functions, as shown below: <code> Mat corners, dilated_corners; preCornerDetect(image, corners, 3); // dilation with 3x3 rectangular structuring element dilate(corners, dilated_corners, Mat(), 1); Mat corner_mask = corners == dilated_corners; </code></p>
<p>param src Source single-channel 8-bit of floating-point image. param dst Output image that has the type CV_32F and the same size as src . param ksize Aperture size of the Sobel . param borderType Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported. </p>

</div>
</div>
<a id="a87a298b6358b5be1af96ddc1a042fcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a298b6358b5be1af96ddc1a042fcd8">&#9670;&nbsp;</a></span>preCornerDetect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.preCornerDetect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a feature map for corner detection.</p>
<p>The function calculates the complex spatial derivative-based function of the source image</p>
<p>(\texttt{dst} = (D_x \texttt{src} )^2 \cdot D_{yy} \texttt{src} + (D_y \texttt{src} )^2 \cdot D_{xx} \texttt{src} - 2 D_x \texttt{src} \cdot D_y \texttt{src} \cdot D_{xy} \texttt{src})</p>
<p>where (D_x),(D_y) are the first image derivatives, (D_{xx}),(D_{yy}) are the second image derivatives, and (D_{xy}) is the mixed derivative.</p>
<p>The corners can be found as local maximums of the functions, as shown below: <code> Mat corners, dilated_corners; preCornerDetect(image, corners, 3); // dilation with 3x3 rectangular structuring element dilate(corners, dilated_corners, Mat(), 1); Mat corner_mask = corners == dilated_corners; </code></p>
<p>param src Source single-channel 8-bit of floating-point image. param dst Output image that has the type CV_32F and the same size as src . param ksize Aperture size of the Sobel . </p>

</div>
</div>
<a id="aedb6b1f82df67dc5224580d77ea0fb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb6b1f82df67dc5224580d77ea0fb02">&#9670;&nbsp;</a></span>putText() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.putText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fontScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bottomLeftOrigin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a text string.</p>
<p>The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af32d35c17f9443528b2163b3d6371719">getTextSize</a> for a text rendering code example.</p>
<p>param img Image. param text Text string to be drawn. param org Bottom-left corner of the text string in the image. param fontFace Font type, see #HersheyFonts. param fontScale Font scale factor that is multiplied by the font-specific base size. param color Text color. param thickness Thickness of the lines used to draw a text. param lineType Line type. See #LineTypes param bottomLeftOrigin When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner. </p>

</div>
</div>
<a id="af81bb458e42dd2ab94a8d1b07410d189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81bb458e42dd2ab94a8d1b07410d189">&#9670;&nbsp;</a></span>putText() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.putText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fontScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a text string.</p>
<p>The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af32d35c17f9443528b2163b3d6371719">getTextSize</a> for a text rendering code example.</p>
<p>param img Image. param text Text string to be drawn. param org Bottom-left corner of the text string in the image. param fontFace Font type, see #HersheyFonts. param fontScale Font scale factor that is multiplied by the font-specific base size. param color Text color. param thickness Thickness of the lines used to draw a text. param lineType Line type. See #LineTypes it is at the top-left corner. </p>

</div>
</div>
<a id="ab0db98c79737c96a2d9a1ff366998e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0db98c79737c96a2d9a1ff366998e05">&#9670;&nbsp;</a></span>putText() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.putText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fontScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a text string.</p>
<p>The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af32d35c17f9443528b2163b3d6371719">getTextSize</a> for a text rendering code example.</p>
<p>param img Image. param text Text string to be drawn. param org Bottom-left corner of the text string in the image. param fontFace Font type, see #HersheyFonts. param fontScale Font scale factor that is multiplied by the font-specific base size. param color Text color. param thickness Thickness of the lines used to draw a text. it is at the top-left corner. </p>

</div>
</div>
<a id="a262a6d8baa2a6f9a184bc5e42d5a9655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262a6d8baa2a6f9a184bc5e42d5a9655">&#9670;&nbsp;</a></span>putText() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.putText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fontScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a text string.</p>
<p>The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af32d35c17f9443528b2163b3d6371719">getTextSize</a> for a text rendering code example.</p>
<p>param img Image. param text Text string to be drawn. param org Bottom-left corner of the text string in the image. param fontFace Font type, see #HersheyFonts. param fontScale Font scale factor that is multiplied by the font-specific base size. param color Text color. it is at the top-left corner. </p>

</div>
</div>
<a id="af095ac8765714266d30bc24d55bfa068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af095ac8765714266d30bc24d55bfa068">&#9670;&nbsp;</a></span>pyrDown() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dstsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image and downsamples it.</p>
<p>By default, size of the output image is computed as {code Size((src.cols+1)/2, (src.rows+1)/2)}, but in any case, the following conditions should be satisfied:</p>
<p>(\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array})</p>
<p>The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel:</p>
<p>(\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix})</p>
<p>Then, it downsamples the image by rejecting even rows and columns.</p>
<p>param src input image. param dst output image; it has the specified size and the same type as src. param dstsize size of the output image. param borderType Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported) </p>

</div>
</div>
<a id="af5227f72d5d796183271b503a2f5b2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5227f72d5d796183271b503a2f5b2e8">&#9670;&nbsp;</a></span>pyrDown() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dstsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image and downsamples it.</p>
<p>By default, size of the output image is computed as {code Size((src.cols+1)/2, (src.rows+1)/2)}, but in any case, the following conditions should be satisfied:</p>
<p>(\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array})</p>
<p>The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel:</p>
<p>(\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix})</p>
<p>Then, it downsamples the image by rejecting even rows and columns.</p>
<p>param src input image. param dst output image; it has the specified size and the same type as src. param dstsize size of the output image. </p>

</div>
</div>
<a id="a20d074422b89b2d9ccbd5216f86753e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d074422b89b2d9ccbd5216f86753e0">&#9670;&nbsp;</a></span>pyrDown() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blurs an image and downsamples it.</p>
<p>By default, size of the output image is computed as {code Size((src.cols+1)/2, (src.rows+1)/2)}, but in any case, the following conditions should be satisfied:</p>
<p>(\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array})</p>
<p>The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel:</p>
<p>(\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix})</p>
<p>Then, it downsamples the image by rejecting even rows and columns.</p>
<p>param src input image. param dst output image; it has the specified size and the same type as src. </p>

</div>
</div>
<a id="a78838a4dac65a1ae6c5caa88ef9bd149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78838a4dac65a1ae6c5caa88ef9bd149">&#9670;&nbsp;</a></span>pyrMeanShiftFiltering() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrMeanShiftFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>termcrit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs initial step of meanshift segmentation of an image.</p>
<p>The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered "posterized" image with color gradients and fine-grain texture flattened. At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is considered:</p>
<p>((x,y): X- \texttt{sp} \le x \le X+ \texttt{sp} , Y- \texttt{sp} \le y \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)|| \le \texttt{sr})</p>
<p>where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively (though, the algorithm does not depend on the color space used, so any 3-component color space can be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector (R',G',B') are found and they act as the neighborhood center on the next iteration:</p>
<p>((X,Y)~(X',Y'), (R,G,B)~(R',G',B').)</p>
<p>After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration):</p>
<p>(I(X,Y) &lt;- (R*,G*,B*))</p>
<p>When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than sr from the lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.e. when maxLevel==0).</p>
<p>param src The source 8-bit, 3-channel image. param dst The destination image of the same format and the same size as the source. param sp The spatial window radius. param sr The color window radius. param maxLevel Maximum level of the pyramid for the segmentation. param termcrit Termination criteria: when to stop meanshift iterations. </p>

</div>
</div>
<a id="a1c98c7b87159575a278472d88f51c5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c98c7b87159575a278472d88f51c5cd">&#9670;&nbsp;</a></span>pyrMeanShiftFiltering() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrMeanShiftFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs initial step of meanshift segmentation of an image.</p>
<p>The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered "posterized" image with color gradients and fine-grain texture flattened. At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is considered:</p>
<p>((x,y): X- \texttt{sp} \le x \le X+ \texttt{sp} , Y- \texttt{sp} \le y \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)|| \le \texttt{sr})</p>
<p>where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively (though, the algorithm does not depend on the color space used, so any 3-component color space can be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector (R',G',B') are found and they act as the neighborhood center on the next iteration:</p>
<p>((X,Y)~(X',Y'), (R,G,B)~(R',G',B').)</p>
<p>After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration):</p>
<p>(I(X,Y) &lt;- (R*,G*,B*))</p>
<p>When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than sr from the lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.e. when maxLevel==0).</p>
<p>param src The source 8-bit, 3-channel image. param dst The destination image of the same format and the same size as the source. param sp The spatial window radius. param sr The color window radius. param maxLevel Maximum level of the pyramid for the segmentation. </p>

</div>
</div>
<a id="a8c9b3281fb1f948ea9e9ef0a922a655c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b3281fb1f948ea9e9ef0a922a655c">&#9670;&nbsp;</a></span>pyrMeanShiftFiltering() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrMeanShiftFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs initial step of meanshift segmentation of an image.</p>
<p>The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered "posterized" image with color gradients and fine-grain texture flattened. At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is considered:</p>
<p>((x,y): X- \texttt{sp} \le x \le X+ \texttt{sp} , Y- \texttt{sp} \le y \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)|| \le \texttt{sr})</p>
<p>where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively (though, the algorithm does not depend on the color space used, so any 3-component color space can be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector (R',G',B') are found and they act as the neighborhood center on the next iteration:</p>
<p>((X,Y)~(X',Y'), (R,G,B)~(R',G',B').)</p>
<p>After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration):</p>
<p>(I(X,Y) &lt;- (R*,G*,B*))</p>
<p>When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than sr from the lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.e. when maxLevel==0).</p>
<p>param src The source 8-bit, 3-channel image. param dst The destination image of the same format and the same size as the source. param sp The spatial window radius. param sr The color window radius. </p>

</div>
</div>
<a id="a58b6a512cd3ccb5c1165e2a54e0ecee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b6a512cd3ccb5c1165e2a54e0ecee2">&#9670;&nbsp;</a></span>pyrUp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dstsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Upsamples an image and then blurs it.</p>
<p>By default, size of the output image is computed as {code Size(src.cols*2, (src.rows*2)}, but in any case, the following conditions should be satisfied:</p>
<p>(\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq ( \texttt{dstsize.width} \mod 2) \ | \texttt{dstsize.height} -src.rows*2| \leq ( \texttt{dstsize.height} \mod 2) \end{array})</p>
<p>The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in pyrDown multiplied by 4.</p>
<p>param src input image. param dst output image. It has the specified size and the same type as src . param dstsize size of the output image. param borderType Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported) </p>

</div>
</div>
<a id="a07489c4023ab80a46ed4adccddae1aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07489c4023ab80a46ed4adccddae1aa5">&#9670;&nbsp;</a></span>pyrUp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dstsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Upsamples an image and then blurs it.</p>
<p>By default, size of the output image is computed as {code Size(src.cols*2, (src.rows*2)}, but in any case, the following conditions should be satisfied:</p>
<p>(\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq ( \texttt{dstsize.width} \mod 2) \ | \texttt{dstsize.height} -src.rows*2| \leq ( \texttt{dstsize.height} \mod 2) \end{array})</p>
<p>The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in pyrDown multiplied by 4.</p>
<p>param src input image. param dst output image. It has the specified size and the same type as src . param dstsize size of the output image. </p>

</div>
</div>
<a id="aada36bb8545d8c4017480c800da8266a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada36bb8545d8c4017480c800da8266a">&#9670;&nbsp;</a></span>pyrUp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.pyrUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Upsamples an image and then blurs it.</p>
<p>By default, size of the output image is computed as {code Size(src.cols*2, (src.rows*2)}, but in any case, the following conditions should be satisfied:</p>
<p>(\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq ( \texttt{dstsize.width} \mod 2) \ | \texttt{dstsize.height} -src.rows*2| \leq ( \texttt{dstsize.height} \mod 2) \end{array})</p>
<p>The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in pyrDown multiplied by 4.</p>
<p>param src input image. param dst output image. It has the specified size and the same type as src . </p>

</div>
</div>
<a id="af305be5b7e383b14309a26c79a4de7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af305be5b7e383b14309a26c79a4de7a2">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple, thick, or filled up-right rectangle.</p>
<p>The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners are pt1 and pt2.</p>
<p>param img Image. param pt1 Vertex of the rectangle. param pt2 Vertex of the rectangle opposite to pt1 . param color Rectangle color or brightness (grayscale image). param thickness Thickness of lines that make up the rectangle. Negative values, like <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, mean that the function has to draw a filled rectangle. param lineType Type of the line. See #LineTypes param shift Number of fractional bits in the point coordinates. </p>

</div>
</div>
<a id="ad5ef754055d88064bd7130e407aa5c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ef754055d88064bd7130e407aa5c87">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple, thick, or filled up-right rectangle.</p>
<p>The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners are pt1 and pt2.</p>
<p>param img Image. param pt1 Vertex of the rectangle. param pt2 Vertex of the rectangle opposite to pt1 . param color Rectangle color or brightness (grayscale image). param thickness Thickness of lines that make up the rectangle. Negative values, like <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, mean that the function has to draw a filled rectangle. param lineType Type of the line. See #LineTypes </p>

</div>
</div>
<a id="adbced45d096fbc644a4317923dbaf4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbced45d096fbc644a4317923dbaf4f0">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple, thick, or filled up-right rectangle.</p>
<p>The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners are pt1 and pt2.</p>
<p>param img Image. param pt1 Vertex of the rectangle. param pt2 Vertex of the rectangle opposite to pt1 . param color Rectangle color or brightness (grayscale image). param thickness Thickness of lines that make up the rectangle. Negative values, like <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad0981db573c5f55ea0c930075d8240e7">FILLED</a>, mean that the function has to draw a filled rectangle. </p>

</div>
</div>
<a id="a00587eedad371a402e892e2aa33ef51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00587eedad371a402e892e2aa33ef51a">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simple, thick, or filled up-right rectangle.</p>
<p>The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners are pt1 and pt2.</p>
<p>param img Image. param pt1 Vertex of the rectangle. param pt2 Vertex of the rectangle opposite to pt1 . param color Rectangle color or brightness (grayscale image). mean that the function has to draw a filled rectangle. </p>

</div>
</div>
<a id="a0c11a800d85f7cc430d1a35a390d44de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c11a800d85f7cc430d1a35a390d44de">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>use {code rec} parameter as alternative specification of the drawn rectangle: <code>r.tl() and r.br()-Point(1,1)</code> are opposite corners param img automatically generated param rec automatically generated param color automatically generated param thickness automatically generated param lineType automatically generated param shift automatically generated </p>

</div>
</div>
<a id="a39097cc807c5dfebb3cd48f6cd869de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39097cc807c5dfebb3cd48f6cd869de0">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>use {code rec} parameter as alternative specification of the drawn rectangle: <code>r.tl() and r.br()-Point(1,1)</code> are opposite corners param img automatically generated param rec automatically generated param color automatically generated param thickness automatically generated param lineType automatically generated </p>

</div>
</div>
<a id="ad353d33e7ef513840d65c8745b09f1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad353d33e7ef513840d65c8745b09f1b7">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>use {code rec} parameter as alternative specification of the drawn rectangle: <code>r.tl() and r.br()-Point(1,1)</code> are opposite corners param img automatically generated param rec automatically generated param color automatically generated param thickness automatically generated </p>

</div>
</div>
<a id="a85da408f59ec38cdd47c227f20e699e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85da408f59ec38cdd47c227f20e699e5">&#9670;&nbsp;</a></span>rectangle() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>use {code rec} parameter as alternative specification of the drawn rectangle: <code>r.tl() and r.br()-Point(1,1)</code> are opposite corners param img automatically generated param rec automatically generated param color automatically generated </p>

</div>
</div>
<a id="aec52c137086f54b94e1d2b63375b71b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec52c137086f54b94e1d2b63375b71b6">&#9670;&nbsp;</a></span>remap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>borderValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a generic geometrical transformation to an image.</p>
<p>The function remap transforms the source image using the specified map:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} (map_x(x,y),map_y(x,y)))</p>
<p>where values of pixels with non-integer coordinates are computed using one of available interpolation methods. (map_x) and (map_y) can be encoded as separate floating-point maps in (map_1) and (map_2) respectively, or interleaved floating-point maps of ((x,y)) in (map_1), or fixed-point maps created by using convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (2x) remapping operations. In the converted case, (map_1) contains pairs (cvFloor(x), cvFloor(y)) and (map_2) contains indices in a table of interpolation coefficients.</p>
<p>This function cannot operate in-place.</p>
<p>param src Source image. param dst Destination image. It has the same size as map1 and the same type as src . param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point representation to fixed-point for speed. param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively. param interpolation Interpolation method (see #InterpolationFlags). The method <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> is not supported by this function. param borderMode Pixel extrapolation method (see #BorderTypes). When borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that corresponds to the "outliers" in the source image are not modified by the function. param borderValue Value used in case of a constant border. By default, it is 0. <b>Note:</b> Due to current implementation limitations the size of an input and output images should be less than 32767x32767. </p>

</div>
</div>
<a id="a72178fed86c7a059d7e6b99c10bce1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72178fed86c7a059d7e6b99c10bce1c0">&#9670;&nbsp;</a></span>remap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a generic geometrical transformation to an image.</p>
<p>The function remap transforms the source image using the specified map:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} (map_x(x,y),map_y(x,y)))</p>
<p>where values of pixels with non-integer coordinates are computed using one of available interpolation methods. (map_x) and (map_y) can be encoded as separate floating-point maps in (map_1) and (map_2) respectively, or interleaved floating-point maps of ((x,y)) in (map_1), or fixed-point maps created by using convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (2x) remapping operations. In the converted case, (map_1) contains pairs (cvFloor(x), cvFloor(y)) and (map_2) contains indices in a table of interpolation coefficients.</p>
<p>This function cannot operate in-place.</p>
<p>param src Source image. param dst Destination image. It has the same size as map1 and the same type as src . param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point representation to fixed-point for speed. param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively. param interpolation Interpolation method (see #InterpolationFlags). The method <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> is not supported by this function. param borderMode Pixel extrapolation method (see #BorderTypes). When borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that corresponds to the "outliers" in the source image are not modified by the function. <b>Note:</b> Due to current implementation limitations the size of an input and output images should be less than 32767x32767. </p>

</div>
</div>
<a id="a5e6c2b9d2b03739eb7863319c2e69462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6c2b9d2b03739eb7863319c2e69462">&#9670;&nbsp;</a></span>remap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>map2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a generic geometrical transformation to an image.</p>
<p>The function remap transforms the source image using the specified map:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} (map_x(x,y),map_y(x,y)))</p>
<p>where values of pixels with non-integer coordinates are computed using one of available interpolation methods. (map_x) and (map_y) can be encoded as separate floating-point maps in (map_1) and (map_2) respectively, or interleaved floating-point maps of ((x,y)) in (map_1), or fixed-point maps created by using convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (2x) remapping operations. In the converted case, (map_1) contains pairs (cvFloor(x), cvFloor(y)) and (map_2) contains indices in a table of interpolation coefficients.</p>
<p>This function cannot operate in-place.</p>
<p>param src Source image. param dst Destination image. It has the same size as map1 and the same type as src . param map1 The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point representation to fixed-point for speed. param map2 The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively. param interpolation Interpolation method (see #InterpolationFlags). The method <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> is not supported by this function. borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that corresponds to the "outliers" in the source image are not modified by the function. <b>Note:</b> Due to current implementation limitations the size of an input and output images should be less than 32767x32767. </p>

</div>
</div>
<a id="a7ff0030ce002733467640953ecc5b032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff0030ce002733467640953ecc5b032">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interpolation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes an image.</p>
<p>The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the {code src},{code dsize},{code fx}, and {code fy}. If you want to resize src so that it fits the pre-created dst, you may call the function as follows: <code> // explicitly specify dsize=dst.size(); fx and fy will be computed from that. resize(src, dst, dst.size(), 0, 0, interpolation); </code> If you want to decimate the image by factor of 2 in each direction, you can call the function this way: <code> // specify fx and fy and let the function compute the destination image size. resize(src, dst, Size(), 0.5, 0.5, interpolation); </code> To shrink an image, it will generally look best with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> interpolation, whereas to enlarge an image, it will generally look best with c::INTER_CUBIC (slow) or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> (faster but still looks OK).</p>
<p>param src input image. param dst output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src. param dsize output image size; if it equals zero, it is computed as: (\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}) Either dsize or both fx and fy must be non-zero. param fx scale factor along the horizontal axis; when it equals 0, it is computed as (\texttt{(double)dsize.width/src.cols}) param fy scale factor along the vertical axis; when it equals 0, it is computed as (\texttt{(double)dsize.height/src.rows}) param interpolation interpolation method, see #InterpolationFlags</p>
<p>SEE: warpAffine, warpPerspective, remap </p>

</div>
</div>
<a id="a393a0871cd7353170aa47dc96cca13fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393a0871cd7353170aa47dc96cca13fd">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes an image.</p>
<p>The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the {code src},{code dsize},{code fx}, and {code fy}. If you want to resize src so that it fits the pre-created dst, you may call the function as follows: <code> // explicitly specify dsize=dst.size(); fx and fy will be computed from that. resize(src, dst, dst.size(), 0, 0, interpolation); </code> If you want to decimate the image by factor of 2 in each direction, you can call the function this way: <code> // specify fx and fy and let the function compute the destination image size. resize(src, dst, Size(), 0.5, 0.5, interpolation); </code> To shrink an image, it will generally look best with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> interpolation, whereas to enlarge an image, it will generally look best with c::INTER_CUBIC (slow) or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> (faster but still looks OK).</p>
<p>param src input image. param dst output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src. param dsize output image size; if it equals zero, it is computed as: (\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}) Either dsize or both fx and fy must be non-zero. param fx scale factor along the horizontal axis; when it equals 0, it is computed as (\texttt{(double)dsize.width/src.cols}) param fy scale factor along the vertical axis; when it equals 0, it is computed as (\texttt{(double)dsize.height/src.rows})</p>
<p>SEE: warpAffine, warpPerspective, remap </p>

</div>
</div>
<a id="a5453ae767d79b289b3ee56dfb15bd21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5453ae767d79b289b3ee56dfb15bd21c">&#9670;&nbsp;</a></span>resize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes an image.</p>
<p>The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the {code src},{code dsize},{code fx}, and {code fy}. If you want to resize src so that it fits the pre-created dst, you may call the function as follows: <code> // explicitly specify dsize=dst.size(); fx and fy will be computed from that. resize(src, dst, dst.size(), 0, 0, interpolation); </code> If you want to decimate the image by factor of 2 in each direction, you can call the function this way: <code> // specify fx and fy and let the function compute the destination image size. resize(src, dst, Size(), 0.5, 0.5, interpolation); </code> To shrink an image, it will generally look best with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> interpolation, whereas to enlarge an image, it will generally look best with c::INTER_CUBIC (slow) or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> (faster but still looks OK).</p>
<p>param src input image. param dst output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src. param dsize output image size; if it equals zero, it is computed as: (\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}) Either dsize or both fx and fy must be non-zero. param fx scale factor along the horizontal axis; when it equals 0, it is computed as (\texttt{(double)dsize.width/src.cols}) (\texttt{(double)dsize.height/src.rows})</p>
<p>SEE: warpAffine, warpPerspective, remap </p>

</div>
</div>
<a id="a6fd892d0e4767ff0a3fdba7536a1ba06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd892d0e4767ff0a3fdba7536a1ba06">&#9670;&nbsp;</a></span>resize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes an image.</p>
<p>The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the {code src},{code dsize},{code fx}, and {code fy}. If you want to resize src so that it fits the pre-created dst, you may call the function as follows: <code> // explicitly specify dsize=dst.size(); fx and fy will be computed from that. resize(src, dst, dst.size(), 0, 0, interpolation); </code> If you want to decimate the image by factor of 2 in each direction, you can call the function this way: <code> // specify fx and fy and let the function compute the destination image size. resize(src, dst, Size(), 0.5, 0.5, interpolation); </code> To shrink an image, it will generally look best with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acd8569717c58401af4a264b98bcdcb47">INTER_AREA</a> interpolation, whereas to enlarge an image, it will generally look best with c::INTER_CUBIC (slow) or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> (faster but still looks OK).</p>
<p>param src input image. param dst output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src. param dsize output image size; if it equals zero, it is computed as: (\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}) Either dsize or both fx and fy must be non-zero. (\texttt{(double)dsize.width/src.cols}) (\texttt{(double)dsize.height/src.rows})</p>
<p>SEE: warpAffine, warpPerspective, remap </p>

</div>
</div>
<a id="a9f9746115fdc5a58ece2bb322e777b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9746115fdc5a58ece2bb322e777b3c">&#9670;&nbsp;</a></span>rotatedRectangleIntersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.ImgprocModule.Imgproc.rotatedRectangleIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td>
          <td class="paramname"><em>rect1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rotated_rect.html">RotatedRect</a>&#160;</td>
          <td class="paramname"><em>rect2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>intersectingRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds out if there is any intersection between two rotated rectangles.</p>
<p>If there is then the vertices of the intersecting region are returned as well.</p>
<p>Below are some examples of intersection configurations. The hatched pattern indicates the intersecting region and the red vertices are returned by the function.</p>
<img src="pics/intersection.png" alt="intersection examples" class="inline"/>
<p>param rect1 First rectangle param rect2 Second rectangle param intersectingRegion The output array of the vertices of the intersecting region. It returns at most 8 vertices. Stored as std::vector&lt;cv::Point2f&gt; or cv::Mat as Mx1 of type CV_32FC2. return One of #RectanglesIntersectTypes </p>

</div>
</div>
<a id="a516aaaa89b458b067978906a54f358a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516aaaa89b458b067978906a54f358a9">&#9670;&nbsp;</a></span>Scharr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Scharr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first x- or y- image derivative using Scharr operator.</p>
<p>The function computes the first x- or y- spatial image derivative using the Scharr operator. The call</p>
<p>(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)})</p>
<p>is equivalent to</p>
<p>(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .)</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth output image depth, see REF: filter_depths "combinations" param dx order of the derivative x. param dy order of the derivative y. param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). param delta optional delta value that is added to the results prior to storing them in dst. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. SEE: cartToPolar </p>

</div>
</div>
<a id="a010ac218e6fe02a907c5b1c0b9c423fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010ac218e6fe02a907c5b1c0b9c423fe">&#9670;&nbsp;</a></span>Scharr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Scharr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first x- or y- image derivative using Scharr operator.</p>
<p>The function computes the first x- or y- spatial image derivative using the Scharr operator. The call</p>
<p>(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)})</p>
<p>is equivalent to</p>
<p>(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .)</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth output image depth, see REF: filter_depths "combinations" param dx order of the derivative x. param dy order of the derivative y. param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). param delta optional delta value that is added to the results prior to storing them in dst. SEE: cartToPolar </p>

</div>
</div>
<a id="a29a39fa047400e8c9cc308d8ccb9971a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a39fa047400e8c9cc308d8ccb9971a">&#9670;&nbsp;</a></span>Scharr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Scharr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first x- or y- image derivative using Scharr operator.</p>
<p>The function computes the first x- or y- spatial image derivative using the Scharr operator. The call</p>
<p>(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)})</p>
<p>is equivalent to</p>
<p>(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .)</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth output image depth, see REF: filter_depths "combinations" param dx order of the derivative x. param dy order of the derivative y. param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). SEE: cartToPolar </p>

</div>
</div>
<a id="a91a66651017d30b92549d583ef343685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a66651017d30b92549d583ef343685">&#9670;&nbsp;</a></span>Scharr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Scharr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first x- or y- image derivative using Scharr operator.</p>
<p>The function computes the first x- or y- spatial image derivative using the Scharr operator. The call</p>
<p>(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)})</p>
<p>is equivalent to</p>
<p>(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .)</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src. param ddepth output image depth, see REF: filter_depths "combinations" param dx order of the derivative x. param dy order of the derivative y. applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). SEE: cartToPolar </p>

</div>
</div>
<a id="a283f8733d3d2de422385d88e70b51f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283f8733d3d2de422385d88e70b51f19">&#9670;&nbsp;</a></span>sepFilter2D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sepFilter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a separable linear filter to an image.</p>
<p>The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst .</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Destination image depth, see REF: filter_depths "combinations" param kernelX Coefficients for filtering each row. param kernelY Coefficients for filtering each column. param anchor Anchor position within the kernel. The default value ((-1,-1)) means that the anchor is at the kernel center. param delta Value added to the filtered results before storing them. param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. SEE: filter2D, Sobel, GaussianBlur, boxFilter, blur </p>

</div>
</div>
<a id="a258308a6c84af634a7dad5a288c64a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258308a6c84af634a7dad5a288c64a3e">&#9670;&nbsp;</a></span>sepFilter2D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sepFilter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a separable linear filter to an image.</p>
<p>The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst .</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Destination image depth, see REF: filter_depths "combinations" param kernelX Coefficients for filtering each row. param kernelY Coefficients for filtering each column. param anchor Anchor position within the kernel. The default value ((-1,-1)) means that the anchor is at the kernel center. param delta Value added to the filtered results before storing them. SEE: filter2D, Sobel, GaussianBlur, boxFilter, blur </p>

</div>
</div>
<a id="a00c4d9909ca5a59b8ad3e9e77e528e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c4d9909ca5a59b8ad3e9e77e528e0e">&#9670;&nbsp;</a></span>sepFilter2D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sepFilter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a separable linear filter to an image.</p>
<p>The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst .</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Destination image depth, see REF: filter_depths "combinations" param kernelX Coefficients for filtering each row. param kernelY Coefficients for filtering each column. param anchor Anchor position within the kernel. The default value ((-1,-1)) means that the anchor is at the kernel center. SEE: filter2D, Sobel, GaussianBlur, boxFilter, blur </p>

</div>
</div>
<a id="ac1762ace53f93346a490a8948a946cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1762ace53f93346a490a8948a946cf0">&#9670;&nbsp;</a></span>sepFilter2D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sepFilter2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>kernelY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a separable linear filter to an image.</p>
<p>The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst .</p>
<p>param src Source image. param dst Destination image of the same size and the same number of channels as src . param ddepth Destination image depth, see REF: filter_depths "combinations" param kernelX Coefficients for filtering each row. param kernelY Coefficients for filtering each column. is at the kernel center. SEE: filter2D, Sobel, GaussianBlur, boxFilter, blur </p>

</div>
</div>
<a id="aedc11d47ee5206e9b6b56ae0796e1c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc11d47ee5206e9b6b56ae0796e1c88">&#9670;&nbsp;</a></span>Sobel() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Sobel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p>
<p>In all cases except one, the (\texttt{ksize} \times \texttt{ksize}) separable kernel is used to calculate the derivative. When (\texttt{ksize = 1}), the (3 \times 1) or (1 \times 3) kernel is used (that is, no Gaussian smoothing is done). {code ksize = 1} can only be used for the first or the second x- or y- derivatives.</p>
<p>There is also the special value {code ksize = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a347be864656deaf36444c5a95db2dc">FILTER_SCHARR</a> (-1)} that corresponds to the (3\times3) Scharr filter that may give more accurate results than the (3\times3) Sobel. The Scharr aperture is</p>
<p>(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3})</p>
<p>for the x-derivative, or transposed for the y-derivative.</p>
<p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p>
<p>(\texttt{dst} = \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}})</p>
<p>The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1})</p>
<p>The second case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1})</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src . param ddepth output image depth, see REF: filter_depths "combinations"; in the case of 8-bit input images it will result in truncated derivatives. param dx order of the derivative x. param dy order of the derivative y. param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7. param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). param delta optional delta value that is added to the results prior to storing them in dst. param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. SEE: Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar </p>

</div>
</div>
<a id="aa541796245127554b0585c07880dea53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa541796245127554b0585c07880dea53">&#9670;&nbsp;</a></span>Sobel() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Sobel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p>
<p>In all cases except one, the (\texttt{ksize} \times \texttt{ksize}) separable kernel is used to calculate the derivative. When (\texttt{ksize = 1}), the (3 \times 1) or (1 \times 3) kernel is used (that is, no Gaussian smoothing is done). {code ksize = 1} can only be used for the first or the second x- or y- derivatives.</p>
<p>There is also the special value {code ksize = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a347be864656deaf36444c5a95db2dc">FILTER_SCHARR</a> (-1)} that corresponds to the (3\times3) Scharr filter that may give more accurate results than the (3\times3) Sobel. The Scharr aperture is</p>
<p>(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3})</p>
<p>for the x-derivative, or transposed for the y-derivative.</p>
<p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p>
<p>(\texttt{dst} = \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}})</p>
<p>The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1})</p>
<p>The second case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1})</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src . param ddepth output image depth, see REF: filter_depths "combinations"; in the case of 8-bit input images it will result in truncated derivatives. param dx order of the derivative x. param dy order of the derivative y. param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7. param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). param delta optional delta value that is added to the results prior to storing them in dst. SEE: Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar </p>

</div>
</div>
<a id="a8640141faf04538817b310375592c8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8640141faf04538817b310375592c8f5">&#9670;&nbsp;</a></span>Sobel() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Sobel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p>
<p>In all cases except one, the (\texttt{ksize} \times \texttt{ksize}) separable kernel is used to calculate the derivative. When (\texttt{ksize = 1}), the (3 \times 1) or (1 \times 3) kernel is used (that is, no Gaussian smoothing is done). {code ksize = 1} can only be used for the first or the second x- or y- derivatives.</p>
<p>There is also the special value {code ksize = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a347be864656deaf36444c5a95db2dc">FILTER_SCHARR</a> (-1)} that corresponds to the (3\times3) Scharr filter that may give more accurate results than the (3\times3) Sobel. The Scharr aperture is</p>
<p>(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3})</p>
<p>for the x-derivative, or transposed for the y-derivative.</p>
<p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p>
<p>(\texttt{dst} = \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}})</p>
<p>The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1})</p>
<p>The second case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1})</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src . param ddepth output image depth, see REF: filter_depths "combinations"; in the case of 8-bit input images it will result in truncated derivatives. param dx order of the derivative x. param dy order of the derivative y. param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7. param scale optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). SEE: Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar </p>

</div>
</div>
<a id="a91d8dbb38914310680f3f07542fbf7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d8dbb38914310680f3f07542fbf7c3">&#9670;&nbsp;</a></span>Sobel() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Sobel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p>
<p>In all cases except one, the (\texttt{ksize} \times \texttt{ksize}) separable kernel is used to calculate the derivative. When (\texttt{ksize = 1}), the (3 \times 1) or (1 \times 3) kernel is used (that is, no Gaussian smoothing is done). {code ksize = 1} can only be used for the first or the second x- or y- derivatives.</p>
<p>There is also the special value {code ksize = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a347be864656deaf36444c5a95db2dc">FILTER_SCHARR</a> (-1)} that corresponds to the (3\times3) Scharr filter that may give more accurate results than the (3\times3) Sobel. The Scharr aperture is</p>
<p>(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3})</p>
<p>for the x-derivative, or transposed for the y-derivative.</p>
<p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p>
<p>(\texttt{dst} = \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}})</p>
<p>The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1})</p>
<p>The second case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1})</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src . param ddepth output image depth, see REF: filter_depths "combinations"; in the case of 8-bit input images it will result in truncated derivatives. param dx order of the derivative x. param dy order of the derivative y. param ksize size of the extended Sobel kernel; it must be 1, 3, 5, or 7. applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). SEE: Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar </p>

</div>
</div>
<a id="aa07263af90084b6a94e630d18d11dcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07263af90084b6a94e630d18d11dcdd">&#9670;&nbsp;</a></span>Sobel() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.Sobel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p>
<p>In all cases except one, the (\texttt{ksize} \times \texttt{ksize}) separable kernel is used to calculate the derivative. When (\texttt{ksize = 1}), the (3 \times 1) or (1 \times 3) kernel is used (that is, no Gaussian smoothing is done). {code ksize = 1} can only be used for the first or the second x- or y- derivatives.</p>
<p>There is also the special value {code ksize = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8a347be864656deaf36444c5a95db2dc">FILTER_SCHARR</a> (-1)} that corresponds to the (3\times3) Scharr filter that may give more accurate results than the (3\times3) Sobel. The Scharr aperture is</p>
<p>(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3})</p>
<p>for the x-derivative, or transposed for the y-derivative.</p>
<p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p>
<p>(\texttt{dst} = \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}})</p>
<p>The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1})</p>
<p>The second case corresponds to a kernel of:</p>
<p>(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1})</p>
<p>param src input image. param dst output image of the same size and the same number of channels as src . param ddepth output image depth, see REF: filter_depths "combinations"; in the case of 8-bit input images it will result in truncated derivatives. param dx order of the derivative x. param dy order of the derivative y. applied (see <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae449bb66300f367c5c3efef85954520a">getDerivKernels</a> for details). SEE: Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar </p>

</div>
</div>
<a id="a17a69131018461ba1390bf7c31b8966e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a69131018461ba1390bf7c31b8966e">&#9670;&nbsp;</a></span>spatialGradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.spatialGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first order image derivative in both x and y using a Sobel operator</p>
<p>Equivalent to calling:</p>
<p><code> Sobel( src, dx, CV_16SC1, 1, 0, 3 ); Sobel( src, dy, CV_16SC1, 0, 1, 3 ); </code></p>
<p>param src input image. param dx output image with first-order derivative in x. param dy output image with first-order derivative in y. param ksize size of Sobel kernel. It must be 3. param borderType pixel extrapolation method, see #BorderTypes. Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.</p>
<p>SEE: Sobel </p>

</div>
</div>
<a id="ae663bf8a7ccc7ac59ada1cf7c6b83d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae663bf8a7ccc7ac59ada1cf7c6b83d14">&#9670;&nbsp;</a></span>spatialGradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.spatialGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first order image derivative in both x and y using a Sobel operator</p>
<p>Equivalent to calling:</p>
<p><code> Sobel( src, dx, CV_16SC1, 1, 0, 3 ); Sobel( src, dy, CV_16SC1, 0, 1, 3 ); </code></p>
<p>param src input image. param dx output image with first-order derivative in x. param dy output image with first-order derivative in y. param ksize size of Sobel kernel. It must be 3. Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.</p>
<p>SEE: Sobel </p>

</div>
</div>
<a id="a60384a42f9d0ea9aac40bea76dfa5c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60384a42f9d0ea9aac40bea76dfa5c8c">&#9670;&nbsp;</a></span>spatialGradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.spatialGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the first order image derivative in both x and y using a Sobel operator</p>
<p>Equivalent to calling:</p>
<p><code> Sobel( src, dx, CV_16SC1, 1, 0, 3 ); Sobel( src, dy, CV_16SC1, 0, 1, 3 ); </code></p>
<p>param src input image. param dx output image with first-order derivative in x. param dy output image with first-order derivative in y. Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.</p>
<p>SEE: Sobel </p>

</div>
</div>
<a id="ad52ac9645596e3a21376519d69b57729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52ac9645596e3a21376519d69b57729">&#9670;&nbsp;</a></span>sqrBoxFilter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sqrBoxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the normalized sum of squares of the pixel values overlapping the filter.</p>
<p>For every pixel ( (x, y) ) in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel ( (x, y) ).</p>
<p>The unnormalized square box filter can be useful in computing local image statistics such as the the local variance and standard deviation around the neighborhood of a pixel.</p>
<p>param src input image param dst output image of the same size and type as _src param ddepth the output image depth (-1 to use src.depth()) param ksize kernel size param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel center. param normalize flag, specifying whether the kernel is to be normalized by it's area or not. param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. SEE: boxFilter </p>

</div>
</div>
<a id="a1f1852560876d37662a782e222f1b80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1852560876d37662a782e222f1b80e">&#9670;&nbsp;</a></span>sqrBoxFilter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sqrBoxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the normalized sum of squares of the pixel values overlapping the filter.</p>
<p>For every pixel ( (x, y) ) in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel ( (x, y) ).</p>
<p>The unnormalized square box filter can be useful in computing local image statistics such as the the local variance and standard deviation around the neighborhood of a pixel.</p>
<p>param src input image param dst output image of the same size and type as _src param ddepth the output image depth (-1 to use src.depth()) param ksize kernel size param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel center. param normalize flag, specifying whether the kernel is to be normalized by it's area or not. SEE: boxFilter </p>

</div>
</div>
<a id="a06e64eb3878dac69e291a3d873f7e1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e64eb3878dac69e291a3d873f7e1be">&#9670;&nbsp;</a></span>sqrBoxFilter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sqrBoxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the normalized sum of squares of the pixel values overlapping the filter.</p>
<p>For every pixel ( (x, y) ) in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel ( (x, y) ).</p>
<p>The unnormalized square box filter can be useful in computing local image statistics such as the the local variance and standard deviation around the neighborhood of a pixel.</p>
<p>param src input image param dst output image of the same size and type as _src param ddepth the output image depth (-1 to use src.depth()) param ksize kernel size param anchor kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel center. SEE: boxFilter </p>

</div>
</div>
<a id="a44a46f76cfe16a69ebffe4862b6b75e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a46f76cfe16a69ebffe4862b6b75e9">&#9670;&nbsp;</a></span>sqrBoxFilter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.sqrBoxFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>ksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the normalized sum of squares of the pixel values overlapping the filter.</p>
<p>For every pixel ( (x, y) ) in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel ( (x, y) ).</p>
<p>The unnormalized square box filter can be useful in computing local image statistics such as the the local variance and standard deviation around the neighborhood of a pixel.</p>
<p>param src input image param dst output image of the same size and type as _src param ddepth the output image depth (-1 to use src.depth()) param ksize kernel size center. SEE: boxFilter </p>

</div>
</div>
<a id="a0bddd2f479a606944d19b3bca2dd208a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bddd2f479a606944d19b3bca2dd208a">&#9670;&nbsp;</a></span>threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.ImgprocModule.Imgproc.threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a fixed-level threshold to each array element.</p>
<p>The function applies fixed-level thresholding to a multiple-channel array. The function is typically used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for this purpose) or for removing a noise, that is, filtering out pixels with too small or too large values. There are several types of thresholding supported by the function. They are determined by type parameter.</p>
<p>Also, the special values <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a32501a520c81dbdb6241d128abd3bba8">THRESH_OTSU</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae5b309160d855309ccdb47dd0097fa50">THRESH_TRIANGLE</a> may be combined with one of the above values. In these cases, the function determines the optimal threshold value using the Otsu's or Triangle algorithm and uses it instead of the specified thresh.</p>
<p><b>Note:</b> Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.</p>
<p>param src input array (multiple-channel, 8-bit or 32-bit floating point). param dst output array of the same size and type and the same number of channels as src. param thresh threshold value. param maxval maximum value to use with the <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a67e028e91805b98470871674c698bfad">THRESH_BINARY</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a59df462c043ae03de2521b1ba9bf7849">THRESH_BINARY_INV</a> thresholding types. param type thresholding type (see #ThresholdTypes). return the computed threshold value if Otsu's or Triangle methods used.</p>
<p>SEE: adaptiveThreshold, findContours, compare, min, max </p>

</div>
</div>
<a id="a74017885add09e19513333b797acc29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74017885add09e19513333b797acc29b">&#9670;&nbsp;</a></span>warpAffine() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpAffine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>borderValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies an affine transformation to an image.</p>
<p>The function warpAffine transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} ( \texttt{M} _{11} x + \texttt{M} _{12} y + \texttt{M} _{13}, \texttt{M} _{21} x + \texttt{M} _{22} y + \texttt{M} _{23}))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad80e5dd8a074d21e406024b8e6352a60">invertAffineTransform</a> and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (2\times 3) transformation matrix. param dsize size of the output image. param flags combination of interpolation methods (see #InterpolationFlags) and the optional flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> that means that M is the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ). param borderMode pixel extrapolation method (see #BorderTypes); when borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the "outliers" in the source image are not modified by the function. param borderValue value used in case of a constant border; by default, it is 0.</p>
<p>SEE: warpPerspective, resize, remap, getRectSubPix, transform </p>

</div>
</div>
<a id="a8e455da67fca53faf645fbb93230bcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e455da67fca53faf645fbb93230bcec">&#9670;&nbsp;</a></span>warpAffine() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpAffine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies an affine transformation to an image.</p>
<p>The function warpAffine transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} ( \texttt{M} _{11} x + \texttt{M} _{12} y + \texttt{M} _{13}, \texttt{M} _{21} x + \texttt{M} _{22} y + \texttt{M} _{23}))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad80e5dd8a074d21e406024b8e6352a60">invertAffineTransform</a> and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (2\times 3) transformation matrix. param dsize size of the output image. param flags combination of interpolation methods (see #InterpolationFlags) and the optional flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> that means that M is the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ). param borderMode pixel extrapolation method (see #BorderTypes); when borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the "outliers" in the source image are not modified by the function.</p>
<p>SEE: warpPerspective, resize, remap, getRectSubPix, transform </p>

</div>
</div>
<a id="acc765385b9a1a5f4e886ae5f0e9be52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc765385b9a1a5f4e886ae5f0e9be52f">&#9670;&nbsp;</a></span>warpAffine() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpAffine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies an affine transformation to an image.</p>
<p>The function warpAffine transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} ( \texttt{M} _{11} x + \texttt{M} _{12} y + \texttt{M} _{13}, \texttt{M} _{21} x + \texttt{M} _{22} y + \texttt{M} _{23}))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad80e5dd8a074d21e406024b8e6352a60">invertAffineTransform</a> and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (2\times 3) transformation matrix. param dsize size of the output image. param flags combination of interpolation methods (see #InterpolationFlags) and the optional flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> that means that M is the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ). borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the "outliers" in the source image are not modified by the function.</p>
<p>SEE: warpPerspective, resize, remap, getRectSubPix, transform </p>

</div>
</div>
<a id="a4fce376b00ed93819988045ab996568e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fce376b00ed93819988045ab996568e">&#9670;&nbsp;</a></span>warpAffine() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpAffine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies an affine transformation to an image.</p>
<p>The function warpAffine transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} ( \texttt{M} _{11} x + \texttt{M} _{12} y + \texttt{M} _{13}, \texttt{M} _{21} x + \texttt{M} _{22} y + \texttt{M} _{23}))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad80e5dd8a074d21e406024b8e6352a60">invertAffineTransform</a> and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (2\times 3) transformation matrix. param dsize size of the output image. flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> that means that M is the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ). borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the "outliers" in the source image are not modified by the function.</p>
<p>SEE: warpPerspective, resize, remap, getRectSubPix, transform </p>

</div>
</div>
<a id="a4244b84548efc2bac7b546fda04c6638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4244b84548efc2bac7b546fda04c6638">&#9670;&nbsp;</a></span>warpPerspective() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpPerspective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>borderValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a perspective transformation to an image.</p>
<p>The function warpPerspective transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right ))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (3\times 3) transformation matrix. param dsize size of the output image. param flags combination of interpolation methods (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a74743d222b543bc6f12feb87f31a9c55">INTER_NEAREST</a>) and the optional flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a>, that sets M as the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ). param borderMode pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE). param borderValue value used in case of a constant border; by default, it equals 0.</p>
<p>SEE: warpAffine, resize, remap, getRectSubPix, perspectiveTransform </p>

</div>
</div>
<a id="a17c7bf372363a627086c6ad8d7c4b263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c7bf372363a627086c6ad8d7c4b263">&#9670;&nbsp;</a></span>warpPerspective() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpPerspective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a perspective transformation to an image.</p>
<p>The function warpPerspective transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right ))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (3\times 3) transformation matrix. param dsize size of the output image. param flags combination of interpolation methods (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a74743d222b543bc6f12feb87f31a9c55">INTER_NEAREST</a>) and the optional flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a>, that sets M as the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ). param borderMode pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).</p>
<p>SEE: warpAffine, resize, remap, getRectSubPix, perspectiveTransform </p>

</div>
</div>
<a id="a5373db668c96e38044d1fb705359085e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5373db668c96e38044d1fb705359085e">&#9670;&nbsp;</a></span>warpPerspective() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpPerspective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a perspective transformation to an image.</p>
<p>The function warpPerspective transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right ))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (3\times 3) transformation matrix. param dsize size of the output image. param flags combination of interpolation methods (<a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7e16d35f425f556033afeef60210a02c">INTER_LINEAR</a> or <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a74743d222b543bc6f12feb87f31a9c55">INTER_NEAREST</a>) and the optional flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a>, that sets M as the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ).</p>
<p>SEE: warpAffine, resize, remap, getRectSubPix, perspectiveTransform </p>

</div>
</div>
<a id="a4428aeec0a11749cf229d7b8245d2d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4428aeec0a11749cf229d7b8245d2d39">&#9670;&nbsp;</a></span>warpPerspective() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpPerspective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a perspective transformation to an image.</p>
<p>The function warpPerspective transforms the source image using the specified matrix:</p>
<p>(\texttt{dst} (x,y) = \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right ))</p>
<p>when the flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place.</p>
<p>param src input image. param dst output image that has the size dsize and the same type as src . param M (3\times 3) transformation matrix. param dsize size of the output image. optional flag <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a>, that sets M as the inverse transformation ( (\texttt{dst}\rightarrow\texttt{src}) ).</p>
<p>SEE: warpAffine, resize, remap, getRectSubPix, perspectiveTransform </p>

</div>
</div>
<a id="a477a82bb12e39cb4e7c09059f8a9d50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477a82bb12e39cb4e7c09059f8a9d50b">&#9670;&nbsp;</a></span>warpPolar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.warpPolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remaps an image to polar or semilog-polar coordinates space</p>
<p>polar_remaps_reference_image <img src="pics/polar_remap_doc.png" alt="Polar remaps reference" class="inline"/>
<p>Transform the source image using the following transformation: ( dst(\rho , \phi ) = src(x,y) )</p>
<p>where ( \begin{array}{l} \vec{I} = (x - center.x, \;y - center.y) \ \phi = Kangle \cdot \texttt{angle} (\vec{I}) \ \rho = \left\begin{matrix} Klin \cdot \texttt{magnitude} (\vec{I}) &amp; default \ Klog \cdot log_e(\texttt{magnitude} (\vec{I})) &amp; if \; semilog \ \end{matrix}\right. \end{array} )</p>
<p>and ( \begin{array}{l} Kangle = dsize.height / 2\Pi \ Klin = dsize.width / maxRadius \ Klog = dsize.width / log_e(maxRadius) \ \end{array} )</p>
<dl class="section user"><dt>Linear vs semilog mapping</dt><dd></dd></dl>
<p>Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to {code flags} to specify the polar mapping mode.</p>
<p>Linear is the default mode.</p>
<p>The semilog mapping emulates the human "foveal" vision that permit very high acuity on the line of sight (central vision) in contrast to peripheral vision where acuity is minor.</p>
<dl class="section user"><dt>Option on {code dsize}:</dt><dd></dd></dl>
<ul>
<li>
if both values in {code dsize &lt;=0 } (default), the destination image will have (almost) same area of source bounding circle: (\begin{array}{l} dsize.area \leftarrow (maxRadius^2 \cdot \Pi) \ dsize.width = \texttt{cvRound}(maxRadius) \ dsize.height = \texttt{cvRound}(maxRadius \cdot \Pi) \ \end{array})  </li>
</ul>
<ul>
<li>
if only {code dsize.height &lt;= 0}, the destination image area will be proportional to the bounding circle area but scaled by {code Kx * Kx}: (\begin{array}{l} dsize.height = \texttt{cvRound}(dsize.width \cdot \Pi) \ \end{array} )  </li>
</ul>
<ul>
<li>
if both values in {code dsize &gt; 0 }, the destination image will have the given size therefore the area of the bounding circle will be scaled to {code dsize}.  </li>
</ul>
<dl class="section user"><dt>Reverse mapping</dt><dd></dd></dl>
<p>You can get reverse mapping adding <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> to {code flags} </p><div class="fragment"></div><!-- fragment --><p> In addiction, to calculate the original coordinate from a polar mapped coordinate ((rho, phi)-&gt;(x, y)): </p><div class="fragment"></div><!-- fragment --><p> param src Source image. param dst Destination image. It will have same type as src. param dsize The destination image size (see description for valid options). param center The transformation center. param maxRadius The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too. param flags A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode. </p><ul>
<li>
Add <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aeb7de6327fef811bfbdc7fc5a46e333f">WARP_POLAR_LINEAR</a> to select linear polar mapping (default)  </li>
<li>
Add <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa2e5836cf9fb0f2e251dfa76e85f15fc">WARP_POLAR_LOG</a> to select semilog polar mapping  </li>
<li>
Add <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a905d5a97e2f56183b8b9140c641f27f3">WARP_INVERSE_MAP</a> for reverse mapping.  </li>
</ul>
<p><b>Note:</b> </p><ul>
<li>
The function can not operate in-place.  </li>
<li>
To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.  </li>
<li>
This function uses <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aec52c137086f54b94e1d2b63375b71b6">remap</a>. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.  </li>
</ul>
<p>SEE: cv::remap </p>

</div>
</div>
<a id="aef9ea60d31b293a1141b609885d8c893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9ea60d31b293a1141b609885d8c893">&#9670;&nbsp;</a></span>watershed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.ImgprocModule.Imgproc.watershed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td>
          <td class="paramname"><em>markers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a marker-based image segmentation using the watershed algorithm.</p>
<p>The function implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in CITE: Meyer92 .</p>
<p>Before passing the image to the function, you have to roughly outline the desired regions in the image markers with positive (&gt;0) indices. So, every region is represented as one or more connected components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary mask using <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0a3fe471f679fa851ffce18e751d8625">findContours</a> and <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a598a742bf4f67b16ea1094a000a0646a">drawContours</a> (see the watershed.cpp demo). The markers are "seeds" of the future image regions. All the other pixels in markers , whose relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. In the function output, each pixel in markers is set to a value of the "seed" components or to -1 at boundaries between the regions.</p>
<p><b>Note:</b> Any two neighbor connected components are not necessarily separated by a watershed boundary (-1's pixels); for example, they can touch each other in the initial marker image passed to the function.</p>
<p>param image Input 8-bit 3-channel image. param markers Input/output 32-bit single-channel image (map) of markers. It should have the same size as image .</p>
<p>SEE: findContours</p>
<p>imgproc_misc </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a25098a4ff90d87dd757b7e1f43476b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25098a4ff90d87dd757b7e1f43476b07">&#9670;&nbsp;</a></span>ADAPTIVE_THRESH_GAUSSIAN_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ae3fc73657dbbaa86c8f5f36d54de57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae3fc73657dbbaa86c8f5f36d54de57">&#9670;&nbsp;</a></span>ADAPTIVE_THRESH_MEAN_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.ADAPTIVE_THRESH_MEAN_C = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa52fe93e89b2982913c60253561c9ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52fe93e89b2982913c60253561c9ab8">&#9670;&nbsp;</a></span>CC_STAT_AREA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CC_STAT_AREA = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9242dfdbaf6bcb7a0f7221286e82e7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9242dfdbaf6bcb7a0f7221286e82e7f9">&#9670;&nbsp;</a></span>CC_STAT_HEIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CC_STAT_HEIGHT = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8823eecb80f36056f442650de4a54ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8823eecb80f36056f442650de4a54ae">&#9670;&nbsp;</a></span>CC_STAT_LEFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CC_STAT_LEFT = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3192d8c1c863fe9c5b651e3ab0b7d4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3192d8c1c863fe9c5b651e3ab0b7d4a7">&#9670;&nbsp;</a></span>CC_STAT_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CC_STAT_MAX = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa74ad192f15cdd0bff0baa13711bd11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74ad192f15cdd0bff0baa13711bd11f">&#9670;&nbsp;</a></span>CC_STAT_TOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CC_STAT_TOP = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80de013264e5228023c0d60171405ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80de013264e5228023c0d60171405ae9">&#9670;&nbsp;</a></span>CC_STAT_WIDTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CC_STAT_WIDTH = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dbdb5c12a328965de5cd8f4b7d8a262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbdb5c12a328965de5cd8f4b7d8a262">&#9670;&nbsp;</a></span>CCL_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CCL_DEFAULT = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13c2d43d3dd377c99f18f27ab6331486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c2d43d3dd377c99f18f27ab6331486">&#9670;&nbsp;</a></span>CCL_GRANA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CCL_GRANA = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab12285527b5cd3888ab35f854e1fb9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12285527b5cd3888ab35f854e1fb9ce">&#9670;&nbsp;</a></span>CCL_WU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CCL_WU = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf2ac590850cc0a6d9e18dd2d663108f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2ac590850cc0a6d9e18dd2d663108f">&#9670;&nbsp;</a></span>CHAIN_APPROX_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CHAIN_APPROX_NONE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afddab97f976086adada53d09d6f4a06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddab97f976086adada53d09d6f4a06a">&#9670;&nbsp;</a></span>CHAIN_APPROX_SIMPLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CHAIN_APPROX_SIMPLE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab50baf08587b17d74ee973a52e13fe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50baf08587b17d74ee973a52e13fe8e">&#9670;&nbsp;</a></span>CHAIN_APPROX_TC89_KCOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CHAIN_APPROX_TC89_KCOS = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1a27c7cf4f49d4f6bab7402701661f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a27c7cf4f49d4f6bab7402701661f9">&#9670;&nbsp;</a></span>CHAIN_APPROX_TC89_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CHAIN_APPROX_TC89_L1 = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00455e4dd6ed254c5cd1ed192d2cb251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00455e4dd6ed254c5cd1ed192d2cb251">&#9670;&nbsp;</a></span>COLOR_BayerBG2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2BGR = 46</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a580985395bc98c8517eabaa43293584e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580985395bc98c8517eabaa43293584e">&#9670;&nbsp;</a></span>COLOR_BayerBG2BGR_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2BGR_EA = 135</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fa695747e7048fa7dbb3cff1be6cfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa695747e7048fa7dbb3cff1be6cfdc">&#9670;&nbsp;</a></span>COLOR_BayerBG2BGR_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2BGR_VNG = 62</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a621682b6f4c6bc015c1ebc059b75f432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621682b6f4c6bc015c1ebc059b75f432">&#9670;&nbsp;</a></span>COLOR_BayerBG2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2BGRA = 139</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2789575f260d7c778971e5d70b987f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2789575f260d7c778971e5d70b987f70">&#9670;&nbsp;</a></span>COLOR_BayerBG2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2GRAY = 86</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b91f2092febbb98acbb2dcd545f9c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b91f2092febbb98acbb2dcd545f9c90">&#9670;&nbsp;</a></span>COLOR_BayerBG2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aac938efbf5a272685313cfba5f36b128">COLOR_BayerRG2BGR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a149212dcd23d64b1044df92884948103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149212dcd23d64b1044df92884948103">&#9670;&nbsp;</a></span>COLOR_BayerBG2RGB_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2RGB_EA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a918cf15595fa340f586e3ad3e88f01d2">COLOR_BayerRG2BGR_EA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22f212e0107a355ca8c444424265a932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f212e0107a355ca8c444424265a932">&#9670;&nbsp;</a></span>COLOR_BayerBG2RGB_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2RGB_VNG = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a03957ef64cdc0c120c72bf1cfb4a09e8">COLOR_BayerRG2BGR_VNG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8147f4eb2fa4fca69586a7743b5050e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8147f4eb2fa4fca69586a7743b5050e8">&#9670;&nbsp;</a></span>COLOR_BayerBG2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerBG2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad28810c3f4d5f441fc2af12a8c3089b1">COLOR_BayerRG2BGRA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a640bc9c494d309897aea3313b6e30d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640bc9c494d309897aea3313b6e30d5c">&#9670;&nbsp;</a></span>COLOR_BayerGB2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2BGR = 47</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbee19d4cd4672c9b6988516e7850bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbee19d4cd4672c9b6988516e7850bb0">&#9670;&nbsp;</a></span>COLOR_BayerGB2BGR_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2BGR_EA = 136</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad56f16ded2575b412e0b8b094bb77a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56f16ded2575b412e0b8b094bb77a74">&#9670;&nbsp;</a></span>COLOR_BayerGB2BGR_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2BGR_VNG = 63</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a4c1fd33e473c0621cb3a89c27b77e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4c1fd33e473c0621cb3a89c27b77e6">&#9670;&nbsp;</a></span>COLOR_BayerGB2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2BGRA = 140</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacec19fcf81bd927b4e0d9fad73de7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacec19fcf81bd927b4e0d9fad73de7e4">&#9670;&nbsp;</a></span>COLOR_BayerGB2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2GRAY = 87</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d493ad5d017d13765364b1bd85625b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d493ad5d017d13765364b1bd85625b7">&#9670;&nbsp;</a></span>COLOR_BayerGB2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ade5cf921fe1c7c068eeb94bb338f7de5">COLOR_BayerGR2BGR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a4cc6138e73f880dcf6ad20bfc66713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4cc6138e73f880dcf6ad20bfc66713">&#9670;&nbsp;</a></span>COLOR_BayerGB2RGB_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2RGB_EA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa57ed966fae2eec59a838a370dc82c5e">COLOR_BayerGR2BGR_EA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace1d5c8aa7bdcd835f6efb7affae247a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1d5c8aa7bdcd835f6efb7affae247a">&#9670;&nbsp;</a></span>COLOR_BayerGB2RGB_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2RGB_VNG = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7afd65cf67f7c86f3b5b05c3166af40b">COLOR_BayerGR2BGR_VNG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a005c23caeba72214b0d2400eec7982d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005c23caeba72214b0d2400eec7982d7">&#9670;&nbsp;</a></span>COLOR_BayerGB2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGB2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab83d821e2e5cc6a9efd23000dba73c33">COLOR_BayerGR2BGRA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade5cf921fe1c7c068eeb94bb338f7de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5cf921fe1c7c068eeb94bb338f7de5">&#9670;&nbsp;</a></span>COLOR_BayerGR2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2BGR = 49</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa57ed966fae2eec59a838a370dc82c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57ed966fae2eec59a838a370dc82c5e">&#9670;&nbsp;</a></span>COLOR_BayerGR2BGR_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2BGR_EA = 138</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7afd65cf67f7c86f3b5b05c3166af40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afd65cf67f7c86f3b5b05c3166af40b">&#9670;&nbsp;</a></span>COLOR_BayerGR2BGR_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2BGR_VNG = 65</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab83d821e2e5cc6a9efd23000dba73c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83d821e2e5cc6a9efd23000dba73c33">&#9670;&nbsp;</a></span>COLOR_BayerGR2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2BGRA = 142</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a261eb729f702770ff1fb469df65851f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261eb729f702770ff1fb469df65851f2">&#9670;&nbsp;</a></span>COLOR_BayerGR2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2GRAY = 89</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1044e6a0769a88d66353e38885263e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1044e6a0769a88d66353e38885263e15">&#9670;&nbsp;</a></span>COLOR_BayerGR2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a640bc9c494d309897aea3313b6e30d5c">COLOR_BayerGB2BGR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44b530b32e58d7de641c1ac1e2a4971f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b530b32e58d7de641c1ac1e2a4971f">&#9670;&nbsp;</a></span>COLOR_BayerGR2RGB_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2RGB_EA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#acbee19d4cd4672c9b6988516e7850bb0">COLOR_BayerGB2BGR_EA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2ec997885f7fbba32625690fd207241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ec997885f7fbba32625690fd207241">&#9670;&nbsp;</a></span>COLOR_BayerGR2RGB_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2RGB_VNG = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad56f16ded2575b412e0b8b094bb77a74">COLOR_BayerGB2BGR_VNG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a763ece64f5a4ddc82069227f9fca621a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763ece64f5a4ddc82069227f9fca621a">&#9670;&nbsp;</a></span>COLOR_BayerGR2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerGR2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5a4c1fd33e473c0621cb3a89c27b77e6">COLOR_BayerGB2BGRA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac938efbf5a272685313cfba5f36b128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac938efbf5a272685313cfba5f36b128">&#9670;&nbsp;</a></span>COLOR_BayerRG2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2BGR = 48</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a918cf15595fa340f586e3ad3e88f01d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918cf15595fa340f586e3ad3e88f01d2">&#9670;&nbsp;</a></span>COLOR_BayerRG2BGR_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2BGR_EA = 137</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03957ef64cdc0c120c72bf1cfb4a09e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03957ef64cdc0c120c72bf1cfb4a09e8">&#9670;&nbsp;</a></span>COLOR_BayerRG2BGR_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2BGR_VNG = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad28810c3f4d5f441fc2af12a8c3089b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28810c3f4d5f441fc2af12a8c3089b1">&#9670;&nbsp;</a></span>COLOR_BayerRG2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2BGRA = 141</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20617e3ea282bc30eb43c2f1f289df45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20617e3ea282bc30eb43c2f1f289df45">&#9670;&nbsp;</a></span>COLOR_BayerRG2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2GRAY = 88</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08796489bb301a56fadf9d20c90deea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08796489bb301a56fadf9d20c90deea6">&#9670;&nbsp;</a></span>COLOR_BayerRG2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a00455e4dd6ed254c5cd1ed192d2cb251">COLOR_BayerBG2BGR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c635c4bbe115b84a6ce17e34e6cd8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c635c4bbe115b84a6ce17e34e6cd8e4">&#9670;&nbsp;</a></span>COLOR_BayerRG2RGB_EA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2RGB_EA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a580985395bc98c8517eabaa43293584e">COLOR_BayerBG2BGR_EA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56d76310ba75e85c5be7e240caf05efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d76310ba75e85c5be7e240caf05efa">&#9670;&nbsp;</a></span>COLOR_BayerRG2RGB_VNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2RGB_VNG = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7fa695747e7048fa7dbb3cff1be6cfdc">COLOR_BayerBG2BGR_VNG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d1316ea9052d9281fe79b39890da65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1316ea9052d9281fe79b39890da65c">&#9670;&nbsp;</a></span>COLOR_BayerRG2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BayerRG2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a621682b6f4c6bc015c1ebc059b75f432">COLOR_BayerBG2BGRA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c5efc705bbb0b54b83644838c4becd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5efc705bbb0b54b83644838c4becd1">&#9670;&nbsp;</a></span>COLOR_BGR2BGR555</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2BGR555 = 22</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa69281d22f6d5ed729a97fefc0f81346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69281d22f6d5ed729a97fefc0f81346">&#9670;&nbsp;</a></span>COLOR_BGR2BGR565</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2BGR565 = 12</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10e46baa414f6271ba5447cf9dab76b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e46baa414f6271ba5447cf9dab76b7">&#9670;&nbsp;</a></span>COLOR_BGR2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2BGRA = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a464aaf4c654ff382e81cca815a2719cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464aaf4c654ff382e81cca815a2719cb">&#9670;&nbsp;</a></span>COLOR_BGR2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2GRAY = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04ae14e3c04fb1b80c755ba0ee93e6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ae14e3c04fb1b80c755ba0ee93e6f2">&#9670;&nbsp;</a></span>COLOR_BGR2HLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2HLS = 52</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e7c62a6c19ffb58fb73e5fcadac6ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7c62a6c19ffb58fb73e5fcadac6ab7">&#9670;&nbsp;</a></span>COLOR_BGR2HLS_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2HLS_FULL = 68</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75a2a263703501e1b1c2c20a50c3ff0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a2a263703501e1b1c2c20a50c3ff0d">&#9670;&nbsp;</a></span>COLOR_BGR2HSV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2HSV = 40</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08dcfd1a9504ffc0c12a33f970930f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dcfd1a9504ffc0c12a33f970930f73">&#9670;&nbsp;</a></span>COLOR_BGR2HSV_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2HSV_FULL = 66</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af75906aa1bf88138d0031577ee48523d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75906aa1bf88138d0031577ee48523d">&#9670;&nbsp;</a></span>COLOR_BGR2Lab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2Lab = 44</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7addf6028350cc90df58055485e526b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7addf6028350cc90df58055485e526b">&#9670;&nbsp;</a></span>COLOR_BGR2Luv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2Luv = 50</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ac059d41f9d702ca57c7a822719760d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac059d41f9d702ca57c7a822719760d">&#9670;&nbsp;</a></span>COLOR_BGR2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2RGB = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a101295561754d1738139cf92fd47d22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101295561754d1738139cf92fd47d22f">&#9670;&nbsp;</a></span>COLOR_BGR2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2RGBA = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b7fab7aabbbaf657164fe2c10e4c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b7fab7aabbbaf657164fe2c10e4c6c">&#9670;&nbsp;</a></span>COLOR_BGR2XYZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2XYZ = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6c9dfcb6248acee5c047ee1f817eb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c9dfcb6248acee5c047ee1f817eb31">&#9670;&nbsp;</a></span>COLOR_BGR2YCrCb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2YCrCb = 36</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acca71c1a80c48be2dbac774a11a9dd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca71c1a80c48be2dbac774a11a9dd80">&#9670;&nbsp;</a></span>COLOR_BGR2YUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2YUV = 82</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43e3c90be838a4b3addcc4ea8e399deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e3c90be838a4b3addcc4ea8e399deb">&#9670;&nbsp;</a></span>COLOR_BGR2YUV_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2YUV_I420 = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef650a98f06470811e95e20b8b404f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef650a98f06470811e95e20b8b404f7c">&#9670;&nbsp;</a></span>COLOR_BGR2YUV_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2YUV_IYUV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a43e3c90be838a4b3addcc4ea8e399deb">COLOR_BGR2YUV_I420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6b6dad7e0617d7f80af3225bf8bd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6b6dad7e0617d7f80af3225bf8bd4f">&#9670;&nbsp;</a></span>COLOR_BGR2YUV_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR2YUV_YV12 = 132</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac48651e34cb670d21b6e851053729efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48651e34cb670d21b6e851053729efa">&#9670;&nbsp;</a></span>COLOR_BGR5552BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5552BGR = 24</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a847066523f4117614984b9da52e78f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847066523f4117614984b9da52e78f93">&#9670;&nbsp;</a></span>COLOR_BGR5552BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5552BGRA = 28</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c358b642f100a5e18032cd7af6ce256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c358b642f100a5e18032cd7af6ce256">&#9670;&nbsp;</a></span>COLOR_BGR5552GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5552GRAY = 31</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79c13f1f2147354ecb8a571fcd574408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c13f1f2147354ecb8a571fcd574408">&#9670;&nbsp;</a></span>COLOR_BGR5552RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5552RGB = 25</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e89f492666502c1f6e7f85f38969bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89f492666502c1f6e7f85f38969bad">&#9670;&nbsp;</a></span>COLOR_BGR5552RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5552RGBA = 29</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c79696aacda8d8f1dfed030604525eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c79696aacda8d8f1dfed030604525eb">&#9670;&nbsp;</a></span>COLOR_BGR5652BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5652BGR = 14</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbb9097eea5ee98102b6849de6b62f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb9097eea5ee98102b6849de6b62f07">&#9670;&nbsp;</a></span>COLOR_BGR5652BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5652BGRA = 18</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f1ed53133719d4d4ef979865590b144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1ed53133719d4d4ef979865590b144">&#9670;&nbsp;</a></span>COLOR_BGR5652GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5652GRAY = 21</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4f1d487969e7c1e5274e4908ef5d80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f1d487969e7c1e5274e4908ef5d80b">&#9670;&nbsp;</a></span>COLOR_BGR5652RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5652RGB = 15</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c14fa4665f6cbf773eebce019d7de0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c14fa4665f6cbf773eebce019d7de0d">&#9670;&nbsp;</a></span>COLOR_BGR5652RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGR5652RGBA = 19</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a4271616879e7356fe83218b8a3c3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4271616879e7356fe83218b8a3c3a3">&#9670;&nbsp;</a></span>COLOR_BGRA2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2BGR = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaff16693f5a52f869978a9a10d97e281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff16693f5a52f869978a9a10d97e281">&#9670;&nbsp;</a></span>COLOR_BGRA2BGR555</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2BGR555 = 26</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afde417d40aced9503df9929d856f7013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde417d40aced9503df9929d856f7013">&#9670;&nbsp;</a></span>COLOR_BGRA2BGR565</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2BGR565 = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a925a20e45f0320e80034100ab7a53f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925a20e45f0320e80034100ab7a53f8b">&#9670;&nbsp;</a></span>COLOR_BGRA2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2GRAY = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdda38f32ceafa96d9f2537eb5334834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdda38f32ceafa96d9f2537eb5334834">&#9670;&nbsp;</a></span>COLOR_BGRA2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#add37f6071b490c68c7ba8f689a80ddaa">COLOR_RGBA2BGR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4d8591b56f56758cc107c162fd21e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d8591b56f56758cc107c162fd21e30">&#9670;&nbsp;</a></span>COLOR_BGRA2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2RGBA = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0dab20dbb4e9f09df3dee314a8235a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dab20dbb4e9f09df3dee314a8235a2">&#9670;&nbsp;</a></span>COLOR_BGRA2YUV_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2YUV_I420 = 130</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2caea108c87f17cdfef51e932c912e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caea108c87f17cdfef51e932c912e33">&#9670;&nbsp;</a></span>COLOR_BGRA2YUV_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2YUV_IYUV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae0dab20dbb4e9f09df3dee314a8235a2">COLOR_BGRA2YUV_I420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad31e0e905ca8852151881576f5f69401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31e0e905ca8852151881576f5f69401">&#9670;&nbsp;</a></span>COLOR_BGRA2YUV_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_BGRA2YUV_YV12 = 134</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e210deafcd9cfe7acbe0df85ad2124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e210deafcd9cfe7acbe0df85ad2124b">&#9670;&nbsp;</a></span>COLOR_COLORCVT_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_COLORCVT_MAX = 143</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88af4af59300538f6a290ca3ee66e5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88af4af59300538f6a290ca3ee66e5f2">&#9670;&nbsp;</a></span>COLOR_GRAY2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_GRAY2BGR = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a698bc51610d1c86504bfad4c7ad5464a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698bc51610d1c86504bfad4c7ad5464a">&#9670;&nbsp;</a></span>COLOR_GRAY2BGR555</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_GRAY2BGR555 = 30</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86f0acaf0a09d742bd2bbaf10f3da9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f0acaf0a09d742bd2bbaf10f3da9fa">&#9670;&nbsp;</a></span>COLOR_GRAY2BGR565</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_GRAY2BGR565 = 20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a659f7cf920be585a68fd39b194263fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659f7cf920be585a68fd39b194263fcc">&#9670;&nbsp;</a></span>COLOR_GRAY2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_GRAY2BGRA = 9</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a12de578efca2714c878a6e768f2d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a12de578efca2714c878a6e768f2d8d">&#9670;&nbsp;</a></span>COLOR_GRAY2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_GRAY2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a88af4af59300538f6a290ca3ee66e5f2">COLOR_GRAY2BGR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa9fd09f8067264ad76f57a14033135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa9fd09f8067264ad76f57a14033135">&#9670;&nbsp;</a></span>COLOR_GRAY2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_GRAY2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a659f7cf920be585a68fd39b194263fcc">COLOR_GRAY2BGRA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6639937f498bf2dd083772623b8f908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6639937f498bf2dd083772623b8f908">&#9670;&nbsp;</a></span>COLOR_HLS2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HLS2BGR = 60</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a3b67c3562b0bf10fd7513e12ec91ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3b67c3562b0bf10fd7513e12ec91ed">&#9670;&nbsp;</a></span>COLOR_HLS2BGR_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HLS2BGR_FULL = 72</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a629b69a4f3c3d9e571236d6f02839f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629b69a4f3c3d9e571236d6f02839f40">&#9670;&nbsp;</a></span>COLOR_HLS2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HLS2RGB = 61</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab88eef1c8ac525082e7a0e7dd636e562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88eef1c8ac525082e7a0e7dd636e562">&#9670;&nbsp;</a></span>COLOR_HLS2RGB_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HLS2RGB_FULL = 73</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab3765f3b94790e1e9238c6f91c475b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3765f3b94790e1e9238c6f91c475b6">&#9670;&nbsp;</a></span>COLOR_HSV2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HSV2BGR = 54</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a074ec49b2bf764531ed8b28721bdac4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074ec49b2bf764531ed8b28721bdac4c">&#9670;&nbsp;</a></span>COLOR_HSV2BGR_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HSV2BGR_FULL = 70</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55e355ca24bdcbf1e02314b717be5a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e355ca24bdcbf1e02314b717be5a34">&#9670;&nbsp;</a></span>COLOR_HSV2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HSV2RGB = 55</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e25e45b888044ee8fefd99875725833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e25e45b888044ee8fefd99875725833">&#9670;&nbsp;</a></span>COLOR_HSV2RGB_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_HSV2RGB_FULL = 71</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b58c9a46645bce79aabf635c2fdbfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b58c9a46645bce79aabf635c2fdbfeb">&#9670;&nbsp;</a></span>COLOR_Lab2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Lab2BGR = 56</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a175bfc7d56cf7e2651049e348f8885d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175bfc7d56cf7e2651049e348f8885d3">&#9670;&nbsp;</a></span>COLOR_Lab2LBGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Lab2LBGR = 78</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ad4d58d8e0d3e61b50b4519ac8f8d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad4d58d8e0d3e61b50b4519ac8f8d3a">&#9670;&nbsp;</a></span>COLOR_Lab2LRGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Lab2LRGB = 79</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae88682acb75083d8c95ec198ce040251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88682acb75083d8c95ec198ce040251">&#9670;&nbsp;</a></span>COLOR_Lab2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Lab2RGB = 57</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad52fcb138109b02513f39928b133201c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52fcb138109b02513f39928b133201c">&#9670;&nbsp;</a></span>COLOR_LBGR2Lab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_LBGR2Lab = 74</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f4da92563208c9e856d927baefe9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f4da92563208c9e856d927baefe9e8">&#9670;&nbsp;</a></span>COLOR_LBGR2Luv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_LBGR2Luv = 76</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59324f32f4c7bdb89ff65463b2b565a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59324f32f4c7bdb89ff65463b2b565a2">&#9670;&nbsp;</a></span>COLOR_LRGB2Lab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_LRGB2Lab = 75</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7052252d1a08703d5ed2a552a96d869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7052252d1a08703d5ed2a552a96d869">&#9670;&nbsp;</a></span>COLOR_LRGB2Luv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_LRGB2Luv = 77</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bcec239143bcd04afb097ce2cdc449d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcec239143bcd04afb097ce2cdc449d">&#9670;&nbsp;</a></span>COLOR_Luv2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Luv2BGR = 58</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcc519862f77c949c4283b42524bdbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc519862f77c949c4283b42524bdbf0">&#9670;&nbsp;</a></span>COLOR_Luv2LBGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Luv2LBGR = 80</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee823353a0af0845d24bd0b27f0c37ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee823353a0af0845d24bd0b27f0c37ae">&#9670;&nbsp;</a></span>COLOR_Luv2LRGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Luv2LRGB = 81</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5791ec36b656d188a822fac67aaf55fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5791ec36b656d188a822fac67aaf55fe">&#9670;&nbsp;</a></span>COLOR_Luv2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_Luv2RGB = 59</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a278d827701793a2ef5ed773f9cbbe13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278d827701793a2ef5ed773f9cbbe13a">&#9670;&nbsp;</a></span>COLOR_mRGBA2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_mRGBA2RGBA = 126</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a427cf050f387171eae656fab7cb133ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427cf050f387171eae656fab7cb133ed">&#9670;&nbsp;</a></span>COLOR_RGB2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2BGR = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a3ac059d41f9d702ca57c7a822719760d">COLOR_BGR2RGB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6bd0e9f769f22e5a877c10be6eee5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bd0e9f769f22e5a877c10be6eee5d1">&#9670;&nbsp;</a></span>COLOR_RGB2BGR555</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2BGR555 = 23</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f3b94eb3f9c5df394581515cb562607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3b94eb3f9c5df394581515cb562607">&#9670;&nbsp;</a></span>COLOR_RGB2BGR565</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2BGR565 = 13</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50ca3ac02f237c63a54ef205ce2525a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ca3ac02f237c63a54ef205ce2525a9">&#9670;&nbsp;</a></span>COLOR_RGB2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2BGRA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a101295561754d1738139cf92fd47d22f">COLOR_BGR2RGBA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d309f61d312fad87e098a49cf6c0778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d309f61d312fad87e098a49cf6c0778">&#9670;&nbsp;</a></span>COLOR_RGB2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2GRAY = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa5c04c062e79742ad112a1d78d3e0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5c04c062e79742ad112a1d78d3e0ec">&#9670;&nbsp;</a></span>COLOR_RGB2HLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2HLS = 53</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a498aabaf86914ee51b7f8060f1f6920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498aabaf86914ee51b7f8060f1f6920e">&#9670;&nbsp;</a></span>COLOR_RGB2HLS_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2HLS_FULL = 69</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a51f721dfc036e6ba3e66320c0ab9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a51f721dfc036e6ba3e66320c0ab9e3">&#9670;&nbsp;</a></span>COLOR_RGB2HSV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2HSV = 41</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a761584602d331fb8fe4cea1baeb655bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761584602d331fb8fe4cea1baeb655bd">&#9670;&nbsp;</a></span>COLOR_RGB2HSV_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2HSV_FULL = 67</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a0639f2731bdb70cd1286be1e499e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0639f2731bdb70cd1286be1e499e70">&#9670;&nbsp;</a></span>COLOR_RGB2Lab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2Lab = 45</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa36bd22ac2ce91d0a94dfffb7a2b5576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36bd22ac2ce91d0a94dfffb7a2b5576">&#9670;&nbsp;</a></span>COLOR_RGB2Luv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2Luv = 51</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a674e8a98bbe4b9010124caf11da0fa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674e8a98bbe4b9010124caf11da0fa2a">&#9670;&nbsp;</a></span>COLOR_RGB2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a10e46baa414f6271ba5447cf9dab76b7">COLOR_BGR2BGRA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d392f7656317e139bc129ed8ec0c34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d392f7656317e139bc129ed8ec0c34f">&#9670;&nbsp;</a></span>COLOR_RGB2XYZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2XYZ = 33</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa24e846619552902e77f5748da7482d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa24e846619552902e77f5748da7482d">&#9670;&nbsp;</a></span>COLOR_RGB2YCrCb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2YCrCb = 37</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac57f5b69b83a58e7bcfe56717a986541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57f5b69b83a58e7bcfe56717a986541">&#9670;&nbsp;</a></span>COLOR_RGB2YUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2YUV = 83</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9af89531576863f7ea636f06ccd8d873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af89531576863f7ea636f06ccd8d873">&#9670;&nbsp;</a></span>COLOR_RGB2YUV_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2YUV_I420 = 127</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a415315859cc86e6f1d9f682ac3010dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415315859cc86e6f1d9f682ac3010dd3">&#9670;&nbsp;</a></span>COLOR_RGB2YUV_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2YUV_IYUV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9af89531576863f7ea636f06ccd8d873">COLOR_RGB2YUV_I420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7a558c99e1660a5253b2539c55356aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a558c99e1660a5253b2539c55356aa">&#9670;&nbsp;</a></span>COLOR_RGB2YUV_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGB2YUV_YV12 = 131</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add37f6071b490c68c7ba8f689a80ddaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add37f6071b490c68c7ba8f689a80ddaa">&#9670;&nbsp;</a></span>COLOR_RGBA2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2BGR = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e03b0ddddc692dff748836948cade7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e03b0ddddc692dff748836948cade7d">&#9670;&nbsp;</a></span>COLOR_RGBA2BGR555</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2BGR555 = 27</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a559f100f933e0524e38a1854ab93ed0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559f100f933e0524e38a1854ab93ed0b">&#9670;&nbsp;</a></span>COLOR_RGBA2BGR565</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2BGR565 = 17</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a085a4bb6a4cccf5bb2a9eec25da4396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085a4bb6a4cccf5bb2a9eec25da4396d">&#9670;&nbsp;</a></span>COLOR_RGBA2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2BGRA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae4d8591b56f56758cc107c162fd21e30">COLOR_BGRA2RGBA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad505ff97dd7536d73e1aae3cee2cbf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad505ff97dd7536d73e1aae3cee2cbf4d">&#9670;&nbsp;</a></span>COLOR_RGBA2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2GRAY = 11</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab43ec0a553cd2fdec1aa26eac5ce31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab43ec0a553cd2fdec1aa26eac5ce31c">&#9670;&nbsp;</a></span>COLOR_RGBA2mRGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2mRGBA = 125</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a746332b2bef835082d566ceeac3b46af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746332b2bef835082d566ceeac3b46af">&#9670;&nbsp;</a></span>COLOR_RGBA2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a0a4271616879e7356fe83218b8a3c3a3">COLOR_BGRA2BGR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f467b97ad4eb1e2401c027e6a85563c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f467b97ad4eb1e2401c027e6a85563c">&#9670;&nbsp;</a></span>COLOR_RGBA2YUV_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2YUV_I420 = 129</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02394858448d272eab8a9ab199224742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02394858448d272eab8a9ab199224742">&#9670;&nbsp;</a></span>COLOR_RGBA2YUV_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2YUV_IYUV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a5f467b97ad4eb1e2401c027e6a85563c">COLOR_RGBA2YUV_I420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94a2f4f768b11831bf2e87ea73b55a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a2f4f768b11831bf2e87ea73b55a92">&#9670;&nbsp;</a></span>COLOR_RGBA2YUV_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_RGBA2YUV_YV12 = 133</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa324633335c87a3faaa1828315a30cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa324633335c87a3faaa1828315a30cc">&#9670;&nbsp;</a></span>COLOR_XYZ2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_XYZ2BGR = 34</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17928689f567520c4b0c47879feeb843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17928689f567520c4b0c47879feeb843">&#9670;&nbsp;</a></span>COLOR_XYZ2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_XYZ2RGB = 35</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c03b294f7560f06b0616ba35a900bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c03b294f7560f06b0616ba35a900bc6">&#9670;&nbsp;</a></span>COLOR_YCrCb2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YCrCb2BGR = 38</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4c5076d19572cc983f4f2021fa809e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c5076d19572cc983f4f2021fa809e3">&#9670;&nbsp;</a></span>COLOR_YCrCb2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YCrCb2RGB = 39</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab628e9f1d2a6d699380c06baebb0c19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab628e9f1d2a6d699380c06baebb0c19d">&#9670;&nbsp;</a></span>COLOR_YUV2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR = 84</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a214ace3bcaaaa3b32e63a2dcc634ddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214ace3bcaaaa3b32e63a2dcc634ddfa">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_I420 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a1eaa77c08db40d971caac3256fc1687a">COLOR_YUV2BGR_IYUV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eaa77c08db40d971caac3256fc1687a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaa77c08db40d971caac3256fc1687a">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_IYUV = 101</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6052068d3a23fe539b125c621625dc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6052068d3a23fe539b125c621625dc3b">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_NV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_NV12 = 91</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad006f0f6c1c38ad4bbb0d13979aaddcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad006f0f6c1c38ad4bbb0d13979aaddcc">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_NV21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_NV21 = 93</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94b5b9d46619cc68f6097b9b06cc6b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b5b9d46619cc68f6097b9b06cc6b9b">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_UYNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_UYNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adcf84938e0e64e9e7757be31053fefdb">COLOR_YUV2BGR_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcf84938e0e64e9e7757be31053fefdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf84938e0e64e9e7757be31053fefdb">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_UYVY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_UYVY = 108</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf1a98aa93bf3bb6b5420d03be2d92ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1a98aa93bf3bb6b5420d03be2d92ce">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_Y422</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_Y422 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adcf84938e0e64e9e7757be31053fefdb">COLOR_YUV2BGR_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7c6afd48e0df3d8cdd6a9ebd6e0da90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c6afd48e0df3d8cdd6a9ebd6e0da90">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_YUNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_YUNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4ec8dc18504a7f178e4e024e97a9a8ee">COLOR_YUV2BGR_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec8dc18504a7f178e4e024e97a9a8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec8dc18504a7f178e4e024e97a9a8ee">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_YUY2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_YUY2 = 116</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a545bed04b92cf21b36dffe5a77445e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545bed04b92cf21b36dffe5a77445e89">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_YUYV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_YUYV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a4ec8dc18504a7f178e4e024e97a9a8ee">COLOR_YUV2BGR_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9db259000fefcc999a11c18ec77d0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9db259000fefcc999a11c18ec77d0fe">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_YV12 = 99</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b97a7d0d69f73115a709076f60bc5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b97a7d0d69f73115a709076f60bc5c2">&#9670;&nbsp;</a></span>COLOR_YUV2BGR_YVYU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGR_YVYU = 118</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9131ad647a8482ec49c5018602a0098d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9131ad647a8482ec49c5018602a0098d">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_I420 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af13bde4178ba33ad07277d6307d139ab">COLOR_YUV2BGRA_IYUV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af13bde4178ba33ad07277d6307d139ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13bde4178ba33ad07277d6307d139ab">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_IYUV = 105</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a714d5a4820517a9e0a55d6eb9c5bef82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714d5a4820517a9e0a55d6eb9c5bef82">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_NV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_NV12 = 95</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c6d9728436a595824c4fc203bab2bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6d9728436a595824c4fc203bab2bdb">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_NV21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_NV21 = 97</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acae3aee438c939255b2870642b98d90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae3aee438c939255b2870642b98d90d">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_UYNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_UYNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9fc7fc56671a5133beda501ec64c5e9d">COLOR_YUV2BGRA_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fc7fc56671a5133beda501ec64c5e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc7fc56671a5133beda501ec64c5e9d">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_UYVY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_UYVY = 112</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34252246bf4469043581b3e32526ac2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34252246bf4469043581b3e32526ac2f">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_Y422</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_Y422 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9fc7fc56671a5133beda501ec64c5e9d">COLOR_YUV2BGRA_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ae6ffa435eff0189a21df9a87b10de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae6ffa435eff0189a21df9a87b10de1">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_YUNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_YUNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae25c23cda2f9a71c1e55f171c2d762f5">COLOR_YUV2BGRA_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae25c23cda2f9a71c1e55f171c2d762f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25c23cda2f9a71c1e55f171c2d762f5">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_YUY2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_YUY2 = 120</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ab1afc43f94dbf48c3b808afee833da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab1afc43f94dbf48c3b808afee833da">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_YUYV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_YUYV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ae25c23cda2f9a71c1e55f171c2d762f5">COLOR_YUV2BGRA_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a280e49359bbdc3425a0b978a26645856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280e49359bbdc3425a0b978a26645856">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_YV12 = 103</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1127d9e657eebc2880cee15649abf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1127d9e657eebc2880cee15649abf2">&#9670;&nbsp;</a></span>COLOR_YUV2BGRA_YVYU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2BGRA_YVYU = 122</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34530c983fa371e744a08ba8a3a607f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34530c983fa371e744a08ba8a3a607f1">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_420 = 106</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33bc50ef0e5cace2eea7e6c9de56b1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33bc50ef0e5cace2eea7e6c9de56b1ae">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_I420 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bae06d7bc5f71893c80783acf91f6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bae06d7bc5f71893c80783acf91f6d9">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_IYUV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5fcc2a92fb0db759f88859ce6c6050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fcc2a92fb0db759f88859ce6c6050f">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_NV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_NV12 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7527676cc1740235cdbb120e763b4011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7527676cc1740235cdbb120e763b4011">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_NV21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_NV21 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a632b2ccfeddc2e6f4565d2ff52fd3463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632b2ccfeddc2e6f4565d2ff52fd3463">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_UYNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_UYNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adc58d75620925938003c78a0b846c628">COLOR_YUV2GRAY_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc58d75620925938003c78a0b846c628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc58d75620925938003c78a0b846c628">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_UYVY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_UYVY = 123</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5be6700ef5b4969803a910dfa96b083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5be6700ef5b4969803a910dfa96b083">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_Y422</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_Y422 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#adc58d75620925938003c78a0b846c628">COLOR_YUV2GRAY_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b37db5c1d3935cb8adfefff5d4d163e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b37db5c1d3935cb8adfefff5d4d163e">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_YUNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_YUNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa66082846d7c9a9326e20e6cbf7f8d92">COLOR_YUV2GRAY_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa66082846d7c9a9326e20e6cbf7f8d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66082846d7c9a9326e20e6cbf7f8d92">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_YUY2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_YUY2 = 124</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a587681a1ff2c842fb6958fa91da1b61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587681a1ff2c842fb6958fa91da1b61c">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_YUYV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_YUYV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa66082846d7c9a9326e20e6cbf7f8d92">COLOR_YUV2GRAY_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe21052765136d9722d43793b54d3fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe21052765136d9722d43793b54d3fd7">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_YV12 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77aeca649e7f7f2c53b468d08e246838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aeca649e7f7f2c53b468d08e246838">&#9670;&nbsp;</a></span>COLOR_YUV2GRAY_YVYU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2GRAY_YVYU = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa66082846d7c9a9326e20e6cbf7f8d92">COLOR_YUV2GRAY_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a509378fbaede245f0543760cd03e10b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509378fbaede245f0543760cd03e10b9">&#9670;&nbsp;</a></span>COLOR_YUV2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB = 85</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abff1d690cf571ecafd8c13cf2eb2adbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff1d690cf571ecafd8c13cf2eb2adbe">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_I420 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a8484b36f2e203a57bf948fe8645443e6">COLOR_YUV2RGB_IYUV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8484b36f2e203a57bf948fe8645443e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8484b36f2e203a57bf948fe8645443e6">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_IYUV = 100</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fe1e59f1952e60d8318013b75ddd70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe1e59f1952e60d8318013b75ddd70a">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_NV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_NV12 = 90</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af931b245acb983ace37bdecd6b9d036a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af931b245acb983ace37bdecd6b9d036a">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_NV21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_NV21 = 92</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62f64ae4fd0d81cae6d9f2f68071e7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f64ae4fd0d81cae6d9f2f68071e7f6">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_UYNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_UYNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a31499d871eb3ca2a8d2aed08844ef38d">COLOR_YUV2RGB_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31499d871eb3ca2a8d2aed08844ef38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31499d871eb3ca2a8d2aed08844ef38d">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_UYVY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_UYVY = 107</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16d798c93ed0646db37d2f8dc4ae7ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d798c93ed0646db37d2f8dc4ae7ef8">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_Y422</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_Y422 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a31499d871eb3ca2a8d2aed08844ef38d">COLOR_YUV2RGB_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c2468fb714b789568006d44eb2e570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c2468fb714b789568006d44eb2e570">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_YUNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_YUNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5fb2dfead28661e783340053a005dfa">COLOR_YUV2RGB_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5fb2dfead28661e783340053a005dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fb2dfead28661e783340053a005dfa">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_YUY2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_YUY2 = 115</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fabcc33793182d7c8717618b445ef31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fabcc33793182d7c8717618b445ef31">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_YUYV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_YUYV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab5fb2dfead28661e783340053a005dfa">COLOR_YUV2RGB_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad514386c338632f41e71de13beec3eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad514386c338632f41e71de13beec3eb2">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_YV12 = 98</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ac08d92249e566924b86cda8fbfbb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac08d92249e566924b86cda8fbfbb51">&#9670;&nbsp;</a></span>COLOR_YUV2RGB_YVYU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGB_YVYU = 117</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac36fe284acda8dd90a97d993b5dab23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36fe284acda8dd90a97d993b5dab23a">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_I420</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_I420 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aa6bb2146fa1f128e5f6dcd729bb25d27">COLOR_YUV2RGBA_IYUV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6bb2146fa1f128e5f6dcd729bb25d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bb2146fa1f128e5f6dcd729bb25d27">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_IYUV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_IYUV = 104</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8da07108887c111ebdab4f2a643e874b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da07108887c111ebdab4f2a643e874b">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_NV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_NV12 = 94</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6ee5d8a713ea844b27f4e6d924830e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ee5d8a713ea844b27f4e6d924830e2">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_NV21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_NV21 = 96</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab61fd136a2f3d718e33b976c4f4f9082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61fd136a2f3d718e33b976c4f4f9082">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_UYNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_UYNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aebd7db73e8112a99da14de20ae9efed9">COLOR_YUV2RGBA_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebd7db73e8112a99da14de20ae9efed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd7db73e8112a99da14de20ae9efed9">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_UYVY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_UYVY = 111</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6481c39de8de018aef034f91d021775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6481c39de8de018aef034f91d021775">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_Y422</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_Y422 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#aebd7db73e8112a99da14de20ae9efed9">COLOR_YUV2RGBA_UYVY</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b5667827f6f329befabdfaafcb7e1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5667827f6f329befabdfaafcb7e1fa">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_YUNV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_YUNV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2e915755240549a4f5c5b0e557fe342f">COLOR_YUV2RGBA_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e915755240549a4f5c5b0e557fe342f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e915755240549a4f5c5b0e557fe342f">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_YUY2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_YUY2 = 119</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5884e72a1b97d2b28bd611aae090a128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5884e72a1b97d2b28bd611aae090a128">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_YUYV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_YUYV = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a2e915755240549a4f5c5b0e557fe342f">COLOR_YUV2RGBA_YUY2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f6d947b1a255ce0bca9e395016a4c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6d947b1a255ce0bca9e395016a4c5a">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_YV12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_YV12 = 102</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab32b87c9acd17de56d25f6fffce760ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32b87c9acd17de56d25f6fffce760ad">&#9670;&nbsp;</a></span>COLOR_YUV2RGBA_YVYU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV2RGBA_YVYU = 121</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f7a7fa1f2f3e6467a85a59001a3b7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7a7fa1f2f3e6467a85a59001a3b7a2">&#9670;&nbsp;</a></span>COLOR_YUV420p2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420p2BGR = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af9db259000fefcc999a11c18ec77d0fe">COLOR_YUV2BGR_YV12</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad28b1a6bad97999b9d48c1104352b1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28b1a6bad97999b9d48c1104352b1a0">&#9670;&nbsp;</a></span>COLOR_YUV420p2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420p2BGRA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a280e49359bbdc3425a0b978a26645856">COLOR_YUV2BGRA_YV12</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acde254de83d738d672736f9fb11a1782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde254de83d738d672736f9fb11a1782">&#9670;&nbsp;</a></span>COLOR_YUV420p2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420p2GRAY = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae172c922f993652cb9bc72d8af32300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae172c922f993652cb9bc72d8af32300f">&#9670;&nbsp;</a></span>COLOR_YUV420p2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420p2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad514386c338632f41e71de13beec3eb2">COLOR_YUV2RGB_YV12</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a438647d0ac55fe2fe85b0fb9c93299a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438647d0ac55fe2fe85b0fb9c93299a8">&#9670;&nbsp;</a></span>COLOR_YUV420p2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420p2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a7f6d947b1a255ce0bca9e395016a4c5a">COLOR_YUV2RGBA_YV12</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed9dfd8ec85dd3264e0c85c12243c7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9dfd8ec85dd3264e0c85c12243c7a8">&#9670;&nbsp;</a></span>COLOR_YUV420sp2BGR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420sp2BGR = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ad006f0f6c1c38ad4bbb0d13979aaddcc">COLOR_YUV2BGR_NV21</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa497937f98d289dbff48ea4c93a2da95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa497937f98d289dbff48ea4c93a2da95">&#9670;&nbsp;</a></span>COLOR_YUV420sp2BGRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420sp2BGRA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9c6d9728436a595824c4fc203bab2bdb">COLOR_YUV2BGRA_NV21</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb103452e718ef621397b6fd06e35607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb103452e718ef621397b6fd06e35607">&#9670;&nbsp;</a></span>COLOR_YUV420sp2GRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420sp2GRAY = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a34530c983fa371e744a08ba8a3a607f1">COLOR_YUV2GRAY_420</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa253114d84795fbcf194141f24ce37e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa253114d84795fbcf194141f24ce37e7">&#9670;&nbsp;</a></span>COLOR_YUV420sp2RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420sp2RGB = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#af931b245acb983ace37bdecd6b9d036a">COLOR_YUV2RGB_NV21</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb935b042a19ee10b0bc1cd47fc696f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb935b042a19ee10b0bc1cd47fc696f8">&#9670;&nbsp;</a></span>COLOR_YUV420sp2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLOR_YUV420sp2RGBA = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#ab6ee5d8a713ea844b27f4e6d924830e2">COLOR_YUV2RGBA_NV21</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa30b6f164c223eadacf25a34aa843180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30b6f164c223eadacf25a34aa843180">&#9670;&nbsp;</a></span>COLORMAP_AUTUMN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_AUTUMN = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b0e3340bdf7d7d547566558117bee85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0e3340bdf7d7d547566558117bee85">&#9670;&nbsp;</a></span>COLORMAP_BONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_BONE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a676f001ad2feb6a1ce1bc87d1e48e310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676f001ad2feb6a1ce1bc87d1e48e310">&#9670;&nbsp;</a></span>COLORMAP_CIVIDIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_CIVIDIS = 17</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4e5b541d5e46f51549354d6ad94fb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e5b541d5e46f51549354d6ad94fb8b">&#9670;&nbsp;</a></span>COLORMAP_COOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_COOL = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0c81c7e52c3b7f873719f8e0770de87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c81c7e52c3b7f873719f8e0770de87">&#9670;&nbsp;</a></span>COLORMAP_DEEPGREEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_DEEPGREEN = 21</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8edbc756cd6b0e441cbb539ae3c76ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edbc756cd6b0e441cbb539ae3c76ad3">&#9670;&nbsp;</a></span>COLORMAP_HOT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_HOT = 11</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85c2cace608f758f685d17e9200ef7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c2cace608f758f685d17e9200ef7d8">&#9670;&nbsp;</a></span>COLORMAP_HSV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_HSV = 9</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f59c6c81544d975d40d70ec07aaa500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f59c6c81544d975d40d70ec07aaa500">&#9670;&nbsp;</a></span>COLORMAP_INFERNO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_INFERNO = 14</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73aa8eedcaa8d495928fe5b54107f558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aa8eedcaa8d495928fe5b54107f558">&#9670;&nbsp;</a></span>COLORMAP_JET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_JET = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3752f38c2888c1b799d967bcf9c567c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3752f38c2888c1b799d967bcf9c567c2">&#9670;&nbsp;</a></span>COLORMAP_MAGMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_MAGMA = 13</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad772eaded7bd1f67b8007cebde1b3b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad772eaded7bd1f67b8007cebde1b3b17">&#9670;&nbsp;</a></span>COLORMAP_OCEAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_OCEAN = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acce1a843bbb84b9f182fe2fb7b5ccf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce1a843bbb84b9f182fe2fb7b5ccf42">&#9670;&nbsp;</a></span>COLORMAP_PARULA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_PARULA = 12</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a2e9a80893e64b9a1f3b7005c82aca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2e9a80893e64b9a1f3b7005c82aca0">&#9670;&nbsp;</a></span>COLORMAP_PINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_PINK = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97603a61d63a2ab6ef82092fc242bf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97603a61d63a2ab6ef82092fc242bf41">&#9670;&nbsp;</a></span>COLORMAP_PLASMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_PLASMA = 15</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35e081c577376a2d7f0ac7e11e3bbfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e081c577376a2d7f0ac7e11e3bbfb6">&#9670;&nbsp;</a></span>COLORMAP_RAINBOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_RAINBOW = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbc5ca5979c351c5f452a37efbc89922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc5ca5979c351c5f452a37efbc89922">&#9670;&nbsp;</a></span>COLORMAP_SPRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_SPRING = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03e0be0e55576b31602b867c0bed3e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e0be0e55576b31602b867c0bed3e53">&#9670;&nbsp;</a></span>COLORMAP_SUMMER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_SUMMER = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33f8e45836c18101e89100c4bff126b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f8e45836c18101e89100c4bff126b1">&#9670;&nbsp;</a></span>COLORMAP_TURBO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_TURBO = 20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed5c4f00055d5145c4aeec4f4ac77d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5c4f00055d5145c4aeec4f4ac77d7b">&#9670;&nbsp;</a></span>COLORMAP_TWILIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_TWILIGHT = 18</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27e32c4f45de8d73cc3089110fa2ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27e32c4f45de8d73cc3089110fa2ff1">&#9670;&nbsp;</a></span>COLORMAP_TWILIGHT_SHIFTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_TWILIGHT_SHIFTED = 19</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acfb4a58364e60d9eaeee5208036cb1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb4a58364e60d9eaeee5208036cb1f2">&#9670;&nbsp;</a></span>COLORMAP_VIRIDIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_VIRIDIS = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a224e8c13c60eba35535dd860869d1864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224e8c13c60eba35535dd860869d1864">&#9670;&nbsp;</a></span>COLORMAP_WINTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.COLORMAP_WINTER = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1afc05a9a7316bcb03babab27fadb2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afc05a9a7316bcb03babab27fadb2ef">&#9670;&nbsp;</a></span>CONTOURS_MATCH_I1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CONTOURS_MATCH_I1 = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1414fe7d7173f75b67d109ece750fad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1414fe7d7173f75b67d109ece750fad6">&#9670;&nbsp;</a></span>CONTOURS_MATCH_I2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CONTOURS_MATCH_I2 = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace2a645a338ce9c6f700a217d451119e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2a645a338ce9c6f700a217d451119e">&#9670;&nbsp;</a></span>CONTOURS_MATCH_I3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CONTOURS_MATCH_I3 = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86502487ec226f58921fb82d8f1ff9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86502487ec226f58921fb82d8f1ff9fa">&#9670;&nbsp;</a></span>CV_BILATERAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_BILATERAL = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c3b0acb224b685dd81cbd0dcadd30e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3b0acb224b685dd81cbd0dcadd30e6">&#9670;&nbsp;</a></span>CV_BLUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_BLUR = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25e72839651cb58242a8ceaf1c338f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e72839651cb58242a8ceaf1c338f64">&#9670;&nbsp;</a></span>CV_BLUR_NO_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_BLUR_NO_SCALE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21874a18462c20ceacec7d444bcb7cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21874a18462c20ceacec7d444bcb7cf4">&#9670;&nbsp;</a></span>CV_CANNY_L2_GRADIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_CANNY_L2_GRADIENT = (1 &lt;&lt; 31)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6d594a0aaabd97eec25e4f1ef8c2505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d594a0aaabd97eec25e4f1ef8c2505">&#9670;&nbsp;</a></span>CV_CHAIN_CODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_CHAIN_CODE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa7da8df221f4fcc5e5de63a2bdc9dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7da8df221f4fcc5e5de63a2bdc9dea">&#9670;&nbsp;</a></span>CV_CLOCKWISE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_CLOCKWISE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a46ba42de6ee8ab6a378ff6b4293f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a46ba42de6ee8ab6a378ff6b4293f6f">&#9670;&nbsp;</a></span>CV_COMP_BHATTACHARYYA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COMP_BHATTACHARYYA = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc00452d3a1d38401dd1404bb8845d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc00452d3a1d38401dd1404bb8845d92">&#9670;&nbsp;</a></span>CV_COMP_CHISQR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COMP_CHISQR = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32e907d7e481887cf48fc9467e93ae5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e907d7e481887cf48fc9467e93ae5a">&#9670;&nbsp;</a></span>CV_COMP_CHISQR_ALT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COMP_CHISQR_ALT = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3371aa091c2628717b1861525d173cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3371aa091c2628717b1861525d173cdc">&#9670;&nbsp;</a></span>CV_COMP_CORREL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COMP_CORREL = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4761c46a82c3c5752e42c421e44acc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4761c46a82c3c5752e42c421e44acc01">&#9670;&nbsp;</a></span>CV_COMP_HELLINGER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COMP_HELLINGER = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a9a46ba42de6ee8ab6a378ff6b4293f6f">CV_COMP_BHATTACHARYYA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad766e8ff379c07c5e38241a516f7a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad766e8ff379c07c5e38241a516f7a7d8">&#9670;&nbsp;</a></span>CV_COMP_INTERSECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COMP_INTERSECT = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7e3449daca042070a990e902a9099c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e3449daca042070a990e902a9099c1">&#9670;&nbsp;</a></span>CV_COMP_KL_DIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COMP_KL_DIV = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcbfe78d2373ae57d7a25af2af071880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbfe78d2373ae57d7a25af2af071880">&#9670;&nbsp;</a></span>CV_CONTOURS_MATCH_I1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_CONTOURS_MATCH_I1 = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f9b4506d4321ec7454c97475328b252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9b4506d4321ec7454c97475328b252">&#9670;&nbsp;</a></span>CV_CONTOURS_MATCH_I2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_CONTOURS_MATCH_I2 = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01a56e5fccacab050014c159bf3cfeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a56e5fccacab050014c159bf3cfeea">&#9670;&nbsp;</a></span>CV_CONTOURS_MATCH_I3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_CONTOURS_MATCH_I3 = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e44c3a33cfa8f1c3ea6d5b6c23e3fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e44c3a33cfa8f1c3ea6d5b6c23e3fc8">&#9670;&nbsp;</a></span>CV_COUNTER_CLOCKWISE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_COUNTER_CLOCKWISE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82b63a48e2b8faf57044cadf7ebaaffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b63a48e2b8faf57044cadf7ebaaffd">&#9670;&nbsp;</a></span>CV_DIST_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_C = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11e932b759b71935decb880e357c1399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e932b759b71935decb880e357c1399">&#9670;&nbsp;</a></span>CV_DIST_FAIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_FAIR = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e4eb7e53e04996fa2143a39eb6c6407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4eb7e53e04996fa2143a39eb6c6407">&#9670;&nbsp;</a></span>CV_DIST_HUBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_HUBER = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5c12a8eda4480ab216c29900740c8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c12a8eda4480ab216c29900740c8e5">&#9670;&nbsp;</a></span>CV_DIST_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_L1 = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bf4908d9c4435ab3d788b09becc56ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf4908d9c4435ab3d788b09becc56ff">&#9670;&nbsp;</a></span>CV_DIST_L12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_L12 = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a106fccbc805cfd3b3772e2c12a5bf1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106fccbc805cfd3b3772e2c12a5bf1ea">&#9670;&nbsp;</a></span>CV_DIST_L2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_L2 = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade7928fa5eb329ee3f87c7c96b30d9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7928fa5eb329ee3f87c7c96b30d9da">&#9670;&nbsp;</a></span>CV_DIST_LABEL_CCOMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_LABEL_CCOMP = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb0b470353262c58c4673f8340ffd54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0b470353262c58c4673f8340ffd54e">&#9670;&nbsp;</a></span>CV_DIST_LABEL_PIXEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_LABEL_PIXEL = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01c8e61d341f80dc3cc2fd91697c33e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c8e61d341f80dc3cc2fd91697c33e3">&#9670;&nbsp;</a></span>CV_DIST_MASK_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_MASK_3 = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8045d0ce84a5182b25bb223b33beff3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8045d0ce84a5182b25bb223b33beff3e">&#9670;&nbsp;</a></span>CV_DIST_MASK_5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_MASK_5 = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5a74fd9d51c0e841c58edb02985b13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a74fd9d51c0e841c58edb02985b13e">&#9670;&nbsp;</a></span>CV_DIST_MASK_PRECISE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_MASK_PRECISE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76398bd47db6108fa15b6daad4e0d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76398bd47db6108fa15b6daad4e0d4cb">&#9670;&nbsp;</a></span>CV_DIST_USER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_USER = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad579ccd71787d39af99868e899b8e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad579ccd71787d39af99868e899b8e6f">&#9670;&nbsp;</a></span>CV_DIST_WELSCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_DIST_WELSCH = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a310d2a7368966dd402e44bce74de6899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310d2a7368966dd402e44bce74de6899">&#9670;&nbsp;</a></span>CV_GAUSSIAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_GAUSSIAN = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8672f047da65fd78bb0f35a281fe764c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8672f047da65fd78bb0f35a281fe764c">&#9670;&nbsp;</a></span>CV_GAUSSIAN_5x5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_GAUSSIAN_5x5 = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46fb74afe4f3535c7c2d33150ec08c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fb74afe4f3535c7c2d33150ec08c21">&#9670;&nbsp;</a></span>CV_HOUGH_GRADIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_HOUGH_GRADIENT = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec1383c2ff939d3521033a4b1fbd302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1383c2ff939d3521033a4b1fbd302">&#9670;&nbsp;</a></span>CV_HOUGH_MULTI_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_HOUGH_MULTI_SCALE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5acb5d02331fb1248e6e5e79335986be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb5d02331fb1248e6e5e79335986be">&#9670;&nbsp;</a></span>CV_HOUGH_PROBABILISTIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_HOUGH_PROBABILISTIC = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85672d58f71afdf5a20b02c97532cfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85672d58f71afdf5a20b02c97532cfdd">&#9670;&nbsp;</a></span>CV_HOUGH_STANDARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_HOUGH_STANDARD = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01d2f3b2ab4fe35adc3ecb49770ef999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d2f3b2ab4fe35adc3ecb49770ef999">&#9670;&nbsp;</a></span>CV_LINK_RUNS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_LINK_RUNS = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb9150a3481c65d5e933fb9f3190228d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9150a3481c65d5e933fb9f3190228d">&#9670;&nbsp;</a></span>CV_MAX_SOBEL_KSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_MAX_SOBEL_KSIZE = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3283cbe031bf1e6b462c2d04b14e40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3283cbe031bf1e6b462c2d04b14e40e">&#9670;&nbsp;</a></span>CV_MEDIAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_MEDIAN = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0808d6219d27bb2cfe09ced70e38183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0808d6219d27bb2cfe09ced70e38183">&#9670;&nbsp;</a></span>CV_mRGBA2RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_mRGBA2RGBA = 126</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee42565a43c4ba7bbf388daf196cb49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee42565a43c4ba7bbf388daf196cb49d">&#9670;&nbsp;</a></span>CV_POLY_APPROX_DP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_POLY_APPROX_DP = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa326180215d215f341bf36d3162954d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa326180215d215f341bf36d3162954d3">&#9670;&nbsp;</a></span>CV_RGBA2mRGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_RGBA2mRGBA = 125</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d01173573ab914c49684bc9bda441fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d01173573ab914c49684bc9bda441fb">&#9670;&nbsp;</a></span>CV_SCHARR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_SCHARR = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24295561cc4a72321041ce8c0b76c4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24295561cc4a72321041ce8c0b76c4f1">&#9670;&nbsp;</a></span>CV_SHAPE_CROSS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_SHAPE_CROSS = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f7dd4c2e3f74a9adb56402d67069794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7dd4c2e3f74a9adb56402d67069794">&#9670;&nbsp;</a></span>CV_SHAPE_CUSTOM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_SHAPE_CUSTOM = 100</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72d5ad76dbb76d20fce609928e77040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d5ad76dbb76d20fce609928e77040d">&#9670;&nbsp;</a></span>CV_SHAPE_ELLIPSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_SHAPE_ELLIPSE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9831b1b318dd4bccb7da7ae0af3f9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9831b1b318dd4bccb7da7ae0af3f9e0">&#9670;&nbsp;</a></span>CV_SHAPE_RECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_SHAPE_RECT = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a369d61dfa82600a9a8c5dab36c98b4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369d61dfa82600a9a8c5dab36c98b4db">&#9670;&nbsp;</a></span>CV_WARP_FILL_OUTLIERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_WARP_FILL_OUTLIERS = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a261a84c2d36325f8c7616af4f6f08026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261a84c2d36325f8c7616af4f6f08026">&#9670;&nbsp;</a></span>CV_WARP_INVERSE_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.CV_WARP_INVERSE_MAP = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af53efa51944b46f35adfc5e8fcd98239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53efa51944b46f35adfc5e8fcd98239">&#9670;&nbsp;</a></span>DIST_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_C = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5416ceb661cd69ed1b34a4674c65ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5416ceb661cd69ed1b34a4674c65ef">&#9670;&nbsp;</a></span>DIST_FAIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_FAIR = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8169f59f9adbc674ba6e58520c18fe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8169f59f9adbc674ba6e58520c18fe51">&#9670;&nbsp;</a></span>DIST_HUBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_HUBER = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70bb7cb6ad4718189a1a0e21301db0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bb7cb6ad4718189a1a0e21301db0f9">&#9670;&nbsp;</a></span>DIST_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_L1 = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8ed21bd40fb4b159befa421ea4ab6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ed21bd40fb4b159befa421ea4ab6e9">&#9670;&nbsp;</a></span>DIST_L12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_L12 = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79f924e45d33bd7e53b2750de0d726b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f924e45d33bd7e53b2750de0d726b9">&#9670;&nbsp;</a></span>DIST_L2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_L2 = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bf1162f90c793f443e484c8b15b7503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf1162f90c793f443e484c8b15b7503">&#9670;&nbsp;</a></span>DIST_LABEL_CCOMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_LABEL_CCOMP = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c35a92d0283d14951426c724eb07d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c35a92d0283d14951426c724eb07d9a">&#9670;&nbsp;</a></span>DIST_LABEL_PIXEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_LABEL_PIXEL = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6062f7a81793d9cd9efd09f15c3b5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6062f7a81793d9cd9efd09f15c3b5be">&#9670;&nbsp;</a></span>DIST_MASK_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_MASK_3 = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e3ecd8a3cd87cbcc208b79ddee6bb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3ecd8a3cd87cbcc208b79ddee6bb27">&#9670;&nbsp;</a></span>DIST_MASK_5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_MASK_5 = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bef27846422c2eaf1ddadf0f3a8f1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bef27846422c2eaf1ddadf0f3a8f1fc">&#9670;&nbsp;</a></span>DIST_MASK_PRECISE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_MASK_PRECISE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac517f80cb65682792ec110864490d4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac517f80cb65682792ec110864490d4eb">&#9670;&nbsp;</a></span>DIST_USER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_USER = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0280258898e9271ba0a56b979faff15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0280258898e9271ba0a56b979faff15">&#9670;&nbsp;</a></span>DIST_WELSCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.DIST_WELSCH = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0981db573c5f55ea0c930075d8240e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0981db573c5f55ea0c930075d8240e7">&#9670;&nbsp;</a></span>FILLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FILLED = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a347be864656deaf36444c5a95db2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a347be864656deaf36444c5a95db2dc">&#9670;&nbsp;</a></span>FILTER_SCHARR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FILTER_SCHARR = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1754724b0680d08d4fd1c96c63a1daa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1754724b0680d08d4fd1c96c63a1daa6">&#9670;&nbsp;</a></span>FLOODFILL_FIXED_RANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FLOODFILL_FIXED_RANGE = 1 &lt;&lt; 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3930e0cc57d7a44255f1a926df80b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3930e0cc57d7a44255f1a926df80b2c">&#9670;&nbsp;</a></span>FLOODFILL_MASK_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FLOODFILL_MASK_ONLY = 1 &lt;&lt; 17</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59237b65971fa7487aa0f84cc617566b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59237b65971fa7487aa0f84cc617566b">&#9670;&nbsp;</a></span>FONT_HERSHEY_COMPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_COMPLEX = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2053d59fee72486e9d4006ce7bc51a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2053d59fee72486e9d4006ce7bc51a4c">&#9670;&nbsp;</a></span>FONT_HERSHEY_COMPLEX_SMALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_COMPLEX_SMALL = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac796dc4cbcb681082875bc19519a62f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac796dc4cbcb681082875bc19519a62f4">&#9670;&nbsp;</a></span>FONT_HERSHEY_DUPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_DUPLEX = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a018089991ec3abdbc91440490adcd7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018089991ec3abdbc91440490adcd7eb">&#9670;&nbsp;</a></span>FONT_HERSHEY_PLAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_PLAIN = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8901f0dc6e71d5266bb1536db0e2c2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8901f0dc6e71d5266bb1536db0e2c2df">&#9670;&nbsp;</a></span>FONT_HERSHEY_SCRIPT_COMPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_SCRIPT_COMPLEX = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9f74345c92c68939e811628ae05bf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f74345c92c68939e811628ae05bf6c">&#9670;&nbsp;</a></span>FONT_HERSHEY_SCRIPT_SIMPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_SCRIPT_SIMPLEX = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a766f4d2bcd4a509e703a5c08b8138866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766f4d2bcd4a509e703a5c08b8138866">&#9670;&nbsp;</a></span>FONT_HERSHEY_SIMPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_SIMPLEX = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a211befb2e85d8448dff6c26fabf0e7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211befb2e85d8448dff6c26fabf0e7f9">&#9670;&nbsp;</a></span>FONT_HERSHEY_TRIPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_HERSHEY_TRIPLEX = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea032d9bd61fad6bb7a1851d7ec02ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea032d9bd61fad6bb7a1851d7ec02ba8">&#9670;&nbsp;</a></span>FONT_ITALIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.FONT_ITALIC = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac544e1fbb5506c450260b187e25ceda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac544e1fbb5506c450260b187e25ceda">&#9670;&nbsp;</a></span>GC_BGD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_BGD = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00bb38e8d01ab03cc46226306489be4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bb38e8d01ab03cc46226306489be4b">&#9670;&nbsp;</a></span>GC_EVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_EVAL = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a756ad278437b86b4ece9a1e4b014fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a756ad278437b86b4ece9a1e4b014fb">&#9670;&nbsp;</a></span>GC_EVAL_FREEZE_MODEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_EVAL_FREEZE_MODEL = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04e1e0f65d4222833146c44381bd85ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e1e0f65d4222833146c44381bd85ac">&#9670;&nbsp;</a></span>GC_FGD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_FGD = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4302eb4e5f105652cb8f5ab009dc00ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4302eb4e5f105652cb8f5ab009dc00ce">&#9670;&nbsp;</a></span>GC_INIT_WITH_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_INIT_WITH_MASK = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af815a3afe07216456a40346026a40015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af815a3afe07216456a40346026a40015">&#9670;&nbsp;</a></span>GC_INIT_WITH_RECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_INIT_WITH_RECT = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5583cd38f785454cfd72b7a687bc4679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5583cd38f785454cfd72b7a687bc4679">&#9670;&nbsp;</a></span>GC_PR_BGD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_PR_BGD = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0567861146ba7dbb0ccd7c6641b18a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0567861146ba7dbb0ccd7c6641b18a29">&#9670;&nbsp;</a></span>GC_PR_FGD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.GC_PR_FGD = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf242723a012b488c23517d74c9ace2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf242723a012b488c23517d74c9ace2d">&#9670;&nbsp;</a></span>HISTCMP_BHATTACHARYYA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HISTCMP_BHATTACHARYYA = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad30e4e433931ee2758fa6950ad31e333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30e4e433931ee2758fa6950ad31e333">&#9670;&nbsp;</a></span>HISTCMP_CHISQR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HISTCMP_CHISQR = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac856046261e15ce7e010df23483f82b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac856046261e15ce7e010df23483f82b4">&#9670;&nbsp;</a></span>HISTCMP_CHISQR_ALT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HISTCMP_CHISQR_ALT = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73fe91c0829a43ef7c60b60a774d8c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fe91c0829a43ef7c60b60a774d8c2e">&#9670;&nbsp;</a></span>HISTCMP_CORREL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HISTCMP_CORREL = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fa5aaa88d1d842d58740e049a3659e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa5aaa88d1d842d58740e049a3659e2">&#9670;&nbsp;</a></span>HISTCMP_HELLINGER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HISTCMP_HELLINGER = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#abf242723a012b488c23517d74c9ace2d">HISTCMP_BHATTACHARYYA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af54f8b853270f901098b907915b70f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54f8b853270f901098b907915b70f0c">&#9670;&nbsp;</a></span>HISTCMP_INTERSECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HISTCMP_INTERSECT = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfec529afe9bda0a7be31caf27ef77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfec529afe9bda0a7be31caf27ef77f">&#9670;&nbsp;</a></span>HISTCMP_KL_DIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HISTCMP_KL_DIV = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8901d713ebbcaefaa4607d79eca9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8901d713ebbcaefaa4607d79eca9ad88">&#9670;&nbsp;</a></span>HOUGH_GRADIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HOUGH_GRADIENT = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27778f2293418e3dfcbd0eba8a63740c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27778f2293418e3dfcbd0eba8a63740c">&#9670;&nbsp;</a></span>HOUGH_GRADIENT_ALT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HOUGH_GRADIENT_ALT = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b04317ee2d5ed8eccc5014019235872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b04317ee2d5ed8eccc5014019235872">&#9670;&nbsp;</a></span>HOUGH_MULTI_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HOUGH_MULTI_SCALE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a835a34a667a82c5f66b8c4aa8e078852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835a34a667a82c5f66b8c4aa8e078852">&#9670;&nbsp;</a></span>HOUGH_PROBABILISTIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HOUGH_PROBABILISTIC = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af328aa050c2f0751ee81fd813682a2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af328aa050c2f0751ee81fd813682a2dd">&#9670;&nbsp;</a></span>HOUGH_STANDARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.HOUGH_STANDARD = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd8569717c58401af4a264b98bcdcb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8569717c58401af4a264b98bcdcb47">&#9670;&nbsp;</a></span>INTER_AREA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_AREA = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a253450ffe54d8a9bf3d34c796dc27713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253450ffe54d8a9bf3d34c796dc27713">&#9670;&nbsp;</a></span>INTER_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_BITS = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73f23c8eb9e03493ce5061d7da6fe628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f23c8eb9e03493ce5061d7da6fe628">&#9670;&nbsp;</a></span>INTER_BITS2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_BITS2 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a253450ffe54d8a9bf3d34c796dc27713">INTER_BITS</a> * 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8443c77973c8c7be0cfe6ac37016773f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8443c77973c8c7be0cfe6ac37016773f">&#9670;&nbsp;</a></span>INTER_CUBIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_CUBIC = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a72412472a5833860a5c8e7b0bcfc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a72412472a5833860a5c8e7b0bcfc72">&#9670;&nbsp;</a></span>INTER_LANCZOS4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_LANCZOS4 = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e16d35f425f556033afeef60210a02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e16d35f425f556033afeef60210a02c">&#9670;&nbsp;</a></span>INTER_LINEAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_LINEAR = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac360ea8f45d858397dc8060717c5c9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac360ea8f45d858397dc8060717c5c9ab">&#9670;&nbsp;</a></span>INTER_LINEAR_EXACT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_LINEAR_EXACT = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad11fdbab00115af0f1375c897662635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11fdbab00115af0f1375c897662635b">&#9670;&nbsp;</a></span>INTER_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_MAX = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74743d222b543bc6f12feb87f31a9c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74743d222b543bc6f12feb87f31a9c55">&#9670;&nbsp;</a></span>INTER_NEAREST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_NEAREST = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6182daf93684d7d7d7dae04a7e82fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6182daf93684d7d7d7dae04a7e82fd4">&#9670;&nbsp;</a></span>INTER_NEAREST_EXACT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_NEAREST_EXACT = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6849f3fbbb982c2376a78126dd20c053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6849f3fbbb982c2376a78126dd20c053">&#9670;&nbsp;</a></span>INTER_TAB_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_TAB_SIZE = 1 &lt;&lt; <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a253450ffe54d8a9bf3d34c796dc27713">INTER_BITS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6969f22a03fa5da2d886d0148efeebd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6969f22a03fa5da2d886d0148efeebd6">&#9670;&nbsp;</a></span>INTER_TAB_SIZE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTER_TAB_SIZE2 = <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6849f3fbbb982c2376a78126dd20c053">INTER_TAB_SIZE</a> * <a class="el" href="class_open_c_v_for_unity_1_1_imgproc_module_1_1_imgproc.html#a6849f3fbbb982c2376a78126dd20c053">INTER_TAB_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa7fa64d95abed6c8365bb6feffb522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7fa64d95abed6c8365bb6feffb522b">&#9670;&nbsp;</a></span>INTERSECT_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTERSECT_FULL = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa79ab77335a6507eef9d43279b68d561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79ab77335a6507eef9d43279b68d561">&#9670;&nbsp;</a></span>INTERSECT_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTERSECT_NONE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96cba858171fdb252f77b6ea0c61b7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cba858171fdb252f77b6ea0c61b7de">&#9670;&nbsp;</a></span>INTERSECT_PARTIAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.INTERSECT_PARTIAL = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af310012e1cbe3bd4832d7b89bd108838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af310012e1cbe3bd4832d7b89bd108838">&#9670;&nbsp;</a></span>LINE_4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.LINE_4 = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92adc2426a0e2b9e74e5b027bd43be7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92adc2426a0e2b9e74e5b027bd43be7d">&#9670;&nbsp;</a></span>LINE_8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.LINE_8 = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6b7230423630026dafc311e7d8d21b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b7230423630026dafc311e7d8d21b8">&#9670;&nbsp;</a></span>LINE_AA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.LINE_AA = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44217d6ecd9000c2c6b3e256fdf1caa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44217d6ecd9000c2c6b3e256fdf1caa5">&#9670;&nbsp;</a></span>LSD_REFINE_ADV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.LSD_REFINE_ADV = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81418ddcb76acaf6142fdeed7fa5bd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81418ddcb76acaf6142fdeed7fa5bd96">&#9670;&nbsp;</a></span>LSD_REFINE_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.LSD_REFINE_NONE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9f88e74247d3f2484f28e569d159d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f88e74247d3f2484f28e569d159d50">&#9670;&nbsp;</a></span>LSD_REFINE_STD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.LSD_REFINE_STD = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6641ca6f19b1584f9c2ab250e30b3213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6641ca6f19b1584f9c2ab250e30b3213">&#9670;&nbsp;</a></span>MARKER_CROSS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MARKER_CROSS = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af660100adaebebab45b3c9e6583e555a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af660100adaebebab45b3c9e6583e555a">&#9670;&nbsp;</a></span>MARKER_DIAMOND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MARKER_DIAMOND = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53fc535edd572792c57be5e7ce579d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fc535edd572792c57be5e7ce579d1f">&#9670;&nbsp;</a></span>MARKER_SQUARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MARKER_SQUARE = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1469fc468f843e6f5d0f0b0164bfa976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1469fc468f843e6f5d0f0b0164bfa976">&#9670;&nbsp;</a></span>MARKER_STAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MARKER_STAR = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa413bb807bb0f0ff7c80cee38a1aac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa413bb807bb0f0ff7c80cee38a1aac44">&#9670;&nbsp;</a></span>MARKER_TILTED_CROSS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MARKER_TILTED_CROSS = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a488695f362d183c17d1dcf1dc7b165b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488695f362d183c17d1dcf1dc7b165b8">&#9670;&nbsp;</a></span>MARKER_TRIANGLE_DOWN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MARKER_TRIANGLE_DOWN = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4e9f8f80a2289e5dc1ac25fd5c2f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e9f8f80a2289e5dc1ac25fd5c2f0b8">&#9670;&nbsp;</a></span>MARKER_TRIANGLE_UP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MARKER_TRIANGLE_UP = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9343a52180c5843d12fa5946be689ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9343a52180c5843d12fa5946be689ba9">&#9670;&nbsp;</a></span>MORPH_BLACKHAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_BLACKHAT = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c50e2da9019c9ea9f9e9666607d3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c50e2da9019c9ea9f9e9666607d3fd">&#9670;&nbsp;</a></span>MORPH_CLOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_CLOSE = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44b97237c6127920090566d2c3bd06f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b97237c6127920090566d2c3bd06f5">&#9670;&nbsp;</a></span>MORPH_CROSS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_CROSS = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f22f6c8f32339d67522be97d39021ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f22f6c8f32339d67522be97d39021ff">&#9670;&nbsp;</a></span>MORPH_DILATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_DILATE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab08cc0080628eabb3252d8fc028c181d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08cc0080628eabb3252d8fc028c181d">&#9670;&nbsp;</a></span>MORPH_ELLIPSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_ELLIPSE = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32d0e13b982b578f699542a1aed133d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d0e13b982b578f699542a1aed133d8">&#9670;&nbsp;</a></span>MORPH_ERODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_ERODE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a919cbde8a6d706840d3d21b8d57db95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919cbde8a6d706840d3d21b8d57db95a">&#9670;&nbsp;</a></span>MORPH_GRADIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_GRADIENT = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a567268baa7fea26d4888d72ad5a5eb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567268baa7fea26d4888d72ad5a5eb27">&#9670;&nbsp;</a></span>MORPH_HITMISS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_HITMISS = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a757ead360cf1d467a71d956d538a4e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757ead360cf1d467a71d956d538a4e42">&#9670;&nbsp;</a></span>MORPH_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_OPEN = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7562c2c65f347f4c894be442bbec4515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7562c2c65f347f4c894be442bbec4515">&#9670;&nbsp;</a></span>MORPH_RECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_RECT = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a6e45ccefa056691b433603ec39663f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6e45ccefa056691b433603ec39663f">&#9670;&nbsp;</a></span>MORPH_TOPHAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.MORPH_TOPHAT = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b1b58bbda9a0eeb208e392db7d3dd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1b58bbda9a0eeb208e392db7d3dd84">&#9670;&nbsp;</a></span>RETR_CCOMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.RETR_CCOMP = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10a4ce883d819221bff4e091aeff0cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a4ce883d819221bff4e091aeff0cac">&#9670;&nbsp;</a></span>RETR_EXTERNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.RETR_EXTERNAL = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a593948e62f3191f39e8ba7087adda6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593948e62f3191f39e8ba7087adda6a9">&#9670;&nbsp;</a></span>RETR_FLOODFILL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.RETR_FLOODFILL = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8be7d69ddc37d8e0d1dcb87c30450c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be7d69ddc37d8e0d1dcb87c30450c73">&#9670;&nbsp;</a></span>RETR_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.RETR_LIST = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa71714f725ef191cbc0954ece440c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71714f725ef191cbc0954ece440c8da">&#9670;&nbsp;</a></span>RETR_TREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.RETR_TREE = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67e028e91805b98470871674c698bfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e028e91805b98470871674c698bfad">&#9670;&nbsp;</a></span>THRESH_BINARY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_BINARY = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59df462c043ae03de2521b1ba9bf7849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59df462c043ae03de2521b1ba9bf7849">&#9670;&nbsp;</a></span>THRESH_BINARY_INV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_BINARY_INV = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc0fd382bd580af2a31a1e11edc2f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0fd382bd580af2a31a1e11edc2f49a">&#9670;&nbsp;</a></span>THRESH_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_MASK = 7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32501a520c81dbdb6241d128abd3bba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32501a520c81dbdb6241d128abd3bba8">&#9670;&nbsp;</a></span>THRESH_OTSU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_OTSU = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac44b39b5c967a0ac76701c9da1103b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44b39b5c967a0ac76701c9da1103b93">&#9670;&nbsp;</a></span>THRESH_TOZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_TOZERO = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b50dc197f4aa2478e449c7d530d3eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b50dc197f4aa2478e449c7d530d3eec">&#9670;&nbsp;</a></span>THRESH_TOZERO_INV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_TOZERO_INV = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5b309160d855309ccdb47dd0097fa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b309160d855309ccdb47dd0097fa50">&#9670;&nbsp;</a></span>THRESH_TRIANGLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_TRIANGLE = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e30772c80ddae780da04e3ec6bf8e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e30772c80ddae780da04e3ec6bf8e77">&#9670;&nbsp;</a></span>THRESH_TRUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.THRESH_TRUNC = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0391d35422b0e4cee4de5a688438544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0391d35422b0e4cee4de5a688438544">&#9670;&nbsp;</a></span>TM_CCOEFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.TM_CCOEFF = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a332ff9eea011f34087d02e168b6b5f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332ff9eea011f34087d02e168b6b5f5d">&#9670;&nbsp;</a></span>TM_CCOEFF_NORMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.TM_CCOEFF_NORMED = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae12d0027daa5192f434a783a7d1fb568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12d0027daa5192f434a783a7d1fb568">&#9670;&nbsp;</a></span>TM_CCORR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.TM_CCORR = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45c1fa9fc6a67cdb8045fb88f257c925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c1fa9fc6a67cdb8045fb88f257c925">&#9670;&nbsp;</a></span>TM_CCORR_NORMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.TM_CCORR_NORMED = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bd19998b32f869dd2788a32f2012aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd19998b32f869dd2788a32f2012aaa">&#9670;&nbsp;</a></span>TM_SQDIFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.TM_SQDIFF = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae537de6f4b01aee383b35803ac343c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae537de6f4b01aee383b35803ac343c2f">&#9670;&nbsp;</a></span>TM_SQDIFF_NORMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.TM_SQDIFF_NORMED = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cc18f533966320534f05d32ff23d377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc18f533966320534f05d32ff23d377">&#9670;&nbsp;</a></span>WARP_FILL_OUTLIERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.WARP_FILL_OUTLIERS = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a905d5a97e2f56183b8b9140c641f27f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905d5a97e2f56183b8b9140c641f27f3">&#9670;&nbsp;</a></span>WARP_INVERSE_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.WARP_INVERSE_MAP = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb7de6327fef811bfbdc7fc5a46e333f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7de6327fef811bfbdc7fc5a46e333f">&#9670;&nbsp;</a></span>WARP_POLAR_LINEAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.WARP_POLAR_LINEAR = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2e5836cf9fb0f2e251dfa76e85f15fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e5836cf9fb0f2e251dfa76e85f15fc">&#9670;&nbsp;</a></span>WARP_POLAR_LOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.ImgprocModule.Imgproc.WARP_POLAR_LOG = 256</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>OpenCVForUnity/org/opencv/imgproc/<a class="el" href="_imgproc_8cs.html">Imgproc.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 7 2020 15:20:25 for OpenCV for Unity by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
