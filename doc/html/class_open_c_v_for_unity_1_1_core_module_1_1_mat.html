<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenCV for Unity: OpenCVForUnity.CoreModule.Mat Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenCV for Unity<span id="projectnumber">&#160;2.6.3</span>
   </div>
   <div id="projectbrief">Enox Software / Please refer to OpenCV official document ( http://docs.opencv.org/4.10.0/index.html ) for the details of the argument of the method.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_open_c_v_for_unity.html">OpenCVForUnity</a></li><li class="navelem"><a class="el" href="namespace_open_c_v_for_unity_1_1_core_module.html">CoreModule</a></li><li class="navelem"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_open_c_v_for_unity_1_1_core_module_1_1_mat-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OpenCVForUnity.CoreModule.Mat Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>n-dimensional dense array class  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for OpenCVForUnity.CoreModule.Mat:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_open_c_v_for_unity_1_1_core_module_1_1_mat.png" usemap="#OpenCVForUnity.CoreModule.Mat_map" alt=""/>
  <map id="OpenCVForUnity.CoreModule.Mat_map" name="OpenCVForUnity.CoreModule.Mat_map">
<area href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html" alt="OpenCVForUnity.DisposableOpenCVObject" shape="rect" coords="0,112,289,136"/>
<area href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html" alt="OpenCVForUnity.DisposableOpenCVObject" shape="rect" coords="299,112,588,136"/>
<area href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html" alt="OpenCVForUnity.DisposableOpenCVObject" shape="rect" coords="598,112,887,136"/>
<area href="class_open_c_v_for_unity_1_1_disposable_object.html" alt="OpenCVForUnity.DisposableObject" shape="rect" coords="0,56,289,80"/>
<area href="class_open_c_v_for_unity_1_1_disposable_object.html" alt="OpenCVForUnity.DisposableObject" shape="rect" coords="299,56,588,80"/>
<area href="class_open_c_v_for_unity_1_1_disposable_object.html" alt="OpenCVForUnity.DisposableObject" shape="rect" coords="598,56,887,80"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_byte.html" alt="OpenCVForUnity.CoreModule.MatOfByte" shape="rect" coords="598,224,887,248"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_d_match.html" alt="OpenCVForUnity.CoreModule.MatOfDMatch" shape="rect" coords="598,280,887,304"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_d_match.html" alt="OpenCVForUnity.CoreModule.MatOfDMatch" shape="rect" coords="598,336,887,360"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_double.html" alt="OpenCVForUnity.CoreModule.MatOfDouble" shape="rect" coords="598,392,887,416"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float.html" alt="OpenCVForUnity.CoreModule.MatOfFloat" shape="rect" coords="598,448,887,472"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float4.html" alt="OpenCVForUnity.CoreModule.MatOfFloat4" shape="rect" coords="598,504,887,528"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float4.html" alt="OpenCVForUnity.CoreModule.MatOfFloat4" shape="rect" coords="598,560,887,584"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float6.html" alt="OpenCVForUnity.CoreModule.MatOfFloat6" shape="rect" coords="598,616,887,640"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_float6.html" alt="OpenCVForUnity.CoreModule.MatOfFloat6" shape="rect" coords="598,672,887,696"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int.html" alt="OpenCVForUnity.CoreModule.MatOfInt" shape="rect" coords="598,728,887,752"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int4.html" alt="OpenCVForUnity.CoreModule.MatOfInt4" shape="rect" coords="598,784,887,808"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_int4.html" alt="OpenCVForUnity.CoreModule.MatOfInt4" shape="rect" coords="598,840,887,864"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_key_point.html" alt="OpenCVForUnity.CoreModule.MatOfKeyPoint" shape="rect" coords="598,896,887,920"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_key_point.html" alt="OpenCVForUnity.CoreModule.MatOfKeyPoint" shape="rect" coords="598,952,887,976"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html" alt="OpenCVForUnity.CoreModule.MatOfPoint" shape="rect" coords="598,1008,887,1032"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point.html" alt="OpenCVForUnity.CoreModule.MatOfPoint" shape="rect" coords="598,1064,887,1088"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html" alt="OpenCVForUnity.CoreModule.MatOfPoint2f" shape="rect" coords="598,1120,887,1144"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point2f.html" alt="OpenCVForUnity.CoreModule.MatOfPoint2f" shape="rect" coords="598,1176,887,1200"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point3.html" alt="OpenCVForUnity.CoreModule.MatOfPoint3" shape="rect" coords="598,1232,887,1256"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point3.html" alt="OpenCVForUnity.CoreModule.MatOfPoint3" shape="rect" coords="598,1288,887,1312"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point3f.html" alt="OpenCVForUnity.CoreModule.MatOfPoint3f" shape="rect" coords="598,1344,887,1368"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_point3f.html" alt="OpenCVForUnity.CoreModule.MatOfPoint3f" shape="rect" coords="598,1400,887,1424"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_rect.html" alt="OpenCVForUnity.CoreModule.MatOfRect" shape="rect" coords="598,1456,887,1480"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_rect.html" alt="OpenCVForUnity.CoreModule.MatOfRect" shape="rect" coords="598,1512,887,1536"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_rect2d.html" alt="OpenCVForUnity.CoreModule.MatOfRect2d" shape="rect" coords="598,1568,887,1592"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_rect2d.html" alt="OpenCVForUnity.CoreModule.MatOfRect2d" shape="rect" coords="598,1624,887,1648"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_rotated_rect.html" alt="OpenCVForUnity.CoreModule.MatOfRotatedRect" shape="rect" coords="598,1680,887,1704"/>
<area href="class_open_c_v_for_unity_1_1_core_module_1_1_mat_of_rotated_rect.html" alt="OpenCVForUnity.CoreModule.MatOfRotatedRect" shape="rect" coords="598,1736,887,1760"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa72bf9d9607cbb0af6e4e3f11bd8b9ba" id="r_aa72bf9d9607cbb0af6e4e3f11bd8b9ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> (IntPtr addr)</td></tr>
<tr class="separator:aa72bf9d9607cbb0af6e4e3f11bd8b9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dab3c9cf93248d9ebe1d13a4b453e3e" id="r_a2dab3c9cf93248d9ebe1d13a4b453e3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dab3c9cf93248d9ebe1d13a4b453e3e">Mat</a> ()</td></tr>
<tr class="separator:a2dab3c9cf93248d9ebe1d13a4b453e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7d4972f5d5c3a02158a8d8f32d7cbb" id="r_afa7d4972f5d5c3a02158a8d8f32d7cbb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa7d4972f5d5c3a02158a8d8f32d7cbb">Mat</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="separator:afa7d4972f5d5c3a02158a8d8f32d7cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07998ca9da3c7f0f0795a1b1094b36a4" id="r_a07998ca9da3c7f0f0795a1b1094b36a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07998ca9da3c7f0f0795a1b1094b36a4">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="separator:a07998ca9da3c7f0f0795a1b1094b36a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac400c0b218eb3ab4b4094c25ac14ebdd" id="r_ac400c0b218eb3ab4b4094c25ac14ebdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac400c0b218eb3ab4b4094c25ac14ebdd">Mat</a> (int[] sizes, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="separator:ac400c0b218eb3ab4b4094c25ac14ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cee01044b874e1b3c00917ae8c6bbf" id="r_ae0cee01044b874e1b3c00917ae8c6bbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0cee01044b874e1b3c00917ae8c6bbf">Mat</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="separator:ae0cee01044b874e1b3c00917ae8c6bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06415b4fc88181a17bc32fe8eb043c23" id="r_a06415b4fc88181a17bc32fe8eb043c23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06415b4fc88181a17bc32fe8eb043c23">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="separator:a06415b4fc88181a17bc32fe8eb043c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63d1cfdddb90f7d5c0c153dc57062ee" id="r_ae63d1cfdddb90f7d5c0c153dc57062ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63d1cfdddb90f7d5c0c153dc57062ee">Mat</a> (int[] sizes, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="separator:ae63d1cfdddb90f7d5c0c153dc57062ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa06de7b72a805cf5fc6b083d5a4ec44" id="r_afa06de7b72a805cf5fc6b083d5a4ec44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa06de7b72a805cf5fc6b083d5a4ec44">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> <a class="el" href="#ab0ebb50b3a9213bad850944413013a90">colRange</a>)</td></tr>
<tr class="separator:afa06de7b72a805cf5fc6b083d5a4ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0384ced6b7bf035f75c6b1dfd079c1" id="r_aff0384ced6b7bf035f75c6b1dfd079c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0384ced6b7bf035f75c6b1dfd079c1">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>)</td></tr>
<tr class="separator:aff0384ced6b7bf035f75c6b1dfd079c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c02633a8b13cfbc3f56a777cf92da0" id="r_af2c02633a8b13cfbc3f56a777cf92da0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2c02633a8b13cfbc3f56a777cf92da0">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a>[] ranges)</td></tr>
<tr class="separator:af2c02633a8b13cfbc3f56a777cf92da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc203c41f2abfe025ac2ad7653b155" id="r_a76dc203c41f2abfe025ac2ad7653b155"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76dc203c41f2abfe025ac2ad7653b155">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> roi)</td></tr>
<tr class="separator:a76dc203c41f2abfe025ac2ad7653b155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956aeb913a92797dcc5f6a6aa8ebf17e" id="r_a956aeb913a92797dcc5f6a6aa8ebf17e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a956aeb913a92797dcc5f6a6aa8ebf17e">Mat</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, IntPtr data, long step=<a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a>)</td></tr>
<tr class="separator:a956aeb913a92797dcc5f6a6aa8ebf17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774031f49d8e16c2262c8cc791d13b78" id="r_a774031f49d8e16c2262c8cc791d13b78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774031f49d8e16c2262c8cc791d13b78">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, IntPtr data, long step=<a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a>)</td></tr>
<tr class="separator:a774031f49d8e16c2262c8cc791d13b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91687b339124b7d84e550c9396e122e7" id="r_a91687b339124b7d84e550c9396e122e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91687b339124b7d84e550c9396e122e7">adjustROI</a> (int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr class="memdesc:a91687b339124b7d84e550c9396e122e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts a submatrix size and position within the parent matrix.  <br /></td></tr>
<tr class="separator:a91687b339124b7d84e550c9396e122e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246d10f53ef54ba5e4b1c86e46672ccd" id="r_a246d10f53ef54ba5e4b1c86e46672ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a246d10f53ef54ba5e4b1c86e46672ccd">assignTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a246d10f53ef54ba5e4b1c86e46672ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a functional form of convertTo.  <br /></td></tr>
<tr class="separator:a246d10f53ef54ba5e4b1c86e46672ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090860925704d0d3adaadf0150b40395" id="r_a090860925704d0d3adaadf0150b40395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a090860925704d0d3adaadf0150b40395">assignTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="memdesc:a090860925704d0d3adaadf0150b40395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a functional form of convertTo.  <br /></td></tr>
<tr class="separator:a090860925704d0d3adaadf0150b40395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32150fedad53188ace78de63421702b1" id="r_a32150fedad53188ace78de63421702b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32150fedad53188ace78de63421702b1">channels</a> ()</td></tr>
<tr class="memdesc:a32150fedad53188ace78de63421702b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of matrix channels.  <br /></td></tr>
<tr class="separator:a32150fedad53188ace78de63421702b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6118bdf829063d8563b5b08446867342" id="r_a6118bdf829063d8563b5b08446867342"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6118bdf829063d8563b5b08446867342">checkVector</a> (int elemChannels, int <a class="el" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a>, bool requireContinuous)</td></tr>
<tr class="separator:a6118bdf829063d8563b5b08446867342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f4fb0ff44f1e760cc48ec5d576b2f0" id="r_a65f4fb0ff44f1e760cc48ec5d576b2f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65f4fb0ff44f1e760cc48ec5d576b2f0">checkVector</a> (int elemChannels, int <a class="el" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a>)</td></tr>
<tr class="separator:a65f4fb0ff44f1e760cc48ec5d576b2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45319b179670bc99d25531b90b9677e7" id="r_a45319b179670bc99d25531b90b9677e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45319b179670bc99d25531b90b9677e7">checkVector</a> (int elemChannels)</td></tr>
<tr class="separator:a45319b179670bc99d25531b90b9677e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727f0d641cd857acdd14bfce16c3aa54" id="r_a727f0d641cd857acdd14bfce16c3aa54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54">clone</a> ()</td></tr>
<tr class="memdesc:a727f0d641cd857acdd14bfce16c3aa54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a full copy of the array and the underlying data.  <br /></td></tr>
<tr class="separator:a727f0d641cd857acdd14bfce16c3aa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506138d3fb9e7f4ba618b93e0455fa86" id="r_a506138d3fb9e7f4ba618b93e0455fa86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a> (int x)</td></tr>
<tr class="memdesc:a506138d3fb9e7f4ba618b93e0455fa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified matrix column.  <br /></td></tr>
<tr class="separator:a506138d3fb9e7f4ba618b93e0455fa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ebb50b3a9213bad850944413013a90" id="r_ab0ebb50b3a9213bad850944413013a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0ebb50b3a9213bad850944413013a90">colRange</a> (int startcol, int endcol)</td></tr>
<tr class="memdesc:ab0ebb50b3a9213bad850944413013a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified column span.  <br /></td></tr>
<tr class="separator:ab0ebb50b3a9213bad850944413013a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5716f7648a36e01b51c1107b1a1d5c24" id="r_a5716f7648a36e01b51c1107b1a1d5c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5716f7648a36e01b51c1107b1a1d5c24">colRange</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> r)</td></tr>
<tr class="memdesc:a5716f7648a36e01b51c1107b1a1d5c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified column span.  <br /></td></tr>
<tr class="separator:a5716f7648a36e01b51c1107b1a1d5c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1325b9e0d8749f1aeb01fa0603143f" id="r_a7d1325b9e0d8749f1aeb01fa0603143f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d1325b9e0d8749f1aeb01fa0603143f">dims</a> ()</td></tr>
<tr class="separator:a7d1325b9e0d8749f1aeb01fa0603143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6b006c4c77d88cbeb2463f09ead6fb" id="r_afb6b006c4c77d88cbeb2463f09ead6fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a> ()</td></tr>
<tr class="separator:afb6b006c4c77d88cbeb2463f09ead6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d02605d9843365941fa911908a7f1" id="r_ae89d02605d9843365941fa911908a7f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89d02605d9843365941fa911908a7f1">convertTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, int rtype, double alpha, double beta)</td></tr>
<tr class="memdesc:ae89d02605d9843365941fa911908a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array to another data type with optional scaling.  <br /></td></tr>
<tr class="separator:ae89d02605d9843365941fa911908a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d994b1fde7037d5d10bb417b0066f2" id="r_a88d994b1fde7037d5d10bb417b0066f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88d994b1fde7037d5d10bb417b0066f2">convertTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, int rtype, double alpha)</td></tr>
<tr class="memdesc:a88d994b1fde7037d5d10bb417b0066f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array to another data type with optional scaling.  <br /></td></tr>
<tr class="separator:a88d994b1fde7037d5d10bb417b0066f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b83526a304f477005ee15e26924c222" id="r_a8b83526a304f477005ee15e26924c222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b83526a304f477005ee15e26924c222">convertTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, int rtype)</td></tr>
<tr class="memdesc:a8b83526a304f477005ee15e26924c222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array to another data type with optional scaling.  <br /></td></tr>
<tr class="separator:a8b83526a304f477005ee15e26924c222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acada63cfb833b34c63965b16be65d6" id="r_a2acada63cfb833b34c63965b16be65d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2acada63cfb833b34c63965b16be65d6">copyTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="memdesc:a2acada63cfb833b34c63965b16be65d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the matrix to another one.  <br /></td></tr>
<tr class="separator:a2acada63cfb833b34c63965b16be65d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e5ee6218e000f2e294edd3db5b9b0" id="r_a7f9e5ee6218e000f2e294edd3db5b9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f9e5ee6218e000f2e294edd3db5b9b0">copyTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="memdesc:a7f9e5ee6218e000f2e294edd3db5b9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the matrix to another one.  <br /></td></tr>
<tr class="separator:a7f9e5ee6218e000f2e294edd3db5b9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18f5d2799293f7fe5219451eb9ac7f1" id="r_ab18f5d2799293f7fe5219451eb9ac7f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1">create</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:ab18f5d2799293f7fe5219451eb9ac7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates new array data if needed.  <br /></td></tr>
<tr class="separator:ab18f5d2799293f7fe5219451eb9ac7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5113257c73c9f0fe2893056b0eb8f1" id="r_ada5113257c73c9f0fe2893056b0eb8f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5113257c73c9f0fe2893056b0eb8f1">create</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:ada5113257c73c9f0fe2893056b0eb8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates new array data if needed.  <br /></td></tr>
<tr class="separator:ada5113257c73c9f0fe2893056b0eb8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085b7a8e4934f0a520f1e7e594654495" id="r_a085b7a8e4934f0a520f1e7e594654495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a085b7a8e4934f0a520f1e7e594654495">create</a> (int[] sizes, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a085b7a8e4934f0a520f1e7e594654495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates new array data if needed.  <br /></td></tr>
<tr class="separator:a085b7a8e4934f0a520f1e7e594654495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6547e08b4259c708ee85a5015ce35e" id="r_a0f6547e08b4259c708ee85a5015ce35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6547e08b4259c708ee85a5015ce35e">copySize</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="separator:a0f6547e08b4259c708ee85a5015ce35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b53dbbdaf1491f0cc3863f5e052885" id="r_ad8b53dbbdaf1491f0cc3863f5e052885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b53dbbdaf1491f0cc3863f5e052885">cross</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="memdesc:ad8b53dbbdaf1491f0cc3863f5e052885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a cross-product of two 3-element vectors.  <br /></td></tr>
<tr class="separator:ad8b53dbbdaf1491f0cc3863f5e052885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b372e9c678fe6c2e3d0fa3d7d43951" id="r_aa8b372e9c678fe6c2e3d0fa3d7d43951"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b372e9c678fe6c2e3d0fa3d7d43951">dataAddr</a> ()</td></tr>
<tr class="memdesc:aa8b372e9c678fe6c2e3d0fa3d7d43951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first pointer address of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> data.  <br /></td></tr>
<tr class="separator:aa8b372e9c678fe6c2e3d0fa3d7d43951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca862341a7b26b18e96e41933ee9a49" id="r_a3ca862341a7b26b18e96e41933ee9a49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a> ()</td></tr>
<tr class="memdesc:a3ca862341a7b26b18e96e41933ee9a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the depth of a matrix element.  <br /></td></tr>
<tr class="separator:a3ca862341a7b26b18e96e41933ee9a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cdf2367d666a83f6af334d01475672" id="r_a26cdf2367d666a83f6af334d01475672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26cdf2367d666a83f6af334d01475672">diag</a> (int d)</td></tr>
<tr class="memdesc:a26cdf2367d666a83f6af334d01475672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a diagonal from a matrix.  <br /></td></tr>
<tr class="separator:a26cdf2367d666a83f6af334d01475672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5493cbddeaf7b18dfb15cd983e027be3" id="r_a5493cbddeaf7b18dfb15cd983e027be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5493cbddeaf7b18dfb15cd983e027be3">diag</a> ()</td></tr>
<tr class="memdesc:a5493cbddeaf7b18dfb15cd983e027be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a diagonal from a matrix.  <br /></td></tr>
<tr class="separator:a5493cbddeaf7b18dfb15cd983e027be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87394e8979587ef2f5cf9a062ba2a62a" id="r_a87394e8979587ef2f5cf9a062ba2a62a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87394e8979587ef2f5cf9a062ba2a62a">dot</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="memdesc:a87394e8979587ef2f5cf9a062ba2a62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a dot-product of two vectors.  <br /></td></tr>
<tr class="separator:a87394e8979587ef2f5cf9a062ba2a62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df92b8f53f26ad2a6b2a7654a153bcc" id="r_a2df92b8f53f26ad2a6b2a7654a153bcc"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc">elemSize</a> ()</td></tr>
<tr class="memdesc:a2df92b8f53f26ad2a6b2a7654a153bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix element size in bytes.  <br /></td></tr>
<tr class="separator:a2df92b8f53f26ad2a6b2a7654a153bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725885019d65746f656ff5697b00033f" id="r_a725885019d65746f656ff5697b00033f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725885019d65746f656ff5697b00033f">elemSize1</a> ()</td></tr>
<tr class="memdesc:a725885019d65746f656ff5697b00033f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of each matrix element channel in bytes.  <br /></td></tr>
<tr class="separator:a725885019d65746f656ff5697b00033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bd1b40a4d9b9b1c0df4deb795b5295" id="r_a21bd1b40a4d9b9b1c0df4deb795b5295"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21bd1b40a4d9b9b1c0df4deb795b5295">empty</a> ()</td></tr>
<tr class="memdesc:a21bd1b40a4d9b9b1c0df4deb795b5295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the array has no elements.  <br /></td></tr>
<tr class="separator:a21bd1b40a4d9b9b1c0df4deb795b5295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265fa032291f4b8db3ad35239c7625f5" id="r_a265fa032291f4b8db3ad35239c7625f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265fa032291f4b8db3ad35239c7625f5">inv</a> (int method)</td></tr>
<tr class="memdesc:a265fa032291f4b8db3ad35239c7625f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverses a matrix.  <br /></td></tr>
<tr class="separator:a265fa032291f4b8db3ad35239c7625f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dc67d6f17bd8488bed57fdcfd8f630" id="r_ae8dc67d6f17bd8488bed57fdcfd8f630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8dc67d6f17bd8488bed57fdcfd8f630">inv</a> ()</td></tr>
<tr class="memdesc:ae8dc67d6f17bd8488bed57fdcfd8f630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverses a matrix.  <br /></td></tr>
<tr class="separator:ae8dc67d6f17bd8488bed57fdcfd8f630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d3d12b95ce8f9bcb7b61dc78de6275" id="r_a63d3d12b95ce8f9bcb7b61dc78de6275"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275">isContinuous</a> ()</td></tr>
<tr class="memdesc:a63d3d12b95ce8f9bcb7b61dc78de6275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the matrix is continuous or not.  <br /></td></tr>
<tr class="separator:a63d3d12b95ce8f9bcb7b61dc78de6275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e89ce1e4e254e7ad3cfa7a11a41b3e9" id="r_a2e89ce1e4e254e7ad3cfa7a11a41b3e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e89ce1e4e254e7ad3cfa7a11a41b3e9">isSubmatrix</a> ()</td></tr>
<tr class="separator:a2e89ce1e4e254e7ad3cfa7a11a41b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0ba88c8c3ae6c0bd3531bfe2e1ef44" id="r_a3d0ba88c8c3ae6c0bd3531bfe2e1ef44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d0ba88c8c3ae6c0bd3531bfe2e1ef44">locateROI</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> wholeSize, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a> ofs)</td></tr>
<tr class="memdesc:a3d0ba88c8c3ae6c0bd3531bfe2e1ef44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the matrix header within a parent matrix.  <br /></td></tr>
<tr class="separator:a3d0ba88c8c3ae6c0bd3531bfe2e1ef44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f71afba9acec61497456f922282abdb" id="r_a2f71afba9acec61497456f922282abdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f71afba9acec61497456f922282abdb">mul</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, double scale)</td></tr>
<tr class="memdesc:a2f71afba9acec61497456f922282abdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an element-wise multiplication or division of the two matrices.  <br /></td></tr>
<tr class="separator:a2f71afba9acec61497456f922282abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379c0d4aad35e0cc1195fe6126c92e56" id="r_a379c0d4aad35e0cc1195fe6126c92e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a379c0d4aad35e0cc1195fe6126c92e56">mul</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="memdesc:a379c0d4aad35e0cc1195fe6126c92e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise multiplication.  <br /></td></tr>
<tr class="separator:a379c0d4aad35e0cc1195fe6126c92e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7c10c6469bf85b5245e23517c5ca7a" id="r_a6b7c10c6469bf85b5245e23517c5ca7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7c10c6469bf85b5245e23517c5ca7a">matMul</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="separator:a6b7c10c6469bf85b5245e23517c5ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b8ed3b4fb1ea7c8decb10b0a1087a" id="r_a241b8ed3b4fb1ea7c8decb10b0a1087a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a241b8ed3b4fb1ea7c8decb10b0a1087a">push_back</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m)</td></tr>
<tr class="memdesc:a241b8ed3b4fb1ea7c8decb10b0a1087a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds elements to the bottom of the matrix.  <br /></td></tr>
<tr class="separator:a241b8ed3b4fb1ea7c8decb10b0a1087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034d3e2b4ce0d37e7058ce55e8b1899b" id="r_a034d3e2b4ce0d37e7058ce55e8b1899b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a034d3e2b4ce0d37e7058ce55e8b1899b">release</a> ()</td></tr>
<tr class="memdesc:a034d3e2b4ce0d37e7058ce55e8b1899b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference counter and deallocates the matrix if needed.  <br /></td></tr>
<tr class="separator:a034d3e2b4ce0d37e7058ce55e8b1899b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494b45ba5c2e9a65d753ca6a11ffe1a" id="r_a9494b45ba5c2e9a65d753ca6a11ffe1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9494b45ba5c2e9a65d753ca6a11ffe1a">reshape</a> (int cn, int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>)</td></tr>
<tr class="memdesc:a9494b45ba5c2e9a65d753ca6a11ffe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the shape and/or the number of channels of a 2D matrix without copying the data.  <br /></td></tr>
<tr class="separator:a9494b45ba5c2e9a65d753ca6a11ffe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af58355f22f240f11903799c4715d71" id="r_a5af58355f22f240f11903799c4715d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af58355f22f240f11903799c4715d71">reshape</a> (int cn)</td></tr>
<tr class="memdesc:a5af58355f22f240f11903799c4715d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the shape and/or the number of channels of a 2D matrix without copying the data.  <br /></td></tr>
<tr class="separator:a5af58355f22f240f11903799c4715d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada118abf428f03501c6c89f94d8aa36b" id="r_ada118abf428f03501c6c89f94d8aa36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada118abf428f03501c6c89f94d8aa36b">reshape</a> (int cn, int[] newshape)</td></tr>
<tr class="memdesc:ada118abf428f03501c6c89f94d8aa36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the shape and/or the number of channels of a 2D matrix without copying the data.  <br /></td></tr>
<tr class="separator:ada118abf428f03501c6c89f94d8aa36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0109de8c8bfbbd232a29268091ffdbb" id="r_ab0109de8c8bfbbd232a29268091ffdbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a> (int y)</td></tr>
<tr class="memdesc:ab0109de8c8bfbbd232a29268091ffdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified matrix row.  <br /></td></tr>
<tr class="separator:ab0109de8c8bfbbd232a29268091ffdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb0424ec8cde559cb1c2343e863e127" id="r_acfb0424ec8cde559cb1c2343e863e127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a> (int startrow, int endrow)</td></tr>
<tr class="memdesc:acfb0424ec8cde559cb1c2343e863e127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified row span.  <br /></td></tr>
<tr class="separator:acfb0424ec8cde559cb1c2343e863e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743deb2f14606f07ebba5a4a0722e5d6" id="r_a743deb2f14606f07ebba5a4a0722e5d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a743deb2f14606f07ebba5a4a0722e5d6">rowRange</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> r)</td></tr>
<tr class="memdesc:a743deb2f14606f07ebba5a4a0722e5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified row span.  <br /></td></tr>
<tr class="separator:a743deb2f14606f07ebba5a4a0722e5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9877819470ffa970b88727037342d458" id="r_a9877819470ffa970b88727037342d458"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9877819470ffa970b88727037342d458">rows</a> ()</td></tr>
<tr class="separator:a9877819470ffa970b88727037342d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18e915ae5367254558ae21a1b45664c" id="r_ad18e915ae5367254558ae21a1b45664c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad18e915ae5367254558ae21a1b45664c">setTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="memdesc:ad18e915ae5367254558ae21a1b45664c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:ad18e915ae5367254558ae21a1b45664c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae059646f6d862a774822dfed11c1bbb5" id="r_ae059646f6d862a774822dfed11c1bbb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae059646f6d862a774822dfed11c1bbb5">setTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> value, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="memdesc:ae059646f6d862a774822dfed11c1bbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:ae059646f6d862a774822dfed11c1bbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10091848ca8380610a2b0fed62c5891" id="r_aa10091848ca8380610a2b0fed62c5891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa10091848ca8380610a2b0fed62c5891">setTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> value, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="memdesc:aa10091848ca8380610a2b0fed62c5891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:aa10091848ca8380610a2b0fed62c5891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5fc0fe15f1f8a7631ad1a93359537c" id="r_a5c5fc0fe15f1f8a7631ad1a93359537c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c5fc0fe15f1f8a7631ad1a93359537c">setTo</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> value)</td></tr>
<tr class="memdesc:a5c5fc0fe15f1f8a7631ad1a93359537c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:a5c5fc0fe15f1f8a7631ad1a93359537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd78d83d7206bf4c4ee61850bf4d0375" id="r_abd78d83d7206bf4c4ee61850bf4d0375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a> ()</td></tr>
<tr class="separator:abd78d83d7206bf4c4ee61850bf4d0375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c01e126e9f2b5ac5753377907c34fc" id="r_ac5c01e126e9f2b5ac5753377907c34fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5c01e126e9f2b5ac5753377907c34fc">size</a> (int i)</td></tr>
<tr class="separator:ac5c01e126e9f2b5ac5753377907c34fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5af46909a86d548e62e64912547f20" id="r_a2c5af46909a86d548e62e64912547f20"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5af46909a86d548e62e64912547f20">step1</a> (int i)</td></tr>
<tr class="memdesc:a2c5af46909a86d548e62e64912547f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a normalized step.  <br /></td></tr>
<tr class="separator:a2c5af46909a86d548e62e64912547f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b88cb2fd7eb23ae0d60e657f8d579aa" id="r_a8b88cb2fd7eb23ae0d60e657f8d579aa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b88cb2fd7eb23ae0d60e657f8d579aa">step1</a> ()</td></tr>
<tr class="memdesc:a8b88cb2fd7eb23ae0d60e657f8d579aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a normalized step.  <br /></td></tr>
<tr class="separator:a8b88cb2fd7eb23ae0d60e657f8d579aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac9038fdbdc543453a7a2a825100484" id="r_a1ac9038fdbdc543453a7a2a825100484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ac9038fdbdc543453a7a2a825100484">submat</a> (int rowStart, int rowEnd, int colStart, int colEnd)</td></tr>
<tr class="memdesc:a1ac9038fdbdc543453a7a2a825100484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:a1ac9038fdbdc543453a7a2a825100484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852cafabddf1020464d6d9b26a6077c7" id="r_a852cafabddf1020464d6d9b26a6077c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a852cafabddf1020464d6d9b26a6077c7">submat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> <a class="el" href="#ab0ebb50b3a9213bad850944413013a90">colRange</a>)</td></tr>
<tr class="memdesc:a852cafabddf1020464d6d9b26a6077c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:a852cafabddf1020464d6d9b26a6077c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa06bfabd37052cc5170e184769e644" id="r_a3aa06bfabd37052cc5170e184769e644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa06bfabd37052cc5170e184769e644">submat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a>[] ranges)</td></tr>
<tr class="memdesc:a3aa06bfabd37052cc5170e184769e644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:a3aa06bfabd37052cc5170e184769e644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42bf1c582dd11f3968051296751f2fa" id="r_af42bf1c582dd11f3968051296751f2fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af42bf1c582dd11f3968051296751f2fa">submat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a> roi)</td></tr>
<tr class="memdesc:af42bf1c582dd11f3968051296751f2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:af42bf1c582dd11f3968051296751f2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c93fdb9e80d98c05d7167ef747de2c1" id="r_a2c93fdb9e80d98c05d7167ef747de2c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c93fdb9e80d98c05d7167ef747de2c1">t</a> ()</td></tr>
<tr class="memdesc:a2c93fdb9e80d98c05d7167ef747de2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a matrix.  <br /></td></tr>
<tr class="separator:a2c93fdb9e80d98c05d7167ef747de2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2049918ee53b9b95746cbec329515bd" id="r_ac2049918ee53b9b95746cbec329515bd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2049918ee53b9b95746cbec329515bd">total</a> ()</td></tr>
<tr class="memdesc:ac2049918ee53b9b95746cbec329515bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of array elements.  <br /></td></tr>
<tr class="separator:ac2049918ee53b9b95746cbec329515bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50fde5c175a561068025df6b35363f1" id="r_ab50fde5c175a561068025df6b35363f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a> ()</td></tr>
<tr class="memdesc:ab50fde5c175a561068025df6b35363f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of a matrix element.  <br /></td></tr>
<tr class="separator:ab50fde5c175a561068025df6b35363f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7ac403115ecf9d8c95df555e05adcc" id="r_a1b7ac403115ecf9d8c95df555e05adcc"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b7ac403115ecf9d8c95df555e05adcc">ToString</a> ()</td></tr>
<tr class="separator:a1b7ac403115ecf9d8c95df555e05adcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489ff76fb92b63ba47628f0f568499eb" id="r_a489ff76fb92b63ba47628f0f568499eb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a489ff76fb92b63ba47628f0f568499eb">dump</a> ()</td></tr>
<tr class="memdesc:a489ff76fb92b63ba47628f0f568499eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of the visualized matrix in String format.  <br /></td></tr>
<tr class="separator:a489ff76fb92b63ba47628f0f568499eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a33d0eae5471f567303c0905ef1e75c" id="r_a8a33d0eae5471f567303c0905ef1e75c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, params double[] data)</td></tr>
<tr class="memdesc:a8a33d0eae5471f567303c0905ef1e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a double array to the matrix at the given row and column, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a8a33d0eae5471f567303c0905ef1e75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7638db6178dda563562d3b23415e7dd5" id="r_a7638db6178dda563562d3b23415e7dd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7638db6178dda563562d3b23415e7dd5">put</a> (int[] idx, params double[] data)</td></tr>
<tr class="memdesc:a7638db6178dda563562d3b23415e7dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a double array to the matrix at the given indices, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a7638db6178dda563562d3b23415e7dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c0f854f0d9b759ebc9b2fc1d4ae33" id="r_a5e1c0f854f0d9b759ebc9b2fc1d4ae33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e1c0f854f0d9b759ebc9b2fc1d4ae33">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, float[] data)</td></tr>
<tr class="memdesc:a5e1c0f854f0d9b759ebc9b2fc1d4ae33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a float array to the matrix at a specified row and column.  <br /></td></tr>
<tr class="separator:a5e1c0f854f0d9b759ebc9b2fc1d4ae33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b03be1fc4ae6ec9f25952e14e96d71b" id="r_a0b03be1fc4ae6ec9f25952e14e96d71b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b03be1fc4ae6ec9f25952e14e96d71b">put</a> (int[] idx, float[] data)</td></tr>
<tr class="memdesc:a0b03be1fc4ae6ec9f25952e14e96d71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a float array to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a0b03be1fc4ae6ec9f25952e14e96d71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb551cdc8d566708b45513ef4702ce6" id="r_aeeb551cdc8d566708b45513ef4702ce6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeb551cdc8d566708b45513ef4702ce6">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, int[] data)</td></tr>
<tr class="memdesc:aeeb551cdc8d566708b45513ef4702ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an int array to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:aeeb551cdc8d566708b45513ef4702ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c81a4ebb2675512257f5e9cb06c76" id="r_a177c81a4ebb2675512257f5e9cb06c76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a177c81a4ebb2675512257f5e9cb06c76">put</a> (int[] idx, int[] data)</td></tr>
<tr class="memdesc:a177c81a4ebb2675512257f5e9cb06c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an int array to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a177c81a4ebb2675512257f5e9cb06c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89935206629d1acbc59e2dc0d33ed5f3" id="r_a89935206629d1acbc59e2dc0d33ed5f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89935206629d1acbc59e2dc0d33ed5f3">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, short[] data)</td></tr>
<tr class="memdesc:a89935206629d1acbc59e2dc0d33ed5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short array to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a89935206629d1acbc59e2dc0d33ed5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0d9cb266e6ef1240342a0a1e0c8ad4" id="r_a9d0d9cb266e6ef1240342a0a1e0c8ad4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d0d9cb266e6ef1240342a0a1e0c8ad4">put</a> (int[] idx, short[] data)</td></tr>
<tr class="memdesc:a9d0d9cb266e6ef1240342a0a1e0c8ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short array to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a9d0d9cb266e6ef1240342a0a1e0c8ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b1982f8a07596740a1639b0be4727e" id="r_a70b1982f8a07596740a1639b0be4727e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70b1982f8a07596740a1639b0be4727e">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, byte[] data)</td></tr>
<tr class="memdesc:a70b1982f8a07596740a1639b0be4727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a byte array to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a70b1982f8a07596740a1639b0be4727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c1ea9be6b9bfe9b8eda8374620aad0" id="r_a53c1ea9be6b9bfe9b8eda8374620aad0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c1ea9be6b9bfe9b8eda8374620aad0">put</a> (int[] idx, byte[] data)</td></tr>
<tr class="memdesc:a53c1ea9be6b9bfe9b8eda8374620aad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a byte array to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a53c1ea9be6b9bfe9b8eda8374620aad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9edfa2271a1985a9f071eea7cc21d2" id="r_a1a9edfa2271a1985a9f071eea7cc21d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a9edfa2271a1985a9f071eea7cc21d2">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, byte[] data, int offset, int length)</td></tr>
<tr class="memdesc:a1a9edfa2271a1985a9f071eea7cc21d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of byte values to the matrix at the given row and column, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:a1a9edfa2271a1985a9f071eea7cc21d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4da73bb973f1229e675722fbd83e9e" id="r_aee4da73bb973f1229e675722fbd83e9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee4da73bb973f1229e675722fbd83e9e">put</a> (int[] idx, byte[] data, int offset, int length)</td></tr>
<tr class="memdesc:aee4da73bb973f1229e675722fbd83e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of byte values to the matrix at the given indices, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:aee4da73bb973f1229e675722fbd83e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4ab7b8b3837945ec745b9cd716c4f4" id="r_acf4ab7b8b3837945ec745b9cd716c4f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, byte[] data)</td></tr>
<tr class="memdesc:acf4ab7b8b3837945ec745b9cd716c4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a byte array from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:acf4ab7b8b3837945ec745b9cd716c4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840d87423fdc2d48b3116db3a5ec3847" id="r_a840d87423fdc2d48b3116db3a5ec3847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a840d87423fdc2d48b3116db3a5ec3847">get</a> (int[] idx, byte[] data)</td></tr>
<tr class="memdesc:a840d87423fdc2d48b3116db3a5ec3847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a byte array from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a840d87423fdc2d48b3116db3a5ec3847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e7410365b11635f4d01814de38a5a5" id="r_ac5e7410365b11635f4d01814de38a5a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e7410365b11635f4d01814de38a5a5">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, short[] data)</td></tr>
<tr class="memdesc:ac5e7410365b11635f4d01814de38a5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a short array from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ac5e7410365b11635f4d01814de38a5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c910eeb3c7de269b4ab09c089f888f" id="r_a27c910eeb3c7de269b4ab09c089f888f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27c910eeb3c7de269b4ab09c089f888f">get</a> (int[] idx, short[] data)</td></tr>
<tr class="memdesc:a27c910eeb3c7de269b4ab09c089f888f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a short array from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a27c910eeb3c7de269b4ab09c089f888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c5ae4fa818026cd60a795ccb903c89" id="r_ad2c5ae4fa818026cd60a795ccb903c89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2c5ae4fa818026cd60a795ccb903c89">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, int[] data)</td></tr>
<tr class="memdesc:ad2c5ae4fa818026cd60a795ccb903c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an int array from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ad2c5ae4fa818026cd60a795ccb903c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad661c4b32d54fb322b5b94d162ebb583" id="r_ad661c4b32d54fb322b5b94d162ebb583"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad661c4b32d54fb322b5b94d162ebb583">get</a> (int[] idx, int[] data)</td></tr>
<tr class="memdesc:ad661c4b32d54fb322b5b94d162ebb583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an int array from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:ad661c4b32d54fb322b5b94d162ebb583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc39ebf9af120b931ec051726d9b207" id="r_a1bc39ebf9af120b931ec051726d9b207"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bc39ebf9af120b931ec051726d9b207">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, float[] data)</td></tr>
<tr class="memdesc:a1bc39ebf9af120b931ec051726d9b207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a float array from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a1bc39ebf9af120b931ec051726d9b207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9224a703f566c8c0a56f03cd59adba" id="r_a1a9224a703f566c8c0a56f03cd59adba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a9224a703f566c8c0a56f03cd59adba">get</a> (int[] idx, float[] data)</td></tr>
<tr class="memdesc:a1a9224a703f566c8c0a56f03cd59adba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a float array from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a1a9224a703f566c8c0a56f03cd59adba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae779595270008b59c79d4d3170b174b6" id="r_ae779595270008b59c79d4d3170b174b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae779595270008b59c79d4d3170b174b6">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, double[] data)</td></tr>
<tr class="memdesc:ae779595270008b59c79d4d3170b174b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a double array from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ae779595270008b59c79d4d3170b174b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851638cab40e428725a162284c402b5c" id="r_a851638cab40e428725a162284c402b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a851638cab40e428725a162284c402b5c">get</a> (int[] idx, double[] data)</td></tr>
<tr class="memdesc:a851638cab40e428725a162284c402b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a double array from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a851638cab40e428725a162284c402b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7525c41bb48e1f00560d6d072a8efe96" id="r_a7525c41bb48e1f00560d6d072a8efe96"><td class="memItemLeft" align="right" valign="top">double[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7525c41bb48e1f00560d6d072a8efe96">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>)</td></tr>
<tr class="memdesc:a7525c41bb48e1f00560d6d072a8efe96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the element values from the matrix at the specified row and column, returning them as an array of double values.  <br /></td></tr>
<tr class="separator:a7525c41bb48e1f00560d6d072a8efe96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e6ea0e3935176db035ca68e038fe5f" id="r_a46e6ea0e3935176db035ca68e038fe5f"><td class="memItemLeft" align="right" valign="top">double[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e6ea0e3935176db035ca68e038fe5f">get</a> (int[] idx)</td></tr>
<tr class="memdesc:a46e6ea0e3935176db035ca68e038fe5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the element values from the matrix at the specified indices, returning them as an array of double values.  <br /></td></tr>
<tr class="separator:a46e6ea0e3935176db035ca68e038fe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f44328c9c29259e9545b1980ead568" id="r_a84f44328c9c29259e9545b1980ead568"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a> ()</td></tr>
<tr class="memdesc:a84f44328c9c29259e9545b1980ead568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the matrix.  <br /></td></tr>
<tr class="separator:a84f44328c9c29259e9545b1980ead568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56037a2f49c55b0ecfb68f476acacb1" id="r_ae56037a2f49c55b0ecfb68f476acacb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae56037a2f49c55b0ecfb68f476acacb1">width</a> ()</td></tr>
<tr class="memdesc:ae56037a2f49c55b0ecfb68f476acacb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the matrix.  <br /></td></tr>
<tr class="separator:ae56037a2f49c55b0ecfb68f476acacb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb04de545c7edc06d906484571762561" id="r_aeb04de545c7edc06d906484571762561"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb04de545c7edc06d906484571762561">getNativeObjAddr</a> ()</td></tr>
<tr class="separator:aeb04de545c7edc06d906484571762561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458a080104cbaf422917e49b0bc7e370" id="r_a458a080104cbaf422917e49b0bc7e370"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a458a080104cbaf422917e49b0bc7e370">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, byte[] data, int length)</td></tr>
<tr class="memdesc:a458a080104cbaf422917e49b0bc7e370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a byte array to the matrix at a specified row and column.  <br /></td></tr>
<tr class="separator:a458a080104cbaf422917e49b0bc7e370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea08d7e5c39fac456b829b802c188ef2" id="r_aea08d7e5c39fac456b829b802c188ef2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea08d7e5c39fac456b829b802c188ef2">put</a> (int[] idx, byte[] data, int length)</td></tr>
<tr class="memdesc:aea08d7e5c39fac456b829b802c188ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of byte values to the matrix at the given indices.  <br /></td></tr>
<tr class="separator:aea08d7e5c39fac456b829b802c188ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840a6f50d01c6ccb93525b7c51555767" id="r_a840a6f50d01c6ccb93525b7c51555767"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a840a6f50d01c6ccb93525b7c51555767">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, sbyte[] data)</td></tr>
<tr class="memdesc:a840a6f50d01c6ccb93525b7c51555767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a sbyte array to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a840a6f50d01c6ccb93525b7c51555767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dbd74c6cc7b118654118f6902fe153" id="r_ac1dbd74c6cc7b118654118f6902fe153"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1dbd74c6cc7b118654118f6902fe153">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, sbyte[] data, int length)</td></tr>
<tr class="memdesc:ac1dbd74c6cc7b118654118f6902fe153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of sbyte values to the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:ac1dbd74c6cc7b118654118f6902fe153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a10e4a652ee3416e8ac181e2a8e0ec" id="r_aa5a10e4a652ee3416e8ac181e2a8e0ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5a10e4a652ee3416e8ac181e2a8e0ec">put</a> (int[] idx, sbyte[] data)</td></tr>
<tr class="memdesc:aa5a10e4a652ee3416e8ac181e2a8e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a sbyte array to the matrix at the specified multi-dimensional indices.  <br /></td></tr>
<tr class="separator:aa5a10e4a652ee3416e8ac181e2a8e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1928333f566024fe466e9e43f3d11f2" id="r_ae1928333f566024fe466e9e43f3d11f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1928333f566024fe466e9e43f3d11f2">put</a> (int[] idx, sbyte[] data, int length)</td></tr>
<tr class="memdesc:ae1928333f566024fe466e9e43f3d11f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of sbyte values to the matrix at the given indices.  <br /></td></tr>
<tr class="separator:ae1928333f566024fe466e9e43f3d11f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f35c7f6da6ec7972bd218c8603825b" id="r_ae3f35c7f6da6ec7972bd218c8603825b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3f35c7f6da6ec7972bd218c8603825b">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, sbyte[] data, int offset, int length)</td></tr>
<tr class="memdesc:ae3f35c7f6da6ec7972bd218c8603825b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of sbyte values to the matrix at the given row and column, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:ae3f35c7f6da6ec7972bd218c8603825b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23eeac63b6ed70fd59b86f49782f15d5" id="r_a23eeac63b6ed70fd59b86f49782f15d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23eeac63b6ed70fd59b86f49782f15d5">put</a> (int[] idx, sbyte[] data, int offset, int length)</td></tr>
<tr class="memdesc:a23eeac63b6ed70fd59b86f49782f15d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of sbyte values to the matrix at the given indices, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:a23eeac63b6ed70fd59b86f49782f15d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d27f118e5864c514f40eb30cf26e79" id="r_a01d27f118e5864c514f40eb30cf26e79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01d27f118e5864c514f40eb30cf26e79">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, ushort[] data)</td></tr>
<tr class="memdesc:a01d27f118e5864c514f40eb30cf26e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an ushort array to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a01d27f118e5864c514f40eb30cf26e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7c3550577239b4df6fc6387d0d8437" id="r_a9a7c3550577239b4df6fc6387d0d8437"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a7c3550577239b4df6fc6387d0d8437">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, ushort[] data, int length)</td></tr>
<tr class="memdesc:a9a7c3550577239b4df6fc6387d0d8437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of ushort values to the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:a9a7c3550577239b4df6fc6387d0d8437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18f92dc319fe415e6bd1ef4257d3565" id="r_aa18f92dc319fe415e6bd1ef4257d3565"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa18f92dc319fe415e6bd1ef4257d3565">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, ushort[] data, int offset, int length)</td></tr>
<tr class="memdesc:aa18f92dc319fe415e6bd1ef4257d3565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of ushort values to the matrix at the given row and column, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:aa18f92dc319fe415e6bd1ef4257d3565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af311092c6edc12608a6b6dd1f5e55212" id="r_af311092c6edc12608a6b6dd1f5e55212"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af311092c6edc12608a6b6dd1f5e55212">put</a> (int[] idx, ushort[] data)</td></tr>
<tr class="memdesc:af311092c6edc12608a6b6dd1f5e55212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an ushort array to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:af311092c6edc12608a6b6dd1f5e55212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7667e0db1ebf4c64c8a0fc9d879af5a" id="r_ab7667e0db1ebf4c64c8a0fc9d879af5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7667e0db1ebf4c64c8a0fc9d879af5a">put</a> (int[] idx, ushort[] data, int length)</td></tr>
<tr class="memdesc:ab7667e0db1ebf4c64c8a0fc9d879af5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of ushort values to the matrix at the given indices.  <br /></td></tr>
<tr class="separator:ab7667e0db1ebf4c64c8a0fc9d879af5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087fb8cf28d3870e19fd1038ff5823e" id="r_a8087fb8cf28d3870e19fd1038ff5823e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8087fb8cf28d3870e19fd1038ff5823e">put</a> (int[] idx, ushort[] data, int offset, int length)</td></tr>
<tr class="memdesc:a8087fb8cf28d3870e19fd1038ff5823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of ushort values to the matrix at the given indices, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:a8087fb8cf28d3870e19fd1038ff5823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea600f52b1964f3c1f543e464d2b69ef" id="r_aea600f52b1964f3c1f543e464d2b69ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea600f52b1964f3c1f543e464d2b69ef">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, short[] data, int length)</td></tr>
<tr class="memdesc:aea600f52b1964f3c1f543e464d2b69ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of short values to the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:aea600f52b1964f3c1f543e464d2b69ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd23d26022438f40106f27e2adae57" id="r_aebbd23d26022438f40106f27e2adae57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebbd23d26022438f40106f27e2adae57">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, short[] data, int offset, int length)</td></tr>
<tr class="memdesc:aebbd23d26022438f40106f27e2adae57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of short values to the matrix at the given row and column, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:aebbd23d26022438f40106f27e2adae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d995539c1551c152eeb6d7427fd1a2" id="r_ab4d995539c1551c152eeb6d7427fd1a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4d995539c1551c152eeb6d7427fd1a2">put</a> (int[] idx, short[] data, int length)</td></tr>
<tr class="memdesc:ab4d995539c1551c152eeb6d7427fd1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of short values to the matrix at the given indices.  <br /></td></tr>
<tr class="separator:ab4d995539c1551c152eeb6d7427fd1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b4522f397514f9f18655ccc1101943" id="r_ad8b4522f397514f9f18655ccc1101943"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b4522f397514f9f18655ccc1101943">put</a> (int[] idx, short[] data, int offset, int length)</td></tr>
<tr class="memdesc:ad8b4522f397514f9f18655ccc1101943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of short values to the matrix at the given indices, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:ad8b4522f397514f9f18655ccc1101943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1635016e6b7614038cd82b75d195e181" id="r_a1635016e6b7614038cd82b75d195e181"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1635016e6b7614038cd82b75d195e181">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, int[] data, int length)</td></tr>
<tr class="memdesc:a1635016e6b7614038cd82b75d195e181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of int values to the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:a1635016e6b7614038cd82b75d195e181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1428edf5ac92c32af049a34fa5c40fc3" id="r_a1428edf5ac92c32af049a34fa5c40fc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1428edf5ac92c32af049a34fa5c40fc3">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, int[] data, int offset, int length)</td></tr>
<tr class="memdesc:a1428edf5ac92c32af049a34fa5c40fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of int values to the matrix at the given row and column, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:a1428edf5ac92c32af049a34fa5c40fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae074f0b994aa9adb1158bc8e94af2cc" id="r_aae074f0b994aa9adb1158bc8e94af2cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae074f0b994aa9adb1158bc8e94af2cc">put</a> (int[] idx, int[] data, int length)</td></tr>
<tr class="memdesc:aae074f0b994aa9adb1158bc8e94af2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of int values to the matrix at the given indices.  <br /></td></tr>
<tr class="separator:aae074f0b994aa9adb1158bc8e94af2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b1957c5e5185ffc41303d4d81f84a8" id="r_ae6b1957c5e5185ffc41303d4d81f84a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b1957c5e5185ffc41303d4d81f84a8">put</a> (int[] idx, int[] data, int offset, int length)</td></tr>
<tr class="memdesc:ae6b1957c5e5185ffc41303d4d81f84a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of int values to the matrix at the given indices, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:ae6b1957c5e5185ffc41303d4d81f84a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e63442b80488044468124015bb8e21" id="r_aa8e63442b80488044468124015bb8e21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8e63442b80488044468124015bb8e21">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, float[] data, int length)</td></tr>
<tr class="memdesc:aa8e63442b80488044468124015bb8e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of float values to the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:aa8e63442b80488044468124015bb8e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1bee0eedc737207e9f4d58c29950ce" id="r_a8f1bee0eedc737207e9f4d58c29950ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f1bee0eedc737207e9f4d58c29950ce">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, float[] data, int offset, int length)</td></tr>
<tr class="memdesc:a8f1bee0eedc737207e9f4d58c29950ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of float values to the matrix at the given row and column, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:a8f1bee0eedc737207e9f4d58c29950ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac61ed515651bf3db5272de8464556dd" id="r_aac61ed515651bf3db5272de8464556dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac61ed515651bf3db5272de8464556dd">put</a> (int[] idx, float[] data, int length)</td></tr>
<tr class="memdesc:aac61ed515651bf3db5272de8464556dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of float values to the matrix at the given indices.  <br /></td></tr>
<tr class="separator:aac61ed515651bf3db5272de8464556dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097204bc9674e65bc16c480d226bfc9f" id="r_a097204bc9674e65bc16c480d226bfc9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a097204bc9674e65bc16c480d226bfc9f">put</a> (int[] idx, float[] data, int offset, int length)</td></tr>
<tr class="memdesc:a097204bc9674e65bc16c480d226bfc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of float values to the matrix at the given indices, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:a097204bc9674e65bc16c480d226bfc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecceb90744aa8027d7b4c97017bf636" id="r_aaecceb90744aa8027d7b4c97017bf636"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaecceb90744aa8027d7b4c97017bf636">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, double[] data, int length)</td></tr>
<tr class="memdesc:aaecceb90744aa8027d7b4c97017bf636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of double values to the matrix at the given row and column, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:aaecceb90744aa8027d7b4c97017bf636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5164a4fc6739c6e269ed6af0bf2c7e" id="r_a2c5164a4fc6739c6e269ed6af0bf2c7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5164a4fc6739c6e269ed6af0bf2c7e">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, double[] data, int offset, int length)</td></tr>
<tr class="memdesc:a2c5164a4fc6739c6e269ed6af0bf2c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of double values to the matrix at the given row and column, starting from the specified offset within the data array, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a2c5164a4fc6739c6e269ed6af0bf2c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4684d58ac209bbbfc5f2a8182f234049" id="r_a4684d58ac209bbbfc5f2a8182f234049"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4684d58ac209bbbfc5f2a8182f234049">put</a> (int[] idx, double[] data, int length)</td></tr>
<tr class="memdesc:a4684d58ac209bbbfc5f2a8182f234049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of double values to the matrix at the given indices, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a4684d58ac209bbbfc5f2a8182f234049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51558bab992c19081c6257bd9c11689b" id="r_a51558bab992c19081c6257bd9c11689b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51558bab992c19081c6257bd9c11689b">put</a> (int[] idx, double[] data, int offset, int length)</td></tr>
<tr class="memdesc:a51558bab992c19081c6257bd9c11689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a specified number of double values to the matrix at the given indices, starting from the specified offset within the data array, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a51558bab992c19081c6257bd9c11689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c49506c0fefa5c37493a8911d269eb" id="r_a04c49506c0fefa5c37493a8911d269eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04c49506c0fefa5c37493a8911d269eb">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, byte[] data, int length)</td></tr>
<tr class="memdesc:a04c49506c0fefa5c37493a8911d269eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of byte values from the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:a04c49506c0fefa5c37493a8911d269eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e5a67212f88d7d77fb6d43b2504c85" id="r_a77e5a67212f88d7d77fb6d43b2504c85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77e5a67212f88d7d77fb6d43b2504c85">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, byte[] data, int offset, int length)</td></tr>
<tr class="memdesc:a77e5a67212f88d7d77fb6d43b2504c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of byte values from the matrix at the given row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a77e5a67212f88d7d77fb6d43b2504c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba4d128b6e9af6fceaebecbea072608" id="r_a0ba4d128b6e9af6fceaebecbea072608"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba4d128b6e9af6fceaebecbea072608">get</a> (int[] idx, byte[] data, int length)</td></tr>
<tr class="memdesc:a0ba4d128b6e9af6fceaebecbea072608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of byte values from the matrix at the given indices.  <br /></td></tr>
<tr class="separator:a0ba4d128b6e9af6fceaebecbea072608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad69938d5e2fdd185ec8067af5b356a" id="r_aaad69938d5e2fdd185ec8067af5b356a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad69938d5e2fdd185ec8067af5b356a">get</a> (int[] idx, byte[] data, int offset, int length)</td></tr>
<tr class="memdesc:aaad69938d5e2fdd185ec8067af5b356a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of byte values from the matrix at the given indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:aaad69938d5e2fdd185ec8067af5b356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59c958963a17765ea7e42c8c5ba0ce8" id="r_af59c958963a17765ea7e42c8c5ba0ce8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af59c958963a17765ea7e42c8c5ba0ce8">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, sbyte[] data)</td></tr>
<tr class="memdesc:af59c958963a17765ea7e42c8c5ba0ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a sbyte array from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:af59c958963a17765ea7e42c8c5ba0ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce6ec43c8537b19cc0ae7768048faea" id="r_a5ce6ec43c8537b19cc0ae7768048faea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ce6ec43c8537b19cc0ae7768048faea">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, sbyte[] data, int length)</td></tr>
<tr class="memdesc:a5ce6ec43c8537b19cc0ae7768048faea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of sbyte values from the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:a5ce6ec43c8537b19cc0ae7768048faea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0a70ac86e461c2b68a4d95ac879e9" id="r_aecb0a70ac86e461c2b68a4d95ac879e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecb0a70ac86e461c2b68a4d95ac879e9">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, sbyte[] data, int offset, int length)</td></tr>
<tr class="memdesc:aecb0a70ac86e461c2b68a4d95ac879e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of sbyte values from the matrix at the given row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:aecb0a70ac86e461c2b68a4d95ac879e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6c3b1fd2793ea26593de44ab4cfb86" id="r_a4a6c3b1fd2793ea26593de44ab4cfb86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a6c3b1fd2793ea26593de44ab4cfb86">get</a> (int[] idx, sbyte[] data)</td></tr>
<tr class="memdesc:a4a6c3b1fd2793ea26593de44ab4cfb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a sbyte array from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a4a6c3b1fd2793ea26593de44ab4cfb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145e61dab3962bd0754d9c273686e036" id="r_a145e61dab3962bd0754d9c273686e036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a145e61dab3962bd0754d9c273686e036">get</a> (int[] idx, sbyte[] data, int length)</td></tr>
<tr class="memdesc:a145e61dab3962bd0754d9c273686e036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of sbyte values from the matrix at the given indices.  <br /></td></tr>
<tr class="separator:a145e61dab3962bd0754d9c273686e036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e31ed0c1e476f30a014c28146ef8ffc" id="r_a9e31ed0c1e476f30a014c28146ef8ffc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e31ed0c1e476f30a014c28146ef8ffc">get</a> (int[] idx, sbyte[] data, int offset, int length)</td></tr>
<tr class="memdesc:a9e31ed0c1e476f30a014c28146ef8ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of sbyte values from the matrix at the given indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a9e31ed0c1e476f30a014c28146ef8ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c032e58142fc109362b381a30f69c" id="r_aef0c032e58142fc109362b381a30f69c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef0c032e58142fc109362b381a30f69c">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, ushort[] data)</td></tr>
<tr class="memdesc:aef0c032e58142fc109362b381a30f69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an ushort array from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:aef0c032e58142fc109362b381a30f69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351db39339ba875c6679f08cd7d36279" id="r_a351db39339ba875c6679f08cd7d36279"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a351db39339ba875c6679f08cd7d36279">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, ushort[] data, int length)</td></tr>
<tr class="memdesc:a351db39339ba875c6679f08cd7d36279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of ushort values from the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:a351db39339ba875c6679f08cd7d36279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338c555a7fa694d97e855867250dd70d" id="r_a338c555a7fa694d97e855867250dd70d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a338c555a7fa694d97e855867250dd70d">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, ushort[] data, int offset, int length)</td></tr>
<tr class="memdesc:a338c555a7fa694d97e855867250dd70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of ushort values from the matrix at the given row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a338c555a7fa694d97e855867250dd70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41d2fabe6b82955f366a40e8654907" id="r_afe41d2fabe6b82955f366a40e8654907"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe41d2fabe6b82955f366a40e8654907">get</a> (int[] idx, ushort[] data)</td></tr>
<tr class="memdesc:afe41d2fabe6b82955f366a40e8654907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an ushort array from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:afe41d2fabe6b82955f366a40e8654907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa2289abcc8008c0b69f28d2c1bc637" id="r_affa2289abcc8008c0b69f28d2c1bc637"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affa2289abcc8008c0b69f28d2c1bc637">get</a> (int[] idx, ushort[] data, int length)</td></tr>
<tr class="memdesc:affa2289abcc8008c0b69f28d2c1bc637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of ushort values from the matrix at the given indices.  <br /></td></tr>
<tr class="separator:affa2289abcc8008c0b69f28d2c1bc637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f83d145fbd5fac11ff10a3d8baed66" id="r_a17f83d145fbd5fac11ff10a3d8baed66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17f83d145fbd5fac11ff10a3d8baed66">get</a> (int[] idx, ushort[] data, int offset, int length)</td></tr>
<tr class="memdesc:a17f83d145fbd5fac11ff10a3d8baed66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of ushort values from the matrix at the given indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a17f83d145fbd5fac11ff10a3d8baed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cd6698974799a8e1d56f3786802869" id="r_ac8cd6698974799a8e1d56f3786802869"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8cd6698974799a8e1d56f3786802869">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, short[] data, int length)</td></tr>
<tr class="memdesc:ac8cd6698974799a8e1d56f3786802869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of short values from the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:ac8cd6698974799a8e1d56f3786802869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3ba4486a0c9f61ad0142b60e287af0" id="r_afa3ba4486a0c9f61ad0142b60e287af0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa3ba4486a0c9f61ad0142b60e287af0">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, short[] data, int offset, int length)</td></tr>
<tr class="memdesc:afa3ba4486a0c9f61ad0142b60e287af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of short values from the matrix at the given row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:afa3ba4486a0c9f61ad0142b60e287af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cf19e01367ed93c7571e058a46cc7a" id="r_ad6cf19e01367ed93c7571e058a46cc7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6cf19e01367ed93c7571e058a46cc7a">get</a> (int[] idx, short[] data, int length)</td></tr>
<tr class="memdesc:ad6cf19e01367ed93c7571e058a46cc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of short values from the matrix at the given indices.  <br /></td></tr>
<tr class="separator:ad6cf19e01367ed93c7571e058a46cc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b3903bbf8c3d33f5eba8d728e55f19" id="r_ad8b3903bbf8c3d33f5eba8d728e55f19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b3903bbf8c3d33f5eba8d728e55f19">get</a> (int[] idx, short[] data, int offset, int length)</td></tr>
<tr class="memdesc:ad8b3903bbf8c3d33f5eba8d728e55f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of short values from the matrix at the given indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:ad8b3903bbf8c3d33f5eba8d728e55f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad971b8a17c7fe69a8813d75f62df58eb" id="r_ad971b8a17c7fe69a8813d75f62df58eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad971b8a17c7fe69a8813d75f62df58eb">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, int[] data, int length)</td></tr>
<tr class="memdesc:ad971b8a17c7fe69a8813d75f62df58eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of int values from the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:ad971b8a17c7fe69a8813d75f62df58eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eeb0d140bcf4c4472d91696dab527f2" id="r_a0eeb0d140bcf4c4472d91696dab527f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eeb0d140bcf4c4472d91696dab527f2">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, int[] data, int offset, int length)</td></tr>
<tr class="memdesc:a0eeb0d140bcf4c4472d91696dab527f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of int values from the matrix at the given row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a0eeb0d140bcf4c4472d91696dab527f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312a2ef6bdeab9bcff4d239f50375537" id="r_a312a2ef6bdeab9bcff4d239f50375537"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a312a2ef6bdeab9bcff4d239f50375537">get</a> (int[] idx, int[] data, int length)</td></tr>
<tr class="memdesc:a312a2ef6bdeab9bcff4d239f50375537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of int values from the matrix at the given indices.  <br /></td></tr>
<tr class="separator:a312a2ef6bdeab9bcff4d239f50375537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0429c78e1d49c590c6a73796a115d153" id="r_a0429c78e1d49c590c6a73796a115d153"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0429c78e1d49c590c6a73796a115d153">get</a> (int[] idx, int[] data, int offset, int length)</td></tr>
<tr class="memdesc:a0429c78e1d49c590c6a73796a115d153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of int values from the matrix at the given indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a0429c78e1d49c590c6a73796a115d153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54a52deba32a3f2d0f4fa63452c5198" id="r_ab54a52deba32a3f2d0f4fa63452c5198"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab54a52deba32a3f2d0f4fa63452c5198">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, float[] data, int length)</td></tr>
<tr class="memdesc:ab54a52deba32a3f2d0f4fa63452c5198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of float values from the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:ab54a52deba32a3f2d0f4fa63452c5198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8bb0a83642e60ce2f869d4c26ca27f" id="r_a4f8bb0a83642e60ce2f869d4c26ca27f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f8bb0a83642e60ce2f869d4c26ca27f">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, float[] data, int offset, int length)</td></tr>
<tr class="memdesc:a4f8bb0a83642e60ce2f869d4c26ca27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of float values from the matrix at the given row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a4f8bb0a83642e60ce2f869d4c26ca27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752bf34aac499908e4ba8475f40fd28f" id="r_a752bf34aac499908e4ba8475f40fd28f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a752bf34aac499908e4ba8475f40fd28f">get</a> (int[] idx, float[] data, int length)</td></tr>
<tr class="memdesc:a752bf34aac499908e4ba8475f40fd28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of float values from the matrix at the given indices.  <br /></td></tr>
<tr class="separator:a752bf34aac499908e4ba8475f40fd28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba4a2a795bdaf3075ae12ad8c3b7f06" id="r_adba4a2a795bdaf3075ae12ad8c3b7f06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adba4a2a795bdaf3075ae12ad8c3b7f06">get</a> (int[] idx, float[] data, int offset, int length)</td></tr>
<tr class="memdesc:adba4a2a795bdaf3075ae12ad8c3b7f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of float values from the matrix at the given indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:adba4a2a795bdaf3075ae12ad8c3b7f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046487a4740bf4ad0966e8e795cf99b7" id="r_a046487a4740bf4ad0966e8e795cf99b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a046487a4740bf4ad0966e8e795cf99b7">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, double[] data, int length)</td></tr>
<tr class="memdesc:a046487a4740bf4ad0966e8e795cf99b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of double values from the matrix at the given row and column.  <br /></td></tr>
<tr class="separator:a046487a4740bf4ad0966e8e795cf99b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef39668fb892353bb376ba142ac6be7b" id="r_aef39668fb892353bb376ba142ac6be7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef39668fb892353bb376ba142ac6be7b">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, double[] data, int offset, int length)</td></tr>
<tr class="memdesc:aef39668fb892353bb376ba142ac6be7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of double values from the matrix at the given row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:aef39668fb892353bb376ba142ac6be7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bc60589f9d824011f0adba76132394" id="r_af4bc60589f9d824011f0adba76132394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4bc60589f9d824011f0adba76132394">get</a> (int[] idx, double[] data, int length)</td></tr>
<tr class="memdesc:af4bc60589f9d824011f0adba76132394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of double values from the matrix at the given indices.  <br /></td></tr>
<tr class="separator:af4bc60589f9d824011f0adba76132394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a3ca8706b26b2f518e95264a350f9a" id="r_ae3a3ca8706b26b2f518e95264a350f9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a3ca8706b26b2f518e95264a350f9a">get</a> (int[] idx, double[] data, int offset, int length)</td></tr>
<tr class="memdesc:ae3a3ca8706b26b2f518e95264a350f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a specified number of double values from the matrix at the given indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:ae3a3ca8706b26b2f518e95264a350f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c010033f5fa376044824ba3399d483c" id="r_a1c010033f5fa376044824ba3399d483c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c010033f5fa376044824ba3399d483c">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; byte &gt; data)</td></tr>
<tr class="memdesc:a1c010033f5fa376044824ba3399d483c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of byte data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a1c010033f5fa376044824ba3399d483c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d69274812793dd61c5178a49c7b9d5" id="r_aa8d69274812793dd61c5178a49c7b9d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8d69274812793dd61c5178a49c7b9d5">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; byte &gt; data, int length)</td></tr>
<tr class="memdesc:aa8d69274812793dd61c5178a49c7b9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of byte data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:aa8d69274812793dd61c5178a49c7b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185c509b1c77e6af866e423854fb780f" id="r_a185c509b1c77e6af866e423854fb780f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a185c509b1c77e6af866e423854fb780f">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; byte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a185c509b1c77e6af866e423854fb780f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of byte data to the matrix at the specified row and column, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:a185c509b1c77e6af866e423854fb780f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0060c259f71a7e9a1361637c9da8a307" id="r_a0060c259f71a7e9a1361637c9da8a307"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0060c259f71a7e9a1361637c9da8a307">put</a> (int[] idx, Span&lt; byte &gt; data)</td></tr>
<tr class="memdesc:a0060c259f71a7e9a1361637c9da8a307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of byte data to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a0060c259f71a7e9a1361637c9da8a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711c294050473ea988d9815ecc78f93b" id="r_a711c294050473ea988d9815ecc78f93b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a711c294050473ea988d9815ecc78f93b">put</a> (int[] idx, Span&lt; byte &gt; data, int length)</td></tr>
<tr class="memdesc:a711c294050473ea988d9815ecc78f93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of byte data to the matrix at the specified indices with a specified length.  <br /></td></tr>
<tr class="separator:a711c294050473ea988d9815ecc78f93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff98250bb5468e5134cc06cb9f9c5335" id="r_aff98250bb5468e5134cc06cb9f9c5335"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff98250bb5468e5134cc06cb9f9c5335">put</a> (int[] idx, Span&lt; byte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:aff98250bb5468e5134cc06cb9f9c5335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of byte data to the matrix at the specified indices, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:aff98250bb5468e5134cc06cb9f9c5335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29611f961a387dc09c25111e60fe44d" id="r_ab29611f961a387dc09c25111e60fe44d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29611f961a387dc09c25111e60fe44d">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; sbyte &gt; data)</td></tr>
<tr class="memdesc:ab29611f961a387dc09c25111e60fe44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of sbyte data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ab29611f961a387dc09c25111e60fe44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5a5dc6014a9bfa07b5df3e0d2cdb48" id="r_a6a5a5dc6014a9bfa07b5df3e0d2cdb48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5a5dc6014a9bfa07b5df3e0d2cdb48">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; sbyte &gt; data, int length)</td></tr>
<tr class="memdesc:a6a5a5dc6014a9bfa07b5df3e0d2cdb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of sbyte data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a6a5a5dc6014a9bfa07b5df3e0d2cdb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12a63d3f06b55790c4152aba3c44007" id="r_ac12a63d3f06b55790c4152aba3c44007"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac12a63d3f06b55790c4152aba3c44007">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; sbyte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:ac12a63d3f06b55790c4152aba3c44007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of sbyte data to the matrix at the specified row and column, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:ac12a63d3f06b55790c4152aba3c44007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13bf7a15739caf8cd7dbeac551bf454" id="r_ac13bf7a15739caf8cd7dbeac551bf454"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac13bf7a15739caf8cd7dbeac551bf454">put</a> (int[] idx, Span&lt; sbyte &gt; data)</td></tr>
<tr class="memdesc:ac13bf7a15739caf8cd7dbeac551bf454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of sbyte data to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:ac13bf7a15739caf8cd7dbeac551bf454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2c8b7a51dc27b5e49472765051e4fa" id="r_a7f2c8b7a51dc27b5e49472765051e4fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f2c8b7a51dc27b5e49472765051e4fa">put</a> (int[] idx, Span&lt; sbyte &gt; data, int length)</td></tr>
<tr class="memdesc:a7f2c8b7a51dc27b5e49472765051e4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of sbyte data to the matrix at the specified indices with a specified length.  <br /></td></tr>
<tr class="separator:a7f2c8b7a51dc27b5e49472765051e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd89e629b8a297e7696be7329a129b3" id="r_a4fd89e629b8a297e7696be7329a129b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fd89e629b8a297e7696be7329a129b3">put</a> (int[] idx, Span&lt; sbyte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a4fd89e629b8a297e7696be7329a129b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of sbyte data to the matrix at the specified indices, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:a4fd89e629b8a297e7696be7329a129b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcc5a7e708e665717df8d95243c24ea" id="r_a1fcc5a7e708e665717df8d95243c24ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fcc5a7e708e665717df8d95243c24ea">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; ushort &gt; data)</td></tr>
<tr class="memdesc:a1fcc5a7e708e665717df8d95243c24ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of ushort data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a1fcc5a7e708e665717df8d95243c24ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6994a26d34b87fad1b8127f078263012" id="r_a6994a26d34b87fad1b8127f078263012"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6994a26d34b87fad1b8127f078263012">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; ushort &gt; data, int length)</td></tr>
<tr class="memdesc:a6994a26d34b87fad1b8127f078263012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of ushort data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a6994a26d34b87fad1b8127f078263012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb155af47b321126e6ca1ca5891c4d3c" id="r_abb155af47b321126e6ca1ca5891c4d3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb155af47b321126e6ca1ca5891c4d3c">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; ushort &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:abb155af47b321126e6ca1ca5891c4d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of ushort data to the matrix at the specified row and column, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:abb155af47b321126e6ca1ca5891c4d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e75e9682cf316d61b248368ba47585e" id="r_a7e75e9682cf316d61b248368ba47585e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e75e9682cf316d61b248368ba47585e">put</a> (int[] idx, Span&lt; ushort &gt; data)</td></tr>
<tr class="memdesc:a7e75e9682cf316d61b248368ba47585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of ushort data to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a7e75e9682cf316d61b248368ba47585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648f1531b9c06928338338d0b868752c" id="r_a648f1531b9c06928338338d0b868752c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a648f1531b9c06928338338d0b868752c">put</a> (int[] idx, Span&lt; ushort &gt; data, int length)</td></tr>
<tr class="memdesc:a648f1531b9c06928338338d0b868752c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of ushort data to the matrix at the specified indices with a specified length.  <br /></td></tr>
<tr class="separator:a648f1531b9c06928338338d0b868752c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd86b7ed985f2f2a91c685a71efd0f27" id="r_afd86b7ed985f2f2a91c685a71efd0f27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd86b7ed985f2f2a91c685a71efd0f27">put</a> (int[] idx, Span&lt; ushort &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:afd86b7ed985f2f2a91c685a71efd0f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of ushort data to the matrix at the specified indices, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:afd86b7ed985f2f2a91c685a71efd0f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8883bb1a68951a35512bb601897f127" id="r_ab8883bb1a68951a35512bb601897f127"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8883bb1a68951a35512bb601897f127">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; short &gt; data)</td></tr>
<tr class="memdesc:ab8883bb1a68951a35512bb601897f127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of short data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ab8883bb1a68951a35512bb601897f127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c536370f7981b652bc82f63b42f4db" id="r_aa2c536370f7981b652bc82f63b42f4db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c536370f7981b652bc82f63b42f4db">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; short &gt; data, int length)</td></tr>
<tr class="memdesc:aa2c536370f7981b652bc82f63b42f4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of short data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:aa2c536370f7981b652bc82f63b42f4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7779f949bbf3da76e84b0d8bff579e3a" id="r_a7779f949bbf3da76e84b0d8bff579e3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7779f949bbf3da76e84b0d8bff579e3a">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; short &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a7779f949bbf3da76e84b0d8bff579e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of short data to the matrix at the specified row and column, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:a7779f949bbf3da76e84b0d8bff579e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad3142478dff00671b03c7f8ebad5c5" id="r_a5ad3142478dff00671b03c7f8ebad5c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad3142478dff00671b03c7f8ebad5c5">put</a> (int[] idx, Span&lt; short &gt; data)</td></tr>
<tr class="memdesc:a5ad3142478dff00671b03c7f8ebad5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of short data to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a5ad3142478dff00671b03c7f8ebad5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fa1b06e45811cc69b83b28f9eb6b70" id="r_a98fa1b06e45811cc69b83b28f9eb6b70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98fa1b06e45811cc69b83b28f9eb6b70">put</a> (int[] idx, Span&lt; short &gt; data, int length)</td></tr>
<tr class="memdesc:a98fa1b06e45811cc69b83b28f9eb6b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of short data to the matrix at the specified indices with a specified length.  <br /></td></tr>
<tr class="separator:a98fa1b06e45811cc69b83b28f9eb6b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b16bcdcbe70000c0af293d5dd6445ed" id="r_a2b16bcdcbe70000c0af293d5dd6445ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b16bcdcbe70000c0af293d5dd6445ed">put</a> (int[] idx, Span&lt; short &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a2b16bcdcbe70000c0af293d5dd6445ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of short data to the matrix at the specified indices, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:a2b16bcdcbe70000c0af293d5dd6445ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a755175818f61126f880bb01649ed2d" id="r_a7a755175818f61126f880bb01649ed2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a755175818f61126f880bb01649ed2d">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; int &gt; data)</td></tr>
<tr class="memdesc:a7a755175818f61126f880bb01649ed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of int data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a7a755175818f61126f880bb01649ed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c97123db0c4580801810ff1cad84ff" id="r_af2c97123db0c4580801810ff1cad84ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2c97123db0c4580801810ff1cad84ff">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; int &gt; data, int length)</td></tr>
<tr class="memdesc:af2c97123db0c4580801810ff1cad84ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of int data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:af2c97123db0c4580801810ff1cad84ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fb38ae971309f9c23b6429629eeed3" id="r_a17fb38ae971309f9c23b6429629eeed3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17fb38ae971309f9c23b6429629eeed3">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; int &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a17fb38ae971309f9c23b6429629eeed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of int data to the matrix at the specified row and column, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:a17fb38ae971309f9c23b6429629eeed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ec1223720689f3c92a3d4c16967de" id="r_a6e9ec1223720689f3c92a3d4c16967de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e9ec1223720689f3c92a3d4c16967de">put</a> (int[] idx, Span&lt; int &gt; data)</td></tr>
<tr class="memdesc:a6e9ec1223720689f3c92a3d4c16967de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of int data to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a6e9ec1223720689f3c92a3d4c16967de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c0e5a543242cb372829a8f5cb7785e" id="r_a42c0e5a543242cb372829a8f5cb7785e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c0e5a543242cb372829a8f5cb7785e">put</a> (int[] idx, Span&lt; int &gt; data, int length)</td></tr>
<tr class="memdesc:a42c0e5a543242cb372829a8f5cb7785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of int data to the matrix at the specified indices with a specified length.  <br /></td></tr>
<tr class="separator:a42c0e5a543242cb372829a8f5cb7785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f95fb756eae6b1381e5b5e21551994e" id="r_a7f95fb756eae6b1381e5b5e21551994e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f95fb756eae6b1381e5b5e21551994e">put</a> (int[] idx, Span&lt; int &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a7f95fb756eae6b1381e5b5e21551994e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of int data to the matrix at the specified indices, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:a7f95fb756eae6b1381e5b5e21551994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a4ff4910758c2bfd611cdf292cb788" id="r_a28a4ff4910758c2bfd611cdf292cb788"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a4ff4910758c2bfd611cdf292cb788">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; float &gt; data)</td></tr>
<tr class="memdesc:a28a4ff4910758c2bfd611cdf292cb788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of float data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a28a4ff4910758c2bfd611cdf292cb788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15235248bec15b6a4a57a8502f411bda" id="r_a15235248bec15b6a4a57a8502f411bda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15235248bec15b6a4a57a8502f411bda">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; float &gt; data, int length)</td></tr>
<tr class="memdesc:a15235248bec15b6a4a57a8502f411bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of float data to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a15235248bec15b6a4a57a8502f411bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405e7aace3a490b6529035e92570af0" id="r_aa405e7aace3a490b6529035e92570af0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa405e7aace3a490b6529035e92570af0">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; float &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:aa405e7aace3a490b6529035e92570af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of float data to the matrix at the specified row and column, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:aa405e7aace3a490b6529035e92570af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68a9d3a799117a67b33ff74bdc45c8e" id="r_ac68a9d3a799117a67b33ff74bdc45c8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac68a9d3a799117a67b33ff74bdc45c8e">put</a> (int[] idx, Span&lt; float &gt; data)</td></tr>
<tr class="memdesc:ac68a9d3a799117a67b33ff74bdc45c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of float data to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:ac68a9d3a799117a67b33ff74bdc45c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d753cae687adb4eb2d34e0989ed79f" id="r_a03d753cae687adb4eb2d34e0989ed79f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03d753cae687adb4eb2d34e0989ed79f">put</a> (int[] idx, Span&lt; float &gt; data, int length)</td></tr>
<tr class="memdesc:a03d753cae687adb4eb2d34e0989ed79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of float data to the matrix at the specified indices with a specified length.  <br /></td></tr>
<tr class="separator:a03d753cae687adb4eb2d34e0989ed79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698f6ca3d869a7b5b9a7f22328b521c5" id="r_a698f6ca3d869a7b5b9a7f22328b521c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a698f6ca3d869a7b5b9a7f22328b521c5">put</a> (int[] idx, Span&lt; float &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a698f6ca3d869a7b5b9a7f22328b521c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of float data to the matrix at the specified indices, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:a698f6ca3d869a7b5b9a7f22328b521c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6372917b40b6cd21b90e24a83f0f40" id="r_a3b6372917b40b6cd21b90e24a83f0f40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b6372917b40b6cd21b90e24a83f0f40">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; double &gt; data)</td></tr>
<tr class="memdesc:a3b6372917b40b6cd21b90e24a83f0f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of double data to the matrix at the specified row and column, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a3b6372917b40b6cd21b90e24a83f0f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc387c2b834d1616d454b874a8f145dc" id="r_abc387c2b834d1616d454b874a8f145dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc387c2b834d1616d454b874a8f145dc">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; double &gt; data, int length)</td></tr>
<tr class="memdesc:abc387c2b834d1616d454b874a8f145dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of double data to the matrix at the specified row and column, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:abc387c2b834d1616d454b874a8f145dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de2107e69f0ccf3487e4ff2fe5b6403" id="r_a6de2107e69f0ccf3487e4ff2fe5b6403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6de2107e69f0ccf3487e4ff2fe5b6403">put</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; double &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a6de2107e69f0ccf3487e4ff2fe5b6403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of double data to the matrix at the specified row and column, starting from the specified offset within the data array, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a6de2107e69f0ccf3487e4ff2fe5b6403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add99fd4a8b4fd9474714a28a1b6a5a96" id="r_add99fd4a8b4fd9474714a28a1b6a5a96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add99fd4a8b4fd9474714a28a1b6a5a96">put</a> (int[] idx, Span&lt; double &gt; data)</td></tr>
<tr class="memdesc:add99fd4a8b4fd9474714a28a1b6a5a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of double data to the matrix at the specified indices, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:add99fd4a8b4fd9474714a28a1b6a5a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1833cfc7e8d9ed5764fb388645f1805" id="r_ab1833cfc7e8d9ed5764fb388645f1805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1833cfc7e8d9ed5764fb388645f1805">put</a> (int[] idx, Span&lt; double &gt; data, int length)</td></tr>
<tr class="memdesc:ab1833cfc7e8d9ed5764fb388645f1805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of double data to the matrix at the specified indices with a specified length, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:ab1833cfc7e8d9ed5764fb388645f1805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cdb6066f5b97dc0af037f1246121e9" id="r_a82cdb6066f5b97dc0af037f1246121e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82cdb6066f5b97dc0af037f1246121e9">put</a> (int[] idx, Span&lt; double &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a82cdb6066f5b97dc0af037f1246121e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of double data to the matrix at the specified indices, starting from the specified offset within the data span, casting them to match the matrix's data type.  <br /></td></tr>
<tr class="separator:a82cdb6066f5b97dc0af037f1246121e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dbaa076c9bd42a3fc4b8118f8aa168" id="r_a35dbaa076c9bd42a3fc4b8118f8aa168"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35dbaa076c9bd42a3fc4b8118f8aa168">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; byte &gt; data)</td></tr>
<tr class="memdesc:a35dbaa076c9bd42a3fc4b8118f8aa168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of byte data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a35dbaa076c9bd42a3fc4b8118f8aa168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea00f8c8f941aa341f0819a2cc3949f" id="r_a9ea00f8c8f941aa341f0819a2cc3949f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea00f8c8f941aa341f0819a2cc3949f">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; byte &gt; data, int length)</td></tr>
<tr class="memdesc:a9ea00f8c8f941aa341f0819a2cc3949f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of byte data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a9ea00f8c8f941aa341f0819a2cc3949f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778ade749444d758a54c9c285de85a24" id="r_a778ade749444d758a54c9c285de85a24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a778ade749444d758a54c9c285de85a24">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; byte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a778ade749444d758a54c9c285de85a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of byte data from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a778ade749444d758a54c9c285de85a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bdaa9115d473f7eb87ee5a1aa15d6f" id="r_a50bdaa9115d473f7eb87ee5a1aa15d6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50bdaa9115d473f7eb87ee5a1aa15d6f">get</a> (int[] idx, Span&lt; byte &gt; data)</td></tr>
<tr class="memdesc:a50bdaa9115d473f7eb87ee5a1aa15d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of byte data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a50bdaa9115d473f7eb87ee5a1aa15d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385fe8c49502752fe02571b29f13f4fc" id="r_a385fe8c49502752fe02571b29f13f4fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a385fe8c49502752fe02571b29f13f4fc">get</a> (int[] idx, Span&lt; byte &gt; data, int length)</td></tr>
<tr class="memdesc:a385fe8c49502752fe02571b29f13f4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of byte data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a385fe8c49502752fe02571b29f13f4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e94186b979cba9bd4395cb1e2e38ff" id="r_ac9e94186b979cba9bd4395cb1e2e38ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9e94186b979cba9bd4395cb1e2e38ff">get</a> (int[] idx, Span&lt; byte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:ac9e94186b979cba9bd4395cb1e2e38ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of byte data from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:ac9e94186b979cba9bd4395cb1e2e38ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bd7436c8159a19ad40a93ad9c121b7" id="r_ad3bd7436c8159a19ad40a93ad9c121b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3bd7436c8159a19ad40a93ad9c121b7">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; sbyte &gt; data)</td></tr>
<tr class="memdesc:ad3bd7436c8159a19ad40a93ad9c121b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of sbyte data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ad3bd7436c8159a19ad40a93ad9c121b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1be756c29b04a90e97a83f24b1347f2" id="r_ab1be756c29b04a90e97a83f24b1347f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1be756c29b04a90e97a83f24b1347f2">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; sbyte &gt; data, int length)</td></tr>
<tr class="memdesc:ab1be756c29b04a90e97a83f24b1347f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of sbyte data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ab1be756c29b04a90e97a83f24b1347f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadde7837d60533bfb831c85f9239acea" id="r_aadde7837d60533bfb831c85f9239acea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadde7837d60533bfb831c85f9239acea">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; sbyte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:aadde7837d60533bfb831c85f9239acea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of sbyte data from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:aadde7837d60533bfb831c85f9239acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8dc424abae99ff2327cb2f69f93a9a" id="r_a6b8dc424abae99ff2327cb2f69f93a9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b8dc424abae99ff2327cb2f69f93a9a">get</a> (int[] idx, Span&lt; sbyte &gt; data)</td></tr>
<tr class="memdesc:a6b8dc424abae99ff2327cb2f69f93a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of sbyte data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a6b8dc424abae99ff2327cb2f69f93a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7075b85a2156156ef47ba77face30a27" id="r_a7075b85a2156156ef47ba77face30a27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7075b85a2156156ef47ba77face30a27">get</a> (int[] idx, Span&lt; sbyte &gt; data, int length)</td></tr>
<tr class="memdesc:a7075b85a2156156ef47ba77face30a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of sbyte data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a7075b85a2156156ef47ba77face30a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5edd365b68560da90c0cf10e69f6ace" id="r_aa5edd365b68560da90c0cf10e69f6ace"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5edd365b68560da90c0cf10e69f6ace">get</a> (int[] idx, Span&lt; sbyte &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:aa5edd365b68560da90c0cf10e69f6ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of sbyte data from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:aa5edd365b68560da90c0cf10e69f6ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48502f2c6ca9d7c1124c06e321c91ec3" id="r_a48502f2c6ca9d7c1124c06e321c91ec3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48502f2c6ca9d7c1124c06e321c91ec3">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; ushort &gt; data)</td></tr>
<tr class="memdesc:a48502f2c6ca9d7c1124c06e321c91ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of ushort data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a48502f2c6ca9d7c1124c06e321c91ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35f14fa305eb3f159441d4e85b5664c" id="r_ab35f14fa305eb3f159441d4e85b5664c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab35f14fa305eb3f159441d4e85b5664c">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; ushort &gt; data, int length)</td></tr>
<tr class="memdesc:ab35f14fa305eb3f159441d4e85b5664c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of ushort data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ab35f14fa305eb3f159441d4e85b5664c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d9b9f77b9b74879a7c9b9f21ef66ed" id="r_a26d9b9f77b9b74879a7c9b9f21ef66ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26d9b9f77b9b74879a7c9b9f21ef66ed">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; ushort &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a26d9b9f77b9b74879a7c9b9f21ef66ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of ushort data from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a26d9b9f77b9b74879a7c9b9f21ef66ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebd7f8a301ac29f58a138f7f2cc9f36" id="r_a7ebd7f8a301ac29f58a138f7f2cc9f36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ebd7f8a301ac29f58a138f7f2cc9f36">get</a> (int[] idx, Span&lt; ushort &gt; data)</td></tr>
<tr class="memdesc:a7ebd7f8a301ac29f58a138f7f2cc9f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a ushort of byte data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a7ebd7f8a301ac29f58a138f7f2cc9f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5197fb7b64ce19fb57bc376471468b0" id="r_ac5197fb7b64ce19fb57bc376471468b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5197fb7b64ce19fb57bc376471468b0">get</a> (int[] idx, Span&lt; ushort &gt; data, int length)</td></tr>
<tr class="memdesc:ac5197fb7b64ce19fb57bc376471468b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of ushort data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:ac5197fb7b64ce19fb57bc376471468b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ed2b9e97da5538c607cdfff29a31fe" id="r_aa5ed2b9e97da5538c607cdfff29a31fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5ed2b9e97da5538c607cdfff29a31fe">get</a> (int[] idx, Span&lt; ushort &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:aa5ed2b9e97da5538c607cdfff29a31fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of ushort data from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:aa5ed2b9e97da5538c607cdfff29a31fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af305d005e4ea2ce7204d3194db81e9ea" id="r_af305d005e4ea2ce7204d3194db81e9ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af305d005e4ea2ce7204d3194db81e9ea">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; short &gt; data)</td></tr>
<tr class="memdesc:af305d005e4ea2ce7204d3194db81e9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of short data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:af305d005e4ea2ce7204d3194db81e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e81dd8f8e0bad658d6f211d3feb323" id="r_a82e81dd8f8e0bad658d6f211d3feb323"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82e81dd8f8e0bad658d6f211d3feb323">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; short &gt; data, int length)</td></tr>
<tr class="memdesc:a82e81dd8f8e0bad658d6f211d3feb323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of short data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a82e81dd8f8e0bad658d6f211d3feb323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50311598c7ef152f70e62e4b5c5d539a" id="r_a50311598c7ef152f70e62e4b5c5d539a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50311598c7ef152f70e62e4b5c5d539a">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; short &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a50311598c7ef152f70e62e4b5c5d539a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of short data from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a50311598c7ef152f70e62e4b5c5d539a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0c733c11124891aa6e8c8400aa3a7" id="r_aebf0c733c11124891aa6e8c8400aa3a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf0c733c11124891aa6e8c8400aa3a7">get</a> (int[] idx, Span&lt; short &gt; data)</td></tr>
<tr class="memdesc:aebf0c733c11124891aa6e8c8400aa3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of short data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:aebf0c733c11124891aa6e8c8400aa3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ea4de13632edbd2075275c1b2a2d4a" id="r_a33ea4de13632edbd2075275c1b2a2d4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33ea4de13632edbd2075275c1b2a2d4a">get</a> (int[] idx, Span&lt; short &gt; data, int length)</td></tr>
<tr class="memdesc:a33ea4de13632edbd2075275c1b2a2d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of short data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a33ea4de13632edbd2075275c1b2a2d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c65d399e6ba9fba362177d45be44f" id="r_a892c65d399e6ba9fba362177d45be44f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a892c65d399e6ba9fba362177d45be44f">get</a> (int[] idx, Span&lt; short &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a892c65d399e6ba9fba362177d45be44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of short data from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a892c65d399e6ba9fba362177d45be44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a339bf08ab76c2fd713ce8b5440b389" id="r_a5a339bf08ab76c2fd713ce8b5440b389"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a339bf08ab76c2fd713ce8b5440b389">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; int &gt; data)</td></tr>
<tr class="memdesc:a5a339bf08ab76c2fd713ce8b5440b389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of int data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a5a339bf08ab76c2fd713ce8b5440b389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbc9a78b15e8314fb4ee737c00a723e" id="r_abdbc9a78b15e8314fb4ee737c00a723e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdbc9a78b15e8314fb4ee737c00a723e">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; int &gt; data, int length)</td></tr>
<tr class="memdesc:abdbc9a78b15e8314fb4ee737c00a723e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of int data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:abdbc9a78b15e8314fb4ee737c00a723e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f73bc59134c3a8c4a73ce3ddd9d813" id="r_ab8f73bc59134c3a8c4a73ce3ddd9d813"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8f73bc59134c3a8c4a73ce3ddd9d813">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; int &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:ab8f73bc59134c3a8c4a73ce3ddd9d813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of int data from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:ab8f73bc59134c3a8c4a73ce3ddd9d813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329a4152e63d2b055afe483152def776" id="r_a329a4152e63d2b055afe483152def776"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a329a4152e63d2b055afe483152def776">get</a> (int[] idx, Span&lt; int &gt; data)</td></tr>
<tr class="memdesc:a329a4152e63d2b055afe483152def776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of int data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a329a4152e63d2b055afe483152def776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad598cb3f51e92d610a9757a0f48bead5" id="r_ad598cb3f51e92d610a9757a0f48bead5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad598cb3f51e92d610a9757a0f48bead5">get</a> (int[] idx, Span&lt; int &gt; data, int length)</td></tr>
<tr class="memdesc:ad598cb3f51e92d610a9757a0f48bead5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of int data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:ad598cb3f51e92d610a9757a0f48bead5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b444804d4fd60d0419a5baede8c1d2" id="r_a33b444804d4fd60d0419a5baede8c1d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33b444804d4fd60d0419a5baede8c1d2">get</a> (int[] idx, Span&lt; int &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a33b444804d4fd60d0419a5baede8c1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of int data from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a33b444804d4fd60d0419a5baede8c1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c4e2095af5786229c6546fd6f6e11e" id="r_a02c4e2095af5786229c6546fd6f6e11e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02c4e2095af5786229c6546fd6f6e11e">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; float &gt; data)</td></tr>
<tr class="memdesc:a02c4e2095af5786229c6546fd6f6e11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of float data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a02c4e2095af5786229c6546fd6f6e11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d0087ad364897bc05b74568aad18a" id="r_a188d0087ad364897bc05b74568aad18a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188d0087ad364897bc05b74568aad18a">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; float &gt; data, int length)</td></tr>
<tr class="memdesc:a188d0087ad364897bc05b74568aad18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of float data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a188d0087ad364897bc05b74568aad18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab4bb07fa1bdecfbaa84fb58d6fbcb0" id="r_a5ab4bb07fa1bdecfbaa84fb58d6fbcb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ab4bb07fa1bdecfbaa84fb58d6fbcb0">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; float &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a5ab4bb07fa1bdecfbaa84fb58d6fbcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of float data from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a5ab4bb07fa1bdecfbaa84fb58d6fbcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af408c95056fa314b4e58e0ae719c0594" id="r_af408c95056fa314b4e58e0ae719c0594"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af408c95056fa314b4e58e0ae719c0594">get</a> (int[] idx, Span&lt; float &gt; data)</td></tr>
<tr class="memdesc:af408c95056fa314b4e58e0ae719c0594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of float data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:af408c95056fa314b4e58e0ae719c0594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351e80c10592fc5032827367fcc23b9d" id="r_a351e80c10592fc5032827367fcc23b9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a351e80c10592fc5032827367fcc23b9d">get</a> (int[] idx, Span&lt; float &gt; data, int length)</td></tr>
<tr class="memdesc:a351e80c10592fc5032827367fcc23b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of float data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a351e80c10592fc5032827367fcc23b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaa83bdb315b4fd0c36b54433ecf9ca" id="r_a6aaa83bdb315b4fd0c36b54433ecf9ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aaa83bdb315b4fd0c36b54433ecf9ca">get</a> (int[] idx, Span&lt; float &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a6aaa83bdb315b4fd0c36b54433ecf9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of float data from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a6aaa83bdb315b4fd0c36b54433ecf9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c2e7b0ec02fbc6446df221ea808330" id="r_ab1c2e7b0ec02fbc6446df221ea808330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1c2e7b0ec02fbc6446df221ea808330">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; double &gt; data)</td></tr>
<tr class="memdesc:ab1c2e7b0ec02fbc6446df221ea808330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of double data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ab1c2e7b0ec02fbc6446df221ea808330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6534eb1e415c7324e52ab852960f5a0" id="r_ad6534eb1e415c7324e52ab852960f5a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6534eb1e415c7324e52ab852960f5a0">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; double &gt; data, int length)</td></tr>
<tr class="memdesc:ad6534eb1e415c7324e52ab852960f5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of double data from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:ad6534eb1e415c7324e52ab852960f5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc5fc29237c6c9fa4d9255d75a1974f" id="r_a8cc5fc29237c6c9fa4d9255d75a1974f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cc5fc29237c6c9fa4d9255d75a1974f">get</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; double &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a8cc5fc29237c6c9fa4d9255d75a1974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of double data from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a8cc5fc29237c6c9fa4d9255d75a1974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a418bff105e44fd78c91bfc6e54cf07" id="r_a5a418bff105e44fd78c91bfc6e54cf07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a418bff105e44fd78c91bfc6e54cf07">get</a> (int[] idx, Span&lt; double &gt; data)</td></tr>
<tr class="memdesc:a5a418bff105e44fd78c91bfc6e54cf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of double data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a5a418bff105e44fd78c91bfc6e54cf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b33328dada72c3c81c393bbb2264b1" id="r_a20b33328dada72c3c81c393bbb2264b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b33328dada72c3c81c393bbb2264b1">get</a> (int[] idx, Span&lt; double &gt; data, int length)</td></tr>
<tr class="memdesc:a20b33328dada72c3c81c393bbb2264b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of double data from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a20b33328dada72c3c81c393bbb2264b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a2617f5d2aea4398d079d8a3ba314f" id="r_a32a2617f5d2aea4398d079d8a3ba314f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32a2617f5d2aea4398d079d8a3ba314f">get</a> (int[] idx, Span&lt; double &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a32a2617f5d2aea4398d079d8a3ba314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of double data from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a32a2617f5d2aea4398d079d8a3ba314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3f76992056753813d3dc8eee761f2b" id="r_abd3f76992056753813d3dc8eee761f2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd3f76992056753813d3dc8eee761f2b">put&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, T[] data)</td></tr>
<tr class="memdesc:abd3f76992056753813d3dc8eee761f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of type <em>T</em>  to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:abd3f76992056753813d3dc8eee761f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126fd9e18f2aac899c766a213fea56b1" id="r_a126fd9e18f2aac899c766a213fea56b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a126fd9e18f2aac899c766a213fea56b1">put&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, T[] data, int length)</td></tr>
<tr class="memdesc:a126fd9e18f2aac899c766a213fea56b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of type <em>T</em>  to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a126fd9e18f2aac899c766a213fea56b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb61a0d7dcc4e6a0b7020777439ca42" id="r_abbb61a0d7dcc4e6a0b7020777439ca42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbb61a0d7dcc4e6a0b7020777439ca42">put&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, T[] data, int offset, int length)</td></tr>
<tr class="memdesc:abbb61a0d7dcc4e6a0b7020777439ca42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of type <em>T</em>  to the matrix at the specified row and column, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:abbb61a0d7dcc4e6a0b7020777439ca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1bea47833afc5a89791a4c11e29e25" id="r_aaa1bea47833afc5a89791a4c11e29e25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa1bea47833afc5a89791a4c11e29e25">put&lt; T &gt;</a> (int[] idx, T[] data)</td></tr>
<tr class="memdesc:aaa1bea47833afc5a89791a4c11e29e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of type <em>T</em>  to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:aaa1bea47833afc5a89791a4c11e29e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f3018291ff94083b1ce03235be36f2" id="r_a10f3018291ff94083b1ce03235be36f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10f3018291ff94083b1ce03235be36f2">put&lt; T &gt;</a> (int[] idx, T[] data, int length)</td></tr>
<tr class="memdesc:a10f3018291ff94083b1ce03235be36f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of type <em>T</em>  to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a10f3018291ff94083b1ce03235be36f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7e469a1e61374e4c99515080e5edf" id="r_adcc7e469a1e61374e4c99515080e5edf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc7e469a1e61374e4c99515080e5edf">put&lt; T &gt;</a> (int[] idx, T[] data, int offset, int length)</td></tr>
<tr class="memdesc:adcc7e469a1e61374e4c99515080e5edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of type <em>T</em>  to the matrix at the specified indices, starting from the specified offset within the data array.  <br /></td></tr>
<tr class="separator:adcc7e469a1e61374e4c99515080e5edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacab7753a08f5e1ad53a4acaf1a10ceb" id="r_aacab7753a08f5e1ad53a4acaf1a10ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacab7753a08f5e1ad53a4acaf1a10ceb">get&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, T[] data)</td></tr>
<tr class="memdesc:aacab7753a08f5e1ad53a4acaf1a10ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of type <em>T</em>  from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:aacab7753a08f5e1ad53a4acaf1a10ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0925f2fadf976710c94156a974f638" id="r_aec0925f2fadf976710c94156a974f638"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec0925f2fadf976710c94156a974f638">get&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, T[] data, int length)</td></tr>
<tr class="memdesc:aec0925f2fadf976710c94156a974f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of type <em>T</em>  from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:aec0925f2fadf976710c94156a974f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e7b7cd4732b79479f70d2523b3392a" id="r_a92e7b7cd4732b79479f70d2523b3392a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92e7b7cd4732b79479f70d2523b3392a">get&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, T[] data, int offset, int length)</td></tr>
<tr class="memdesc:a92e7b7cd4732b79479f70d2523b3392a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of type <em>T</em>  from the matrix at the specified row and column, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:a92e7b7cd4732b79479f70d2523b3392a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172101b25e8a47891b164213c9c7b6be" id="r_a172101b25e8a47891b164213c9c7b6be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a172101b25e8a47891b164213c9c7b6be">get&lt; T &gt;</a> (int[] idx, T[] data)</td></tr>
<tr class="memdesc:a172101b25e8a47891b164213c9c7b6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of type <em>T</em>  from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a172101b25e8a47891b164213c9c7b6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2659dc2a31e84631761bc31a17b50e9" id="r_ac2659dc2a31e84631761bc31a17b50e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2659dc2a31e84631761bc31a17b50e9">get&lt; T &gt;</a> (int[] idx, T[] data, int length)</td></tr>
<tr class="memdesc:ac2659dc2a31e84631761bc31a17b50e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of type <em>T</em>  from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:ac2659dc2a31e84631761bc31a17b50e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f224dd682b161f070f253110407449" id="r_ad8f224dd682b161f070f253110407449"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8f224dd682b161f070f253110407449">get&lt; T &gt;</a> (int[] idx, T[] data, int offset, int length)</td></tr>
<tr class="memdesc:ad8f224dd682b161f070f253110407449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of type <em>T</em>  from the matrix at the specified indices, storing them in the data array starting at the specified offset.  <br /></td></tr>
<tr class="separator:ad8f224dd682b161f070f253110407449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e13da2541074e28aae11c1c6848ffc" id="r_a99e13da2541074e28aae11c1c6848ffc"><td class="memItemLeft" align="right" valign="top">T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99e13da2541074e28aae11c1c6848ffc">get&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>)</td></tr>
<tr class="memdesc:a99e13da2541074e28aae11c1c6848ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the element values from the matrix at the specified row and column, returning them as an array of type <em>T</em> .  <br /></td></tr>
<tr class="separator:a99e13da2541074e28aae11c1c6848ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bd50ab046b9ecdac46da8684091ce0" id="r_a62bd50ab046b9ecdac46da8684091ce0"><td class="memItemLeft" align="right" valign="top">T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62bd50ab046b9ecdac46da8684091ce0">get&lt; T &gt;</a> (int[] idx)</td></tr>
<tr class="memdesc:a62bd50ab046b9ecdac46da8684091ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the element values from the matrix at the specified indices, returning them as an array of type <em>T</em> .  <br /></td></tr>
<tr class="separator:a62bd50ab046b9ecdac46da8684091ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfadb4e5cf544d0ddf5fd7d0812c4957" id="r_adfadb4e5cf544d0ddf5fd7d0812c4957"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfadb4e5cf544d0ddf5fd7d0812c4957">put&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; T &gt; data)</td></tr>
<tr class="memdesc:adfadb4e5cf544d0ddf5fd7d0812c4957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of type <em>T</em>  to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:adfadb4e5cf544d0ddf5fd7d0812c4957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb6e2df44000fbd0ede92a60db8e120" id="r_aeeb6e2df44000fbd0ede92a60db8e120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeb6e2df44000fbd0ede92a60db8e120">put&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; T &gt; data, int length)</td></tr>
<tr class="memdesc:aeeb6e2df44000fbd0ede92a60db8e120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of type <em>T</em>  to the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:aeeb6e2df44000fbd0ede92a60db8e120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f484c619d8399d1b1de59bae102933" id="r_aa6f484c619d8399d1b1de59bae102933"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6f484c619d8399d1b1de59bae102933">put&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; T &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:aa6f484c619d8399d1b1de59bae102933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of type <em>T</em>  to the matrix at the specified row and column, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:aa6f484c619d8399d1b1de59bae102933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4790a0a803cc0912650ea64c7658d8" id="r_a1a4790a0a803cc0912650ea64c7658d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4790a0a803cc0912650ea64c7658d8">put&lt; T &gt;</a> (int[] idx, Span&lt; T &gt; data)</td></tr>
<tr class="memdesc:a1a4790a0a803cc0912650ea64c7658d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of type <em>T</em>  to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a1a4790a0a803cc0912650ea64c7658d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712b0311ea2e60a653b5c6df70fa682c" id="r_a712b0311ea2e60a653b5c6df70fa682c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a712b0311ea2e60a653b5c6df70fa682c">put&lt; T &gt;</a> (int[] idx, Span&lt; T &gt; data, int length)</td></tr>
<tr class="memdesc:a712b0311ea2e60a653b5c6df70fa682c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of type <em>T</em>  to the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a712b0311ea2e60a653b5c6df70fa682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d4549bbe0af7d6e16e43beb769c1bd" id="r_aa0d4549bbe0af7d6e16e43beb769c1bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d4549bbe0af7d6e16e43beb769c1bd">put&lt; T &gt;</a> (int[] idx, Span&lt; T &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:aa0d4549bbe0af7d6e16e43beb769c1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a span of type <em>T</em>  to the matrix at the specified indices, starting from the specified offset within the data span.  <br /></td></tr>
<tr class="separator:aa0d4549bbe0af7d6e16e43beb769c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc224d583b618dcda2524b4fc66ce9" id="r_a07cc224d583b618dcda2524b4fc66ce9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07cc224d583b618dcda2524b4fc66ce9">get&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; T &gt; data)</td></tr>
<tr class="memdesc:a07cc224d583b618dcda2524b4fc66ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of type <em>T</em>  from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:a07cc224d583b618dcda2524b4fc66ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed20f59737a1e296ba16f08ff0c74bc" id="r_abed20f59737a1e296ba16f08ff0c74bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abed20f59737a1e296ba16f08ff0c74bc">get&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; T &gt; data, int length)</td></tr>
<tr class="memdesc:abed20f59737a1e296ba16f08ff0c74bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of type <em>T</em>  from the matrix at the specified row and column.  <br /></td></tr>
<tr class="separator:abed20f59737a1e296ba16f08ff0c74bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181d24766a61e71f2577e9ab95e7044" id="r_ab181d24766a61e71f2577e9ab95e7044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab181d24766a61e71f2577e9ab95e7044">get&lt; T &gt;</a> (int <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>, int <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86">col</a>, Span&lt; T &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:ab181d24766a61e71f2577e9ab95e7044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of type <em>T</em>  from the matrix at the specified row and column, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:ab181d24766a61e71f2577e9ab95e7044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d20fe8a15c16cd9cd04e6cb9fd8885" id="r_a61d20fe8a15c16cd9cd04e6cb9fd8885"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61d20fe8a15c16cd9cd04e6cb9fd8885">get&lt; T &gt;</a> (int[] idx, Span&lt; T &gt; data)</td></tr>
<tr class="memdesc:a61d20fe8a15c16cd9cd04e6cb9fd8885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of type <em>T</em>  from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a61d20fe8a15c16cd9cd04e6cb9fd8885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7579fc79f66980a6cc1834f4603ea211" id="r_a7579fc79f66980a6cc1834f4603ea211"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7579fc79f66980a6cc1834f4603ea211">get&lt; T &gt;</a> (int[] idx, Span&lt; T &gt; data, int length)</td></tr>
<tr class="memdesc:a7579fc79f66980a6cc1834f4603ea211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of type <em>T</em>  from the matrix at the specified indices.  <br /></td></tr>
<tr class="separator:a7579fc79f66980a6cc1834f4603ea211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b677f00e590dddc94d7620aa225c1f8" id="r_a1b677f00e590dddc94d7620aa225c1f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b677f00e590dddc94d7620aa225c1f8">get&lt; T &gt;</a> (int[] idx, Span&lt; T &gt; data, int offset, int length)</td></tr>
<tr class="memdesc:a1b677f00e590dddc94d7620aa225c1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a span of type <em>T</em>  from the matrix at the specified indices, storing them in the data span starting at the specified offset.  <br /></td></tr>
<tr class="separator:a1b677f00e590dddc94d7620aa225c1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ff27d3859fb5f6ce1670245f9506af" id="r_a29ff27d3859fb5f6ce1670245f9506af"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29ff27d3859fb5f6ce1670245f9506af">ptr</a> (int i0)</td></tr>
<tr class="memdesc:a29ff27d3859fb5f6ce1670245f9506af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the specified row of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:a29ff27d3859fb5f6ce1670245f9506af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ca48c0e8bdbf6fa6daec4820b50bbc" id="r_a05ca48c0e8bdbf6fa6daec4820b50bbc"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ca48c0e8bdbf6fa6daec4820b50bbc">ptr</a> (int i0, int i1)</td></tr>
<tr class="memdesc:a05ca48c0e8bdbf6fa6daec4820b50bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the specified row and column of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:a05ca48c0e8bdbf6fa6daec4820b50bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043ada76d46721035aa0acfc91e873be" id="r_a043ada76d46721035aa0acfc91e873be"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a043ada76d46721035aa0acfc91e873be">ptr</a> (int i0, int i1, int i2)</td></tr>
<tr class="memdesc:a043ada76d46721035aa0acfc91e873be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the specified element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object based on the given row, column, and third dimension indices.  <br /></td></tr>
<tr class="separator:a043ada76d46721035aa0acfc91e873be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd23f70bc6de11173882e6b1953d470" id="r_addd23f70bc6de11173882e6b1953d470"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addd23f70bc6de11173882e6b1953d470">ptr</a> (params int[] idx)</td></tr>
<tr class="memdesc:addd23f70bc6de11173882e6b1953d470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the specified element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object based on the provided indices for each dimension.  <br /></td></tr>
<tr class="separator:addd23f70bc6de11173882e6b1953d470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0ae29f91684bda74ebfbea65062efd" id="r_abf0ae29f91684bda74ebfbea65062efd"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf0ae29f91684bda74ebfbea65062efd">at&lt; T &gt;</a> (int i0)</td></tr>
<tr class="memdesc:abf0ae29f91684bda74ebfbea65062efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the first element in the specified row of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:abf0ae29f91684bda74ebfbea65062efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15b7cab767a3bb3ae65a8da84cb94f7" id="r_ae15b7cab767a3bb3ae65a8da84cb94f7"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae15b7cab767a3bb3ae65a8da84cb94f7">at&lt; T &gt;</a> (int i0, int i1)</td></tr>
<tr class="memdesc:ae15b7cab767a3bb3ae65a8da84cb94f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the first element in the specified row and column of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:ae15b7cab767a3bb3ae65a8da84cb94f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4188d33d455cb82110c3a61c2d83e8db" id="r_a4188d33d455cb82110c3a61c2d83e8db"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4188d33d455cb82110c3a61c2d83e8db">at&lt; T &gt;</a> (int i0, int i1, int i2)</td></tr>
<tr class="memdesc:a4188d33d455cb82110c3a61c2d83e8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the first element in the specified row, column, and third dimension of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:a4188d33d455cb82110c3a61c2d83e8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82abaad45b89619bffabec5b762804b6" id="r_a82abaad45b89619bffabec5b762804b6"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82abaad45b89619bffabec5b762804b6">at&lt; T &gt;</a> (params int[] idx)</td></tr>
<tr class="memdesc:a82abaad45b89619bffabec5b762804b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the first element in the specified coordinates of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:a82abaad45b89619bffabec5b762804b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769ba322b0e8e527819fa2c7727fb3f" id="r_ad769ba322b0e8e527819fa2c7727fb3f"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad769ba322b0e8e527819fa2c7727fb3f">AsSpan&lt; T &gt;</a> ()</td></tr>
<tr class="memdesc:ad769ba322b0e8e527819fa2c7727fb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span%3CT%3E representing the entire data of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:ad769ba322b0e8e527819fa2c7727fb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81ebf833a4fbe4330cff20b9249ea39" id="r_ab81ebf833a4fbe4330cff20b9249ea39"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81ebf833a4fbe4330cff20b9249ea39">AsSpan&lt; T &gt;</a> (int i0)</td></tr>
<tr class="memdesc:ab81ebf833a4fbe4330cff20b9249ea39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the data in the specified row or dimension of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:ab81ebf833a4fbe4330cff20b9249ea39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a154ea4c2bc4a63c0eff85f21e4d96" id="r_af0a154ea4c2bc4a63c0eff85f21e4d96"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a154ea4c2bc4a63c0eff85f21e4d96">AsSpan&lt; T &gt;</a> (int i0, int i1)</td></tr>
<tr class="memdesc:af0a154ea4c2bc4a63c0eff85f21e4d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the data at the specified row and column, or dimensions, of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:af0a154ea4c2bc4a63c0eff85f21e4d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4a1d9795159d5c9f8c1b6ba1191ba1" id="r_a5c4a1d9795159d5c9f8c1b6ba1191ba1"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c4a1d9795159d5c9f8c1b6ba1191ba1">AsSpan&lt; T &gt;</a> (int i0, int i1, int i2)</td></tr>
<tr class="memdesc:a5c4a1d9795159d5c9f8c1b6ba1191ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the data at the specified element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, starting from the given three-dimensional indices.  <br /></td></tr>
<tr class="separator:a5c4a1d9795159d5c9f8c1b6ba1191ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8154aa3831f9f3592ca50908d3f72694" id="r_a8154aa3831f9f3592ca50908d3f72694"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8154aa3831f9f3592ca50908d3f72694">AsSpan&lt; T &gt;</a> (params int[] idx)</td></tr>
<tr class="memdesc:a8154aa3831f9f3592ca50908d3f72694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the data at the specified element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object based on a variable number of indices.  <br /></td></tr>
<tr class="separator:a8154aa3831f9f3592ca50908d3f72694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d195ed579c066bc9e38968f626cfed" id="r_ac6d195ed579c066bc9e38968f626cfed"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6d195ed579c066bc9e38968f626cfed">AsSpanRowRange&lt; T &gt;</a> (int startrow, int endrow)</td></tr>
<tr class="memdesc:ac6d195ed579c066bc9e38968f626cfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing the data in the specified range of rows in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object.  <br /></td></tr>
<tr class="separator:ac6d195ed579c066bc9e38968f626cfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada857d5a5dda4c5d0159c0611f8cdfbe" id="r_ada857d5a5dda4c5d0159c0611f8cdfbe"><td class="memItemLeft" align="right" valign="top">Span&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada857d5a5dda4c5d0159c0611f8cdfbe">AsSpanRowRange&lt; T &gt;</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a> r)</td></tr>
<tr class="memdesc:ada857d5a5dda4c5d0159c0611f8cdfbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a Span&lt;T&gt; representing a range of rows from the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, defined by the specified <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a>.  <br /></td></tr>
<tr class="separator:ada857d5a5dda4c5d0159c0611f8cdfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e87ea6ffeada43e8176d9ee9d54f50f" id="r_a3e87ea6ffeada43e8176d9ee9d54f50f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e87ea6ffeada43e8176d9ee9d54f50f">Mat</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="separator:a3e87ea6ffeada43e8176d9ee9d54f50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2a5f199bdb589d20c07a3622957141" id="r_a6b2a5f199bdb589d20c07a3622957141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2a5f199bdb589d20c07a3622957141">Mat</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a> s)</td></tr>
<tr class="separator:a6b2a5f199bdb589d20c07a3622957141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53408a375a782f3cf8c1eb59d7a3ebdb" id="r_a53408a375a782f3cf8c1eb59d7a3ebdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53408a375a782f3cf8c1eb59d7a3ebdb">Mat</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a> s)</td></tr>
<tr class="separator:a53408a375a782f3cf8c1eb59d7a3ebdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452099cb1fc51c0be1d7bd3e64a9dafd" id="r_a452099cb1fc51c0be1d7bd3e64a9dafd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a452099cb1fc51c0be1d7bd3e64a9dafd">Mat</a> (int[] sizes, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a> s)</td></tr>
<tr class="separator:a452099cb1fc51c0be1d7bd3e64a9dafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5658892082d60396f7ef15b38a1ac428" id="r_a5658892082d60396f7ef15b38a1ac428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5658892082d60396f7ef15b38a1ac428">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a> <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a> <a class="el" href="#ab0ebb50b3a9213bad850944413013a90">colRange</a>)</td></tr>
<tr class="separator:a5658892082d60396f7ef15b38a1ac428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ddf594c901042df19f95e53ab8794b" id="r_a91ddf594c901042df19f95e53ab8794b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ddf594c901042df19f95e53ab8794b">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a> <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>)</td></tr>
<tr class="separator:a91ddf594c901042df19f95e53ab8794b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddb29d271595684e5d24ea2fd22f8ad" id="r_a2ddb29d271595684e5d24ea2fd22f8ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ddb29d271595684e5d24ea2fd22f8ad">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a>[] ranges)</td></tr>
<tr class="separator:a2ddb29d271595684e5d24ea2fd22f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4e99f8704b65d358af84ad4192f5b2" id="r_aee4e99f8704b65d358af84ad4192f5b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee4e99f8704b65d358af84ad4192f5b2">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4i.html">Vec4i</a> roi)</td></tr>
<tr class="separator:aee4e99f8704b65d358af84ad4192f5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dd958e823563bdff09c135000d9fb9" id="r_ac6dd958e823563bdff09c135000d9fb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6dd958e823563bdff09c135000d9fb9">Mat</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, IntPtr data, long step=<a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a>)</td></tr>
<tr class="separator:ac6dd958e823563bdff09c135000d9fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d51a7584b20dbcac11949f0540f9f8" id="r_af3d51a7584b20dbcac11949f0540f9f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3d51a7584b20dbcac11949f0540f9f8">colRange</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a> r)</td></tr>
<tr class="memdesc:af3d51a7584b20dbcac11949f0540f9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified column span.  <br /></td></tr>
<tr class="separator:af3d51a7584b20dbcac11949f0540f9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bc90c913081151e338dfc1b3d4b0f7" id="r_a49bc90c913081151e338dfc1b3d4b0f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49bc90c913081151e338dfc1b3d4b0f7">create</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a49bc90c913081151e338dfc1b3d4b0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates new array data if needed.  <br /></td></tr>
<tr class="separator:a49bc90c913081151e338dfc1b3d4b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7c585ef7e25c7867c76bdb1eff883a" id="r_a0a7c585ef7e25c7867c76bdb1eff883a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a7c585ef7e25c7867c76bdb1eff883a">locateROI</a> (out <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> wholeSize, out <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> ofs)</td></tr>
<tr class="memdesc:a0a7c585ef7e25c7867c76bdb1eff883a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the matrix header within a parent matrix.  <br /></td></tr>
<tr class="separator:a0a7c585ef7e25c7867c76bdb1eff883a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5d7d7e581010f0d65684c417ce3787" id="r_a9f5d7d7e581010f0d65684c417ce3787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f5d7d7e581010f0d65684c417ce3787">rowRange</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a> r)</td></tr>
<tr class="memdesc:a9f5d7d7e581010f0d65684c417ce3787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified row span.  <br /></td></tr>
<tr class="separator:a9f5d7d7e581010f0d65684c417ce3787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f11b681d473739b68617b63dc56dd" id="r_a1d3f11b681d473739b68617b63dc56dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d3f11b681d473739b68617b63dc56dd">setTo</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a> s)</td></tr>
<tr class="memdesc:a1d3f11b681d473739b68617b63dc56dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:a1d3f11b681d473739b68617b63dc56dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1452b509297dca05f465f611c1425436" id="r_a1452b509297dca05f465f611c1425436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1452b509297dca05f465f611c1425436">setTo</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a> value, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="memdesc:a1452b509297dca05f465f611c1425436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:a1452b509297dca05f465f611c1425436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310afd4ff744ff488066b972403b90cd" id="r_a310afd4ff744ff488066b972403b90cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a310afd4ff744ff488066b972403b90cd">sizeAsVec2d</a> ()</td></tr>
<tr class="separator:a310afd4ff744ff488066b972403b90cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71af73d3b035f9cf935e762604f63f20" id="r_a71af73d3b035f9cf935e762604f63f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71af73d3b035f9cf935e762604f63f20">submat</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a> <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>, in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a> <a class="el" href="#ab0ebb50b3a9213bad850944413013a90">colRange</a>)</td></tr>
<tr class="memdesc:a71af73d3b035f9cf935e762604f63f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:a71af73d3b035f9cf935e762604f63f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dd57838fcea7c87e4021dc8141695e" id="r_a61dd57838fcea7c87e4021dc8141695e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61dd57838fcea7c87e4021dc8141695e">submat</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a>[] ranges)</td></tr>
<tr class="memdesc:a61dd57838fcea7c87e4021dc8141695e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:a61dd57838fcea7c87e4021dc8141695e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d23c9833db2eaabdceacf7a40e5a68" id="r_af7d23c9833db2eaabdceacf7a40e5a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7d23c9833db2eaabdceacf7a40e5a68">submat</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4i.html">Vec4i</a> roi)</td></tr>
<tr class="memdesc:af7d23c9833db2eaabdceacf7a40e5a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:af7d23c9833db2eaabdceacf7a40e5a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7cf1241d063e226bfdb8522ae3aea" id="r_ad7d7cf1241d063e226bfdb8522ae3aea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7d7cf1241d063e226bfdb8522ae3aea">Mat</a> (in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="separator:ad7d7cf1241d063e226bfdb8522ae3aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef6eecf14439869a0cf6fe1fd22ba07" id="r_afef6eecf14439869a0cf6fe1fd22ba07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afef6eecf14439869a0cf6fe1fd22ba07">Mat</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, in(double v0, double v1, double v2, double v3) s)</td></tr>
<tr class="separator:afef6eecf14439869a0cf6fe1fd22ba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14be477225b4710e66bf325bcbf9eb2b" id="r_a14be477225b4710e66bf325bcbf9eb2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14be477225b4710e66bf325bcbf9eb2b">Mat</a> (in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, in(double v0, double v1, double v2, double v3) s)</td></tr>
<tr class="separator:a14be477225b4710e66bf325bcbf9eb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adb464ae5cd20742485d423609d7131" id="r_a3adb464ae5cd20742485d423609d7131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3adb464ae5cd20742485d423609d7131">Mat</a> (int[] sizes, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, in(double v0, double v1, double v2, double v3) s)</td></tr>
<tr class="separator:a3adb464ae5cd20742485d423609d7131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dd8494568c1e1b2f23b4c19c5c4b9f" id="r_a72dd8494568c1e1b2f23b4c19c5c4b9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72dd8494568c1e1b2f23b4c19c5c4b9f">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in(int start, int end) <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>, in(int start, int end) <a class="el" href="#ab0ebb50b3a9213bad850944413013a90">colRange</a>)</td></tr>
<tr class="separator:a72dd8494568c1e1b2f23b4c19c5c4b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb571de477091ec1f6960f3fdeed4b15" id="r_acb571de477091ec1f6960f3fdeed4b15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb571de477091ec1f6960f3fdeed4b15">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in(int start, int end) <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>)</td></tr>
<tr class="separator:acb571de477091ec1f6960f3fdeed4b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f84c58335f367f16ed3f22de52c98a" id="r_a18f84c58335f367f16ed3f22de52c98a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18f84c58335f367f16ed3f22de52c98a">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in(int start, int end)[] ranges)</td></tr>
<tr class="separator:a18f84c58335f367f16ed3f22de52c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a9b06fb739f3e90ab4be8551bc0f41" id="r_ab2a9b06fb739f3e90ab4be8551bc0f41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2a9b06fb739f3e90ab4be8551bc0f41">Mat</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m, in(int x, int y, int <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, int <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) roi)</td></tr>
<tr class="separator:ab2a9b06fb739f3e90ab4be8551bc0f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01c41f91863417374277f0c9d431a97" id="r_ad01c41f91863417374277f0c9d431a97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad01c41f91863417374277f0c9d431a97">Mat</a> (in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>, IntPtr data, long step=<a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a>)</td></tr>
<tr class="separator:ad01c41f91863417374277f0c9d431a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3619e6f5d94467149f4cff25f2f95ad" id="r_ae3619e6f5d94467149f4cff25f2f95ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3619e6f5d94467149f4cff25f2f95ad">colRange</a> (in(int start, int end) r)</td></tr>
<tr class="memdesc:ae3619e6f5d94467149f4cff25f2f95ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified column span.  <br /></td></tr>
<tr class="separator:ae3619e6f5d94467149f4cff25f2f95ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6313a0050006863c58044802f2acb683" id="r_a6313a0050006863c58044802f2acb683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6313a0050006863c58044802f2acb683">create</a> (in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a6313a0050006863c58044802f2acb683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates new array data if needed.  <br /></td></tr>
<tr class="separator:a6313a0050006863c58044802f2acb683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8a0cc9ac24666fa83e4475e5cfbaca" id="r_adb8a0cc9ac24666fa83e4475e5cfbaca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb8a0cc9ac24666fa83e4475e5cfbaca">locateROI</a> (out(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) wholeSize, out(double x, double y) ofs)</td></tr>
<tr class="memdesc:adb8a0cc9ac24666fa83e4475e5cfbaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the matrix header within a parent matrix.  <br /></td></tr>
<tr class="separator:adb8a0cc9ac24666fa83e4475e5cfbaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2fe9e9b0b54ac6163baf6ca13cc982" id="r_a6e2fe9e9b0b54ac6163baf6ca13cc982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2fe9e9b0b54ac6163baf6ca13cc982">rowRange</a> (in(int start, int end) r)</td></tr>
<tr class="memdesc:a6e2fe9e9b0b54ac6163baf6ca13cc982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix header for the specified row span.  <br /></td></tr>
<tr class="separator:a6e2fe9e9b0b54ac6163baf6ca13cc982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab196de2dc7dd6f6bbb05215c7af684f5" id="r_ab196de2dc7dd6f6bbb05215c7af684f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab196de2dc7dd6f6bbb05215c7af684f5">setTo</a> (in(double v0, double v1, double v2, double v3) s)</td></tr>
<tr class="memdesc:ab196de2dc7dd6f6bbb05215c7af684f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:ab196de2dc7dd6f6bbb05215c7af684f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef63f701bcf60dc6a28251ac4cb6015" id="r_aeef63f701bcf60dc6a28251ac4cb6015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeef63f701bcf60dc6a28251ac4cb6015">setTo</a> (in(double v0, double v1, double v2, double v3) value, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> mask)</td></tr>
<tr class="memdesc:aeef63f701bcf60dc6a28251ac4cb6015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specified value.  <br /></td></tr>
<tr class="separator:aeef63f701bcf60dc6a28251ac4cb6015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c11d62ff655b5786f29ac391dc7d50" id="r_a20c11d62ff655b5786f29ac391dc7d50"><td class="memItemLeft" align="right" valign="top">double double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c11d62ff655b5786f29ac391dc7d50">sizeAsValueTuple</a> ()</td></tr>
<tr class="separator:a20c11d62ff655b5786f29ac391dc7d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffd8efb759c40098f239563a93c1b88" id="r_afffd8efb759c40098f239563a93c1b88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afffd8efb759c40098f239563a93c1b88">submat</a> (in(int start, int end) <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>, in(int start, int end) <a class="el" href="#ab0ebb50b3a9213bad850944413013a90">colRange</a>)</td></tr>
<tr class="memdesc:afffd8efb759c40098f239563a93c1b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:afffd8efb759c40098f239563a93c1b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59918f042f0a5248eb72dab9a45c0f50" id="r_a59918f042f0a5248eb72dab9a45c0f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59918f042f0a5248eb72dab9a45c0f50">submat</a> (in(int start, int end)[] ranges)</td></tr>
<tr class="memdesc:a59918f042f0a5248eb72dab9a45c0f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:a59918f042f0a5248eb72dab9a45c0f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34d753f6967100c9cec3c974ecb5326" id="r_af34d753f6967100c9cec3c974ecb5326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af34d753f6967100c9cec3c974ecb5326">submat</a> (in(int x, int y, int <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, int <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) roi)</td></tr>
<tr class="memdesc:af34d753f6967100c9cec3c974ecb5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a rectangular submatrix.  <br /></td></tr>
<tr class="separator:af34d753f6967100c9cec3c974ecb5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_open_c_v_for_unity_1_1_disposable_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_open_c_v_for_unity_1_1_disposable_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html">OpenCVForUnity.DisposableObject</a></td></tr>
<tr class="memitem:a68dd6362a65b5bf2f2b8828bef0b7dc2 inherit pub_methods_class_open_c_v_for_unity_1_1_disposable_object" id="r_a68dd6362a65b5bf2f2b8828bef0b7dc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html#a68dd6362a65b5bf2f2b8828bef0b7dc2">Dispose</a> ()</td></tr>
<tr class="separator:a68dd6362a65b5bf2f2b8828bef0b7dc2 inherit pub_methods_class_open_c_v_for_unity_1_1_disposable_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620f073ff3aa1bcee28fb00edb01dc11 inherit pub_methods_class_open_c_v_for_unity_1_1_disposable_object" id="r_a620f073ff3aa1bcee28fb00edb01dc11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html#a620f073ff3aa1bcee28fb00edb01dc11">ThrowIfDisposed</a> ()</td></tr>
<tr class="separator:a620f073ff3aa1bcee28fb00edb01dc11 inherit pub_methods_class_open_c_v_for_unity_1_1_disposable_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abc55b2c3ac6281bccf89d57d5eb2c7bb" id="r_abc55b2c3ac6281bccf89d57d5eb2c7bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc55b2c3ac6281bccf89d57d5eb2c7bb">diag</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> d)</td></tr>
<tr class="memdesc:abc55b2c3ac6281bccf89d57d5eb2c7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a diagonal matrix  <br /></td></tr>
<tr class="separator:abc55b2c3ac6281bccf89d57d5eb2c7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789d7a929b3e052d35581cc7f19b1845" id="r_a789d7a929b3e052d35581cc7f19b1845"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a789d7a929b3e052d35581cc7f19b1845">eye</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a789d7a929b3e052d35581cc7f19b1845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity matrix of the specified size and type.  <br /></td></tr>
<tr class="separator:a789d7a929b3e052d35581cc7f19b1845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284bd6237e8afb19b2ccd266630bb450" id="r_a284bd6237e8afb19b2ccd266630bb450"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a284bd6237e8afb19b2ccd266630bb450">eye</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a284bd6237e8afb19b2ccd266630bb450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity matrix of the specified size and type.  <br /></td></tr>
<tr class="separator:a284bd6237e8afb19b2ccd266630bb450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87787208caf135e9a0530b74c9c2633d" id="r_a87787208caf135e9a0530b74c9c2633d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87787208caf135e9a0530b74c9c2633d">ones</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a87787208caf135e9a0530b74c9c2633d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of all 1's of the specified size and type.  <br /></td></tr>
<tr class="separator:a87787208caf135e9a0530b74c9c2633d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206a45993387da30305f25c771a92468" id="r_a206a45993387da30305f25c771a92468"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a206a45993387da30305f25c771a92468">ones</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a206a45993387da30305f25c771a92468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of all 1's of the specified size and type.  <br /></td></tr>
<tr class="separator:a206a45993387da30305f25c771a92468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7cfa6c7a1ab1c82c0c27c1eb516bc0" id="r_ace7cfa6c7a1ab1c82c0c27c1eb516bc0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace7cfa6c7a1ab1c82c0c27c1eb516bc0">ones</a> (int[] sizes, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:ace7cfa6c7a1ab1c82c0c27c1eb516bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of all 1's of the specified size and type.  <br /></td></tr>
<tr class="separator:ace7cfa6c7a1ab1c82c0c27c1eb516bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415b6818d16ea2a7a1dcd571e04e14ab" id="r_a415b6818d16ea2a7a1dcd571e04e14ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab">zeros</a> (int <a class="el" href="#a9877819470ffa970b88727037342d458">rows</a>, int <a class="el" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a415b6818d16ea2a7a1dcd571e04e14ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero array of the specified size and type.  <br /></td></tr>
<tr class="separator:a415b6818d16ea2a7a1dcd571e04e14ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c168ba93b5458263423bba80d7e12b" id="r_a13c168ba93b5458263423bba80d7e12b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c168ba93b5458263423bba80d7e12b">zeros</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a13c168ba93b5458263423bba80d7e12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero array of the specified size and type.  <br /></td></tr>
<tr class="separator:a13c168ba93b5458263423bba80d7e12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834aad696a6dff0391b449dba8d233b1" id="r_a834aad696a6dff0391b449dba8d233b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a834aad696a6dff0391b449dba8d233b1">zeros</a> (int[] sizes, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a834aad696a6dff0391b449dba8d233b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero array of the specified size and type.  <br /></td></tr>
<tr class="separator:a834aad696a6dff0391b449dba8d233b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90b9fbca79f20d6a880f626bafab39" id="r_a4c90b9fbca79f20d6a880f626bafab39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c90b9fbca79f20d6a880f626bafab39">operator-</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:a4c90b9fbca79f20d6a880f626bafab39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates all elements of the matrix.  <br /></td></tr>
<tr class="separator:a4c90b9fbca79f20d6a880f626bafab39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a91923ac94fd6031f12766f44c52991" id="r_a6a91923ac94fd6031f12766f44c52991"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a91923ac94fd6031f12766f44c52991">operator~</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:a6a91923ac94fd6031f12766f44c52991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise NOT operation on the matrix.  <br /></td></tr>
<tr class="separator:a6a91923ac94fd6031f12766f44c52991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648a5f171a6e4196ccc5c8df11cf7677" id="r_a648a5f171a6e4196ccc5c8df11cf7677"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a648a5f171a6e4196ccc5c8df11cf7677">operator+</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b)</td></tr>
<tr class="memdesc:a648a5f171a6e4196ccc5c8df11cf7677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two matrices element-wise.  <br /></td></tr>
<tr class="separator:a648a5f171a6e4196ccc5c8df11cf7677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395fd8de6fae3a7153a6d75aa21d2e46" id="r_a395fd8de6fae3a7153a6d75aa21d2e46"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a395fd8de6fae3a7153a6d75aa21d2e46">operator+</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="memdesc:a395fd8de6fae3a7153a6d75aa21d2e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scalar value to each element of the matrix.  <br /></td></tr>
<tr class="separator:a395fd8de6fae3a7153a6d75aa21d2e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613581d9344659fd48b90a2dfce3bd61" id="r_a613581d9344659fd48b90a2dfce3bd61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a613581d9344659fd48b90a2dfce3bd61">operator+</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:a613581d9344659fd48b90a2dfce3bd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scalar value to each element of the matrix.  <br /></td></tr>
<tr class="separator:a613581d9344659fd48b90a2dfce3bd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308a81a6707d46d353d499fccc5dee89" id="r_a308a81a6707d46d353d499fccc5dee89"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a308a81a6707d46d353d499fccc5dee89">operator-</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b)</td></tr>
<tr class="memdesc:a308a81a6707d46d353d499fccc5dee89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one matrix from another.  <br /></td></tr>
<tr class="separator:a308a81a6707d46d353d499fccc5dee89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2264f6ca764b160987e3fb2d47488c68" id="r_a2264f6ca764b160987e3fb2d47488c68"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2264f6ca764b160987e3fb2d47488c68">operator-</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="memdesc:a2264f6ca764b160987e3fb2d47488c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a scalar value from each element of the matrix.  <br /></td></tr>
<tr class="separator:a2264f6ca764b160987e3fb2d47488c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1174189ddafc673708799798f82b6b74" id="r_a1174189ddafc673708799798f82b6b74"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1174189ddafc673708799798f82b6b74">operator-</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:a1174189ddafc673708799798f82b6b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a scalar value from each element of the matrix.  <br /></td></tr>
<tr class="separator:a1174189ddafc673708799798f82b6b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a3577b30d182d13554beb9dbbd82c8" id="r_a30a3577b30d182d13554beb9dbbd82c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30a3577b30d182d13554beb9dbbd82c8">operator*</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b)</td></tr>
<tr class="memdesc:a30a3577b30d182d13554beb9dbbd82c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two matrices using the General Matrix Multiply (GEMM) operation.  <br /></td></tr>
<tr class="separator:a30a3577b30d182d13554beb9dbbd82c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a599422317dbb86c27ecf8240c6f076" id="r_a8a599422317dbb86c27ecf8240c6f076"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a599422317dbb86c27ecf8240c6f076">operator*</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, double s)</td></tr>
<tr class="memdesc:a8a599422317dbb86c27ecf8240c6f076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix by a scalar value.  <br /></td></tr>
<tr class="separator:a8a599422317dbb86c27ecf8240c6f076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf648be03572f34508ac2c71bdaff577" id="r_acf648be03572f34508ac2c71bdaff577"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf648be03572f34508ac2c71bdaff577">operator*</a> (double s, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:acf648be03572f34508ac2c71bdaff577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix by a scalar value.  <br /></td></tr>
<tr class="separator:acf648be03572f34508ac2c71bdaff577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5b75c4b11d912ee598f280e5f82adb" id="r_aaa5b75c4b11d912ee598f280e5f82adb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa5b75c4b11d912ee598f280e5f82adb">operator/</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b)</td></tr>
<tr class="memdesc:aaa5b75c4b11d912ee598f280e5f82adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides one matrix by another.  <br /></td></tr>
<tr class="separator:aaa5b75c4b11d912ee598f280e5f82adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9791cb41a056ea93bc571851a1f8e8" id="r_aaf9791cb41a056ea93bc571851a1f8e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf9791cb41a056ea93bc571851a1f8e8">operator/</a> (double s, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:aaf9791cb41a056ea93bc571851a1f8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a scalar value by a matrix.  <br /></td></tr>
<tr class="separator:aaf9791cb41a056ea93bc571851a1f8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93c827d80f58bd4b34b827b51d63f4a" id="r_ab93c827d80f58bd4b34b827b51d63f4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab93c827d80f58bd4b34b827b51d63f4a">operator/</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, double s)</td></tr>
<tr class="memdesc:ab93c827d80f58bd4b34b827b51d63f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a matrix by a scalar value.  <br /></td></tr>
<tr class="separator:ab93c827d80f58bd4b34b827b51d63f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e8540445e9cf2fb0bfc71a2887562b" id="r_a15e8540445e9cf2fb0bfc71a2887562b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15e8540445e9cf2fb0bfc71a2887562b">operator&amp;</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b)</td></tr>
<tr class="memdesc:a15e8540445e9cf2fb0bfc71a2887562b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise AND operation between two matrices.  <br /></td></tr>
<tr class="separator:a15e8540445e9cf2fb0bfc71a2887562b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0adf03ae616e4be68fc84ac9ce2e83b" id="r_ac0adf03ae616e4be68fc84ac9ce2e83b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0adf03ae616e4be68fc84ac9ce2e83b">operator&amp;</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="memdesc:ac0adf03ae616e4be68fc84ac9ce2e83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise AND operation between a matrix and a scalar.  <br /></td></tr>
<tr class="separator:ac0adf03ae616e4be68fc84ac9ce2e83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3789629cd268308f1a850ae02758b41" id="r_ae3789629cd268308f1a850ae02758b41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3789629cd268308f1a850ae02758b41">operator&amp;</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:ae3789629cd268308f1a850ae02758b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise AND operation between a scalar and a matrix.  <br /></td></tr>
<tr class="separator:ae3789629cd268308f1a850ae02758b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f68cd26e43262116c27cd70319173e" id="r_ad2f68cd26e43262116c27cd70319173e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2f68cd26e43262116c27cd70319173e">operator|</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b)</td></tr>
<tr class="memdesc:ad2f68cd26e43262116c27cd70319173e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise OR operation between two matrices.  <br /></td></tr>
<tr class="separator:ad2f68cd26e43262116c27cd70319173e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ec36d8053add40646b7fb0a2d25856" id="r_ac0ec36d8053add40646b7fb0a2d25856"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0ec36d8053add40646b7fb0a2d25856">operator|</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="memdesc:ac0ec36d8053add40646b7fb0a2d25856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise OR operation between a matrix and a scalar value.  <br /></td></tr>
<tr class="separator:ac0ec36d8053add40646b7fb0a2d25856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2fc6d1894eb9981076b21ca407f526" id="r_a0b2fc6d1894eb9981076b21ca407f526"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b2fc6d1894eb9981076b21ca407f526">operator|</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:a0b2fc6d1894eb9981076b21ca407f526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise OR operation between a scalar value and a matrix.  <br /></td></tr>
<tr class="separator:a0b2fc6d1894eb9981076b21ca407f526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59aa026973ac82aab6572df8d5bb3114" id="r_a59aa026973ac82aab6572df8d5bb3114"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59aa026973ac82aab6572df8d5bb3114">operator^</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> b)</td></tr>
<tr class="memdesc:a59aa026973ac82aab6572df8d5bb3114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise XOR operation between two matrices.  <br /></td></tr>
<tr class="separator:a59aa026973ac82aab6572df8d5bb3114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93513201a3e2e088241a71a97feeadb8" id="r_a93513201a3e2e088241a71a97feeadb8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93513201a3e2e088241a71a97feeadb8">operator^</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="memdesc:a93513201a3e2e088241a71a97feeadb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise XOR operation between a matrix and a scalar value.  <br /></td></tr>
<tr class="separator:a93513201a3e2e088241a71a97feeadb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de3ca7c4a52ca2630251704748ff0b8" id="r_a8de3ca7c4a52ca2630251704748ff0b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de3ca7c4a52ca2630251704748ff0b8">operator^</a> (<a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a> s, <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> a)</td></tr>
<tr class="memdesc:a8de3ca7c4a52ca2630251704748ff0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise XOR operation between a scalar value and a matrix.  <br /></td></tr>
<tr class="separator:a8de3ca7c4a52ca2630251704748ff0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a15f8376b1d95d29f38d0615f43050" id="r_ad3a15f8376b1d95d29f38d0615f43050"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a15f8376b1d95d29f38d0615f43050">eye</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:ad3a15f8376b1d95d29f38d0615f43050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity matrix of the specified size and type.  <br /></td></tr>
<tr class="separator:ad3a15f8376b1d95d29f38d0615f43050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aaf70723220d0d2d2348c1832482e4" id="r_aa7aaf70723220d0d2d2348c1832482e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7aaf70723220d0d2d2348c1832482e4">ones</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:aa7aaf70723220d0d2d2348c1832482e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of all 1's of the specified size and type.  <br /></td></tr>
<tr class="separator:aa7aaf70723220d0d2d2348c1832482e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4380ecf416bf0e066926a359a5ca08ef" id="r_a4380ecf416bf0e066926a359a5ca08ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4380ecf416bf0e066926a359a5ca08ef">zeros</a> (in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a4380ecf416bf0e066926a359a5ca08ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero array of the specified size and type.  <br /></td></tr>
<tr class="separator:a4380ecf416bf0e066926a359a5ca08ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725cd7bad4718524c64a9a113b103a13" id="r_a725cd7bad4718524c64a9a113b103a13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725cd7bad4718524c64a9a113b103a13">eye</a> (in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a725cd7bad4718524c64a9a113b103a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity matrix of the specified size and type.  <br /></td></tr>
<tr class="separator:a725cd7bad4718524c64a9a113b103a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f393e2a8f60b97b0ea219d5820173c6" id="r_a4f393e2a8f60b97b0ea219d5820173c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f393e2a8f60b97b0ea219d5820173c6">ones</a> (in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:a4f393e2a8f60b97b0ea219d5820173c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of all 1's of the specified size and type.  <br /></td></tr>
<tr class="separator:a4f393e2a8f60b97b0ea219d5820173c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac550f7252eadad76b2d5945b85b37d99" id="r_ac550f7252eadad76b2d5945b85b37d99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac550f7252eadad76b2d5945b85b37d99">zeros</a> (in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>) <a class="el" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, int <a class="el" href="#ab50fde5c175a561068025df6b35363f1">type</a>)</td></tr>
<tr class="memdesc:ac550f7252eadad76b2d5945b85b37d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero array of the specified size and type.  <br /></td></tr>
<tr class="separator:ac550f7252eadad76b2d5945b85b37d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_open_c_v_for_unity_1_1_disposable_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_class_open_c_v_for_unity_1_1_disposable_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html">OpenCVForUnity.DisposableObject</a></td></tr>
<tr class="memitem:a4b998ab4293ee3fb7cdc494ed9375fc3 inherit pub_static_methods_class_open_c_v_for_unity_1_1_disposable_object" id="r_a4b998ab4293ee3fb7cdc494ed9375fc3"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html#a4b998ab4293ee3fb7cdc494ed9375fc3">ThrowIfNullIntPtr</a> (IntPtr ptr)</td></tr>
<tr class="separator:a4b998ab4293ee3fb7cdc494ed9375fc3 inherit pub_static_methods_class_open_c_v_for_unity_1_1_disposable_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae93e9405d94937661d3d8fada5d0e008" id="r_ae93e9405d94937661d3d8fada5d0e008"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a></td></tr>
<tr class="separator:ae93e9405d94937661d3d8fada5d0e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7cee67ee777c199f7f0b02a32970bad5" id="r_a7cee67ee777c199f7f0b02a32970bad5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a> = 0</td></tr>
<tr class="separator:a7cee67ee777c199f7f0b02a32970bad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af3b146269cffa68caa39cf512e869567" id="r_af3b146269cffa68caa39cf512e869567"><td class="memItemLeft" align="right" valign="top">override void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3b146269cffa68caa39cf512e869567">Dispose</a> (bool disposing)</td></tr>
<tr class="memdesc:af3b146269cffa68caa39cf512e869567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the matrix data and releases resources.  <br /></td></tr>
<tr class="separator:af3b146269cffa68caa39cf512e869567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html">OpenCVForUnity.DisposableOpenCVObject</a></td></tr>
<tr class="memitem:aab50d94cc702503eac045ca7042624ae inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object" id="r_aab50d94cc702503eac045ca7042624ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html#aab50d94cc702503eac045ca7042624ae">DisposableOpenCVObject</a> ()</td></tr>
<tr class="separator:aab50d94cc702503eac045ca7042624ae inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc5923de5bd43795c72dd7f581ad832 inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object" id="r_a6dc5923de5bd43795c72dd7f581ad832"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html#a6dc5923de5bd43795c72dd7f581ad832">DisposableOpenCVObject</a> (IntPtr ptr)</td></tr>
<tr class="separator:a6dc5923de5bd43795c72dd7f581ad832 inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb2523312e8a423889a1d160e755e7d inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object" id="r_a1fb2523312e8a423889a1d160e755e7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html#a1fb2523312e8a423889a1d160e755e7d">DisposableOpenCVObject</a> (bool isEnabledDispose)</td></tr>
<tr class="separator:a1fb2523312e8a423889a1d160e755e7d inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739b223f2008fae0966c43d0c6f0f72f inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object" id="r_a739b223f2008fae0966c43d0c6f0f72f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html#a739b223f2008fae0966c43d0c6f0f72f">DisposableOpenCVObject</a> (IntPtr ptr, bool isEnabledDispose)</td></tr>
<tr class="separator:a739b223f2008fae0966c43d0c6f0f72f inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_open_c_v_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_open_c_v_for_unity_1_1_disposable_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_open_c_v_for_unity_1_1_disposable_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html">OpenCVForUnity.DisposableObject</a></td></tr>
<tr class="memitem:ae924d4d77a5929e39abca6ef9daf6330 inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_object" id="r_ae924d4d77a5929e39abca6ef9daf6330"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html#ae924d4d77a5929e39abca6ef9daf6330">DisposableObject</a> ()</td></tr>
<tr class="separator:ae924d4d77a5929e39abca6ef9daf6330 inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e47724d49556061a5ba400577be2a13 inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_object" id="r_a1e47724d49556061a5ba400577be2a13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html#a1e47724d49556061a5ba400577be2a13">DisposableObject</a> (bool isEnabledDispose)</td></tr>
<tr class="separator:a1e47724d49556061a5ba400577be2a13 inherit pro_methods_class_open_c_v_for_unity_1_1_disposable_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pac_attribs_class_open_c_v_for_unity_1_1_disposable_open_c_v_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pac_attribs_class_open_c_v_for_unity_1_1_disposable_open_c_v_object')"><img src="closed.png" alt="-"/>&#160;Package Attributes inherited from <a class="el" href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html">OpenCVForUnity.DisposableOpenCVObject</a></td></tr>
<tr class="inherit_header properties_class_open_c_v_for_unity_1_1_disposable_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('properties_class_open_c_v_for_unity_1_1_disposable_object')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html">OpenCVForUnity.DisposableObject</a></td></tr>
<tr class="memitem:a056e69daaa9ea20e563c5e41b28c1525 inherit properties_class_open_c_v_for_unity_1_1_disposable_object" id="r_a056e69daaa9ea20e563c5e41b28c1525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html#a056e69daaa9ea20e563c5e41b28c1525">IsDisposed</a><code> [get, protected set]</code></td></tr>
<tr class="separator:a056e69daaa9ea20e563c5e41b28c1525 inherit properties_class_open_c_v_for_unity_1_1_disposable_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e287e3cb5995f483cb64dd6c3b19a7f inherit properties_class_open_c_v_for_unity_1_1_disposable_object" id="r_a8e287e3cb5995f483cb64dd6c3b19a7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_for_unity_1_1_disposable_object.html#a8e287e3cb5995f483cb64dd6c3b19a7f">IsEnabledDispose</a><code> [get, set]</code></td></tr>
<tr class="separator:a8e287e3cb5995f483cb64dd6c3b19a7f inherit properties_class_open_c_v_for_unity_1_1_disposable_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>n-dimensional dense array class </p>
<p>C++: cv::Mat Class Reference </p><dl class="section see"><dt>See also</dt><dd><a href="https://docs.opencv.org/4.10.0/d3/d63/classcv_1_1Mat.html">https://docs.opencv.org/4.10.0/d3/d63/classcv_1_1Mat.html</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa72bf9d9607cbb0af6e4e3f11bd8b9ba" name="aa72bf9d9607cbb0af6e4e3f11bd8b9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">&#9670;&#160;</a></span>Mat() <span class="overload">[1/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dab3c9cf93248d9ebe1d13a4b453e3e" name="a2dab3c9cf93248d9ebe1d13a4b453e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dab3c9cf93248d9ebe1d13a4b453e3e">&#9670;&#160;</a></span>Mat() <span class="overload">[2/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>

</div>
</div>
<a id="afa7d4972f5d5c3a02158a8d8f32d7cbb" name="afa7d4972f5d5c3a02158a8d8f32d7cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7d4972f5d5c3a02158a8d8f32d7cbb">&#9670;&#160;</a></span>Mat() <span class="overload">[3/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07998ca9da3c7f0f0795a1b1094b36a4" name="a07998ca9da3c7f0f0795a1b1094b36a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07998ca9da3c7f0f0795a1b1094b36a4">&#9670;&#160;</a></span>Mat() <span class="overload">[4/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac400c0b218eb3ab4b4094c25ac14ebdd" name="ac400c0b218eb3ab4b4094c25ac14ebdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac400c0b218eb3ab4b4094c25ac14ebdd">&#9670;&#160;</a></span>Mat() <span class="overload">[5/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Array of integers specifying an n-dimensional array shape. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0cee01044b874e1b3c00917ae8c6bbf" name="ae0cee01044b874e1b3c00917ae8c6bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cee01044b874e1b3c00917ae8c6bbf">&#9670;&#160;</a></span>Mat() <span class="overload">[6/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06415b4fc88181a17bc32fe8eb043c23" name="a06415b4fc88181a17bc32fe8eb043c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06415b4fc88181a17bc32fe8eb043c23">&#9670;&#160;</a></span>Mat() <span class="overload">[7/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63d1cfdddb90f7d5c0c153dc57062ee" name="ae63d1cfdddb90f7d5c0c153dc57062ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63d1cfdddb90f7d5c0c153dc57062ee">&#9670;&#160;</a></span>Mat() <span class="overload">[8/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Array of integers specifying an n-dimensional array shape. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa06de7b72a805cf5fc6b083d5a4ec44" name="afa06de7b72a805cf5fc6b083d5a4ec44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa06de7b72a805cf5fc6b083d5a4ec44">&#9670;&#160;</a></span>Mat() <span class="overload">[9/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>colRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">rowRange</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m rows to take. As usual, the range start is inclusive and the range end is exclusive.Use Range::all() to take all the rows. </td></tr>
    <tr><td class="paramname">colRange</td><td>colRange <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m columns to take. Use Range::all() to take all the columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0384ced6b7bf035f75c6b1dfd079c1" name="aff0384ced6b7bf035f75c6b1dfd079c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0384ced6b7bf035f75c6b1dfd079c1">&#9670;&#160;</a></span>Mat() <span class="overload">[10/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">rowRange</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m rows to take. As usual, the range start is inclusive and the range end is exclusive.Use Range::all() to take all the rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2c02633a8b13cfbc3f56a777cf92da0" name="af2c02633a8b13cfbc3f56a777cf92da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c02633a8b13cfbc3f56a777cf92da0">&#9670;&#160;</a></span>Mat() <span class="overload">[11/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a>[]</td>          <td class="paramname"><span class="paramname"><em>ranges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">ranges</td><td>Array of selected ranges of m along each dimensionality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76dc203c41f2abfe025ac2ad7653b155" name="a76dc203c41f2abfe025ac2ad7653b155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dc203c41f2abfe025ac2ad7653b155">&#9670;&#160;</a></span>Mat() <span class="overload">[12/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a></td>          <td class="paramname"><span class="paramname"><em>roi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">roi</td><td>Region of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a956aeb913a92797dcc5f6a6aa8ebf17e" name="a956aeb913a92797dcc5f6a6aa8ebf17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956aeb913a92797dcc5f6a6aa8ebf17e">&#9670;&#160;</a></span>Mat() <span class="overload">[13/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data.Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied.This operation is very efficient and can be used to process external data using OpenCV functions.The external data is not automatically deallocated, so you should take care of it. </td></tr>
    <tr><td class="paramname">step</td><td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.If the parameter is missing(set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols* <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">elemSize()</a>. See <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">Mat.elemSize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a774031f49d8e16c2262c8cc791d13b78" name="a774031f49d8e16c2262c8cc791d13b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774031f49d8e16c2262c8cc791d13b78">&#9670;&#160;</a></span>Mat() <span class="overload">[14/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data.Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied.This operation is very efficient and can be used to process external data using OpenCV functions.The external data is not automatically deallocated, so you should take care of it. </td></tr>
    <tr><td class="paramname">step</td><td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.If the parameter is missing(set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols* <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">elemSize()</a>. See <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">Mat.elemSize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e87ea6ffeada43e8176d9ee9d54f50f" name="a3e87ea6ffeada43e8176d9ee9d54f50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e87ea6ffeada43e8176d9ee9d54f50f">&#9670;&#160;</a></span>Mat() <span class="overload">[15/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b2a5f199bdb589d20c07a3622957141" name="a6b2a5f199bdb589d20c07a3622957141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2a5f199bdb589d20c07a3622957141">&#9670;&#160;</a></span>Mat() <span class="overload">[16/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53408a375a782f3cf8c1eb59d7a3ebdb" name="a53408a375a782f3cf8c1eb59d7a3ebdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53408a375a782f3cf8c1eb59d7a3ebdb">&#9670;&#160;</a></span>Mat() <span class="overload">[17/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a452099cb1fc51c0be1d7bd3e64a9dafd" name="a452099cb1fc51c0be1d7bd3e64a9dafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452099cb1fc51c0be1d7bd3e64a9dafd">&#9670;&#160;</a></span>Mat() <span class="overload">[18/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Array of integers specifying an n-dimensional array shape. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5658892082d60396f7ef15b38a1ac428" name="a5658892082d60396f7ef15b38a1ac428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5658892082d60396f7ef15b38a1ac428">&#9670;&#160;</a></span>Mat() <span class="overload">[19/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a></td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a></td>          <td class="paramname"><span class="paramname"><em>colRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">rowRange</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m rows to take. As usual, the range start is inclusive and the range end is exclusive.Use Range::all() to take all the rows. </td></tr>
    <tr><td class="paramname">colRange</td><td>colRange <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m columns to take. Use Range::all() to take all the columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ddf594c901042df19f95e53ab8794b" name="a91ddf594c901042df19f95e53ab8794b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ddf594c901042df19f95e53ab8794b">&#9670;&#160;</a></span>Mat() <span class="overload">[20/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a></td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">rowRange</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m rows to take. As usual, the range start is inclusive and the range end is exclusive.Use Range::all() to take all the rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ddb29d271595684e5d24ea2fd22f8ad" name="a2ddb29d271595684e5d24ea2fd22f8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddb29d271595684e5d24ea2fd22f8ad">&#9670;&#160;</a></span>Mat() <span class="overload">[21/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a>[]</td>          <td class="paramname"><span class="paramname"><em>ranges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">ranges</td><td>Array of selected ranges of m along each dimensionality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee4e99f8704b65d358af84ad4192f5b2" name="aee4e99f8704b65d358af84ad4192f5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4e99f8704b65d358af84ad4192f5b2">&#9670;&#160;</a></span>Mat() <span class="overload">[22/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4i.html">Vec4i</a></td>          <td class="paramname"><span class="paramname"><em>roi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">roi</td><td>Region of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6dd958e823563bdff09c135000d9fb9" name="ac6dd958e823563bdff09c135000d9fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dd958e823563bdff09c135000d9fb9">&#9670;&#160;</a></span>Mat() <span class="overload">[23/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data.Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied.This operation is very efficient and can be used to process external data using OpenCV functions.The external data is not automatically deallocated, so you should take care of it. </td></tr>
    <tr><td class="paramname">step</td><td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.If the parameter is missing(set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols* <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">elemSize()</a>. See <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">Mat.elemSize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7d7cf1241d063e226bfdb8522ae3aea" name="ad7d7cf1241d063e226bfdb8522ae3aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d7cf1241d063e226bfdb8522ae3aea">&#9670;&#160;</a></span>Mat() <span class="overload">[24/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afef6eecf14439869a0cf6fe1fd22ba07" name="afef6eecf14439869a0cf6fe1fd22ba07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef6eecf14439869a0cf6fe1fd22ba07">&#9670;&#160;</a></span>Mat() <span class="overload">[25/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double v0, double v1, double v2, double v3)</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14be477225b4710e66bf325bcbf9eb2b" name="a14be477225b4710e66bf325bcbf9eb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14be477225b4710e66bf325bcbf9eb2b">&#9670;&#160;</a></span>Mat() <span class="overload">[26/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double v0, double v1, double v2, double v3)</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3adb464ae5cd20742485d423609d7131" name="a3adb464ae5cd20742485d423609d7131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adb464ae5cd20742485d423609d7131">&#9670;&#160;</a></span>Mat() <span class="overload">[27/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double v0, double v1, double v2, double v3)</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Array of integers specifying an n-dimensional array shape. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">s</td><td>An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator Mat::operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; value) . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72dd8494568c1e1b2f23b4c19c5c4b9f" name="a72dd8494568c1e1b2f23b4c19c5c4b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dd8494568c1e1b2f23b4c19c5c4b9f">&#9670;&#160;</a></span>Mat() <span class="overload">[28/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(int start, int end)</td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(int start, int end)</td>          <td class="paramname"><span class="paramname"><em>colRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">rowRange</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m rows to take. As usual, the range start is inclusive and the range end is exclusive.Use Range::all() to take all the rows. </td></tr>
    <tr><td class="paramname">colRange</td><td>colRange <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m columns to take. Use Range::all() to take all the columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb571de477091ec1f6960f3fdeed4b15" name="acb571de477091ec1f6960f3fdeed4b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb571de477091ec1f6960f3fdeed4b15">&#9670;&#160;</a></span>Mat() <span class="overload">[29/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(int start, int end)</td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">rowRange</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> of the m rows to take. As usual, the range start is inclusive and the range end is exclusive.Use Range::all() to take all the rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f84c58335f367f16ed3f22de52c98a" name="a18f84c58335f367f16ed3f22de52c98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f84c58335f367f16ed3f22de52c98a">&#9670;&#160;</a></span>Mat() <span class="overload">[30/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(int start, int end)[]</td>          <td class="paramname"><span class="paramname"><em>ranges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">ranges</td><td>Array of selected ranges of m along each dimensionality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2a9b06fb739f3e90ab4be8551bc0f41" name="ab2a9b06fb739f3e90ab4be8551bc0f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a9b06fb739f3e90ab4be8551bc0f41">&#9670;&#160;</a></span>Mat() <span class="overload">[31/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(int x, int y, int <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, int <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>roi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors.Instead, the header pointing to m data or its sub-array is constructed and associated with it.The reference counter, if any, is incremented.So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m.If you want to have an independent copy of the sub-array, use <a class="el" href="#a727f0d641cd857acdd14bfce16c3aa54" title="Creates a full copy of the array and the underlying data.">Mat.clone()</a> . </td></tr>
    <tr><td class="paramname">roi</td><td>Region of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad01c41f91863417374277f0c9d431a97" name="ad01c41f91863417374277f0c9d431a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01c41f91863417374277f0c9d431a97">&#9670;&#160;</a></span>Mat() <span class="overload">[32/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVForUnity.CoreModule.Mat.Mat </td>
          <td>(</td>
          <td class="paramtype">in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a7cee67ee777c199f7f0b02a32970bad5">AUTO_STEP</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are various constructors that form a matrix.As noted in the AutomaticAllocation, often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with Mat::create.In the former case, the old content is de-referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel(up to CV_CN_MAX channels) matrices. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data.Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied.This operation is very efficient and can be used to process external data using OpenCV functions.The external data is not automatically deallocated, so you should take care of it. </td></tr>
    <tr><td class="paramname">step</td><td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.If the parameter is missing(set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols* <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">elemSize()</a>. See <a class="el" href="#a2df92b8f53f26ad2a6b2a7654a153bcc" title="Returns the matrix element size in bytes.">Mat.elemSize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a91687b339124b7d84e550c9396e122e7" name="a91687b339124b7d84e550c9396e122e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91687b339124b7d84e550c9396e122e7">&#9670;&#160;</a></span>adjustROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.adjustROI </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dtop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dbottom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dleft</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dright</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts a submatrix size and position within the parent matrix. </p>
<p>The method is complimentary to Mat::locateROI.The typical use of these functions is to determine the submatrix position within the parent matrix and then shift the position somehow.Typically, it can be required for filtering operations when pixels outside of the ROI should be taken into account.When all the method parameters are positive, the ROI needs to grow in all directions by the specified amount, for example: </p>
<div class="fragment"><div class="line">A.adjustROI(2, 2, 2, 2);</div>
</div><!-- fragment --> <p>In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the filtering with the 5x5 kernel.</p>
<p>adjustROI forces the adjusted ROI to be inside of the parent matrix that is boundaries of the adjusted ROI are constrained by boundaries of the parent matrix.For example, if the submatrix A is located in the first row of a parent matrix and you called A.adjustROI(2, 2, 2, 2) then A will not be increased in the upward direction.</p>
<p>The function is used internally by the OpenCV filtering functions, like filter2D , morphological operations, and so on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtop</td><td>Shift of the top submatrix boundary upwards. </td></tr>
    <tr><td class="paramname">dbottom</td><td>Shift of the bottom submatrix boundary downwards. </td></tr>
    <tr><td class="paramname">dleft</td><td>Shift of the left submatrix boundary to the left. </td></tr>
    <tr><td class="paramname">dright</td><td>Shift of the right submatrix boundary to the right. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>copyMakeBorder </dd></dl>

</div>
</div>
<a id="a090860925704d0d3adaadf0150b40395" name="a090860925704d0d3adaadf0150b40395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090860925704d0d3adaadf0150b40395">&#9670;&#160;</a></span>assignTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.assignTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a functional form of convertTo. </p>
<p>This is an internally used method called by the MatrixExpressions engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Destination array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a246d10f53ef54ba5e4b1c86e46672ccd" name="a246d10f53ef54ba5e4b1c86e46672ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246d10f53ef54ba5e4b1c86e46672ccd">&#9670;&#160;</a></span>assignTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.assignTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a functional form of convertTo. </p>
<p>This is an internally used method called by the MatrixExpressions engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Destination array. </td></tr>
    <tr><td class="paramname">type</td><td>Desired destination array depth (or -1 if it should be the same as the source type). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad769ba322b0e8e527819fa2c7727fb3f" name="ad769ba322b0e8e527819fa2c7727fb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad769ba322b0e8e527819fa2c7727fb3f">&#9670;&#160;</a></span>AsSpan&lt; T &gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.AsSpan&lt; T &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span%3CT%3E representing the entire data of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the first element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object and uses it to create a Span&lt;T&gt; that spans the entire data stored in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. The length of the Span&lt;T&gt; is calculated by dividing the total size of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>'s data (in bytes) by the size of type <em>T</em> .</p>
<p><b>Type Mapping:</b> </p><table class="doxtable">
<tr>
<th><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> CVType </th><th>Description </th><th>Data Type </th><th>C# Type </th><th>VecStruct  </th></tr>
<tr>
<td>CV_8U </td><td>Unsigned 8-bit integer </td><td>unsigned char </td><td>byte (System.Byte) </td><td>VecNb  </td></tr>
<tr>
<td>CV_8S </td><td>Signed 8-bit integer </td><td>signed char </td><td>sbyte (System.SByte) </td><td>VecNc  </td></tr>
<tr>
<td>CV_16U </td><td>Unsigned 16-bit integer </td><td>unsigned short </td><td>ushort (System.UInt16) </td><td>VecNw  </td></tr>
<tr>
<td>CV_16S </td><td>Signed 16-bit integer </td><td>short </td><td>short (System.Int16) </td><td>VecNs  </td></tr>
<tr>
<td>CV_32S </td><td>Signed 32-bit integer </td><td>int </td><td>int (System.Int32) </td><td>VecNi  </td></tr>
<tr>
<td>CV_32F </td><td>32-bit floating-point number </td><td>float </td><td>float (System.Single) </td><td>VecNf  </td></tr>
<tr>
<td>CV_64F </td><td>64-bit floating-point number </td><td>double </td><td>double (System.Double) </td><td>VecNd  </td></tr>
</table>
<p><b>Note:</b> This method only works with continuous <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> objects. If <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code>, an exception will be thrown. Ensure that the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> is continuous before calling this method to avoid errors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; that represents the entire data of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown when <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code>, as this method requires a continuous <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab81ebf833a4fbe4330cff20b9249ea39" name="ab81ebf833a4fbe4330cff20b9249ea39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81ebf833a4fbe4330cff20b9249ea39">&#9670;&#160;</a></span>AsSpan&lt; T &gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.AsSpan&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the data in the specified row or dimension of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the first element in the specified row (i0) or dimension (i0) of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, depending on the number of dimensions in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>, and uses that pointer to create a Span&lt;T&gt;.</p><ul>
<li>For 2D Mats, it returns a pointer to the first element in row i0 and spans the entire row.</li>
<li>For Mats with more than 2 dimensions, it returns a pointer to the first element in dimension i0, assuming the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> is continuous. If <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code>, an exception is thrown.</li>
</ul>
<p>The length of the Span&lt;T&gt; is determined by dividing the size of the data in the specified row or dimension by the size of type <em>T</em> . </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The index of the row or first dimension from which the pointer should be returned. Must be within the valid range for the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the data in the specified row or dimension. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown when <em>i0</em>  is out of the valid range of rows or dimensions. Thrown when <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code> for Mats with more than 2 dimensions. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af0a154ea4c2bc4a63c0eff85f21e4d96" name="af0a154ea4c2bc4a63c0eff85f21e4d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a154ea4c2bc4a63c0eff85f21e4d96">&#9670;&#160;</a></span>AsSpan&lt; T &gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.AsSpan&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the data at the specified row and column, or dimensions, of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the element in the specified row (i0) and column (i1) for 2D Mats, or the first two dimensions (i0, i1) for higher-dimensional Mats, and uses that pointer to create a Span&lt;T&gt;.</p><ul>
<li>For 2D Mats, it returns a pointer to the specific element at row i0 and column i1, returning a Span&lt;T&gt; representing that single element.</li>
<li>For Mats with more than 2 dimensions, it returns a pointer to the element at indices i0 and i1, and spans the rest of the data in the remaining dimensions. If <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code>, an exception is thrown.</li>
</ul>
<p>The length of the Span&lt;T&gt; is determined by dividing the size of the data in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> by the size of type <em>T</em> . For 2D Mats, it spans just one element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The row index or first dimension from which the pointer should be returned. Must be within the valid range for the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </td></tr>
    <tr><td class="paramname">i1</td><td>The column index or second dimension from which the pointer should be returned. Must be within the valid range for the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the data at the specified row and column, or dimensions. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown when <em>i0</em>  or <em>i1</em>  is out of the valid range of rows, columns, or dimensions. Thrown when <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code> for Mats with more than 2 dimensions. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5c4a1d9795159d5c9f8c1b6ba1191ba1" name="a5c4a1d9795159d5c9f8c1b6ba1191ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4a1d9795159d5c9f8c1b6ba1191ba1">&#9670;&#160;</a></span>AsSpan&lt; T &gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.AsSpan&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the data at the specified element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, starting from the given three-dimensional indices. </p>
<p>This method returns a pointer to the element in the specified position (i0, i1, i2) of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object and uses that pointer to create a Span&lt;T&gt;. The method works for Mats with 3 or more dimensions, spanning the data in the remaining dimensions if applicable.</p>
<ul>
<li>For Mats with exactly 3 dimensions, it returns the pointer to the element at the indices (i0, i1, i2) and returns a Span&lt;T&gt; representing the element at that position.</li>
<li>For Mats with more than 3 dimensions, it returns the pointer at (i0, i1, i2) and spans the data across the remaining dimensions. If <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code>, an exception is thrown since continuous memory is required.</li>
</ul>
<p>The length of the Span&lt;T&gt; is determined by dividing the size of the data by the size of type <em>T</em> . For 3D Mats, it spans one element, and for higher-dimensional Mats, it spans the remaining elements in the additional dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The index for the first dimension (typically representing rows). Must be within the valid range of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>'s first dimension. </td></tr>
    <tr><td class="paramname">i1</td><td>The index for the second dimension (typically representing columns). Must be within the valid range of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>'s second dimension. </td></tr>
    <tr><td class="paramname">i2</td><td>The index for the third dimension. Must be within the valid range of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>'s third dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the data starting at the specified element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown when <em>i0</em> , <em>i1</em> , or <em>i2</em>  are out of the valid range of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>'s respective dimensions. Thrown when <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code> for Mats with more than 2 dimensions. Thrown when the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> has fewer than 3 dimensions. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8154aa3831f9f3592ca50908d3f72694" name="a8154aa3831f9f3592ca50908d3f72694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8154aa3831f9f3592ca50908d3f72694">&#9670;&#160;</a></span>AsSpan&lt; T &gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.AsSpan&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">params int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the data at the specified element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object based on a variable number of indices. </p>
<p>This method returns a pointer to the element in the specified position, determined by the indices provided in the <em>idx</em>  array, and uses that pointer to create a Span&lt;T&gt;. The method adapts to Mats with 2 or more dimensions:</p>
<ul>
<li>For a 2D <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>, if one index is provided, it returns a Span&lt;T&gt; for the specified row. If two indices are provided, it returns a Span&lt;T&gt; for the specified element.</li>
<li>For higher-dimensional Mats, it returns the pointer at the specified indices and spans the remaining dimensions. If <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code>, an exception is thrown since continuous memory is required.</li>
</ul>
<p>The length of the Span&lt;T&gt; is determined by dividing the size of the data by the size of type <em>T</em> . For multi-dimensional Mats, it spans one element or the remaining elements in the additional dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the position of the element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. The number of indices must match the number of dimensions in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the data starting at the specified element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown when the number of dimensions in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> is less than the number of indices provided in <em>idx</em> . Thrown when any index in <em>idx</em>  is out of bounds for the respective dimension. Thrown when <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code> for Mats with more than 2 dimensions. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac6d195ed579c066bc9e38968f626cfed" name="ac6d195ed579c066bc9e38968f626cfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d195ed579c066bc9e38968f626cfed">&#9670;&#160;</a></span>AsSpanRowRange&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.AsSpanRowRange&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>endrow</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the data in the specified range of rows in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the first element of the specified range of rows (from <em>startrow</em>  to <em>endrow</em> ), and uses that pointer to create a Span&lt;T&gt; that spans the specified rows.</p>
<ul>
<li>If the difference between <em>startrow</em>  and <em>endrow</em>  is 1, it returns a Span&lt;T&gt; for that single row.</li>
<li>For multi-row ranges, the method requires the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object to be continuous in memory, as checked by <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a>.</li>
</ul>
<p>The length of the Span&lt;T&gt; is determined by the number of rows and the size of the elements in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, divided by the size of type <em>T</em> . </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startrow</td><td>The index of the first row in the range to be spanned. Must be within the valid range of rows. </td></tr>
    <tr><td class="paramname">endrow</td><td>The index of the row after the last row to be spanned. Must be greater than <em>startrow</em>  and within the valid range of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the data in the specified range of rows in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown when <em>endrow</em>  is less than or equal to <em>startrow</em> , when either index is out of bounds, or when <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous()</a> is <code>false</code> for multi-row ranges. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ada857d5a5dda4c5d0159c0611f8cdfbe" name="ada857d5a5dda4c5d0159c0611f8cdfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada857d5a5dda4c5d0159c0611f8cdfbe">&#9670;&#160;</a></span>AsSpanRowRange&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.AsSpanRowRange&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing a range of rows from the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, defined by the specified <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a>. </p>
<p>This method calls <a class="el" href="#ac6d195ed579c066bc9e38968f626cfed" title="Creates and returns a Span&lt;T&gt; representing the data in the specified range of rows in the Mat object.">AsSpanRowRange&lt;T&gt;(int, int)</a> internally, using the start and end indices from the provided <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a>. The resulting Span&lt;T&gt; includes the elements from the row specified by <code>r.Start</code> to the row before <code>r.End</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> representing the start and end row indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the specified row range in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abf0ae29f91684bda74ebfbea65062efd" name="abf0ae29f91684bda74ebfbea65062efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0ae29f91684bda74ebfbea65062efd">&#9670;&#160;</a></span>at&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.at&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the first element in the specified row of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the first element in the specified row (i0) of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, and uses that pointer to create a Span&lt;T&gt;. The length of the Span&lt;T&gt; is determined by dividing the size of one element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> by the size of type <em>T</em> .</p>
<p><b>Note:</b> This method does not perform bounds checking on the index i0. If i0 is out of bounds, an invalid pointer may be dereferenced, which can lead to undefined behavior. Ensure that the index is within the valid range for the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The row index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the first element of the specified row. </dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae15b7cab767a3bb3ae65a8da84cb94f7" name="ae15b7cab767a3bb3ae65a8da84cb94f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15b7cab767a3bb3ae65a8da84cb94f7">&#9670;&#160;</a></span>at&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.at&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the first element in the specified row and column of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the first element in the specified row (i0) and column (i1) of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, and uses that pointer to create a Span&lt;T&gt;. The length of the Span&lt;T&gt; is determined by dividing the size of one element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> by the size of type <em>T</em> .</p>
<p><b>Note:</b> This method does not perform bounds checking on the indices i0 and i1. If any index is out of bounds, an invalid pointer may be dereferenced, which can lead to undefined behavior. Ensure that the indices are within the valid range for the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The row index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of rows. </td></tr>
    <tr><td class="paramname">i1</td><td>The column index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the first element of the specified row and column. </dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a4188d33d455cb82110c3a61c2d83e8db" name="a4188d33d455cb82110c3a61c2d83e8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4188d33d455cb82110c3a61c2d83e8db">&#9670;&#160;</a></span>at&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.at&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the first element in the specified row, column, and third dimension of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the first element in the specified row (i0), column (i1), and third dimension (i2) of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object, and uses that pointer to create a Span&lt;T&gt;. The length of the Span&lt;T&gt; is determined by dividing the size of one element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> by the size of type <em>T</em> .</p>
<p><b>Note:</b> This method does not perform bounds checking on the indices i0, i1, and i2. If any index is out of bounds, an invalid pointer may be dereferenced, which can lead to undefined behavior. Ensure that the indices are within the valid range for the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The row index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of rows. </td></tr>
    <tr><td class="paramname">i1</td><td>The column index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of columns. </td></tr>
    <tr><td class="paramname">i2</td><td>The third dimension index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of third dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the first element of the specified row, column, and third dimension. </dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a82abaad45b89619bffabec5b762804b6" name="a82abaad45b89619bffabec5b762804b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82abaad45b89619bffabec5b762804b6">&#9670;&#160;</a></span>at&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Span&lt; T &gt; OpenCVForUnity.CoreModule.Mat.at&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">params int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a Span&lt;T&gt; representing the first element in the specified coordinates of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the first element in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object at the specified coordinates (idx), and uses that pointer to create a Span&lt;T&gt;. The length of the Span&lt;T&gt; is determined by dividing the size of one element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> by the size of type <em>T</em> .</p>
<p><b>Note:</b> This method does not perform bounds checking on the provided indices. If any index is out of bounds, an invalid pointer may be dereferenced, which can lead to undefined behavior. Ensure that the indices are within the valid range for the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span&lt;T&gt;. Must be unmanaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range for each dimension of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Span&lt;T&gt; representing the first element at the specified coordinates in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a32150fedad53188ace78de63421702b1" name="a32150fedad53188ace78de63421702b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32150fedad53188ace78de63421702b1">&#9670;&#160;</a></span>channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.channels </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of matrix channels. </p>
<p>returns the number of matrix channels. </p>

</div>
</div>
<a id="a45319b179670bc99d25531b90b9677e7" name="a45319b179670bc99d25531b90b9677e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45319b179670bc99d25531b90b9677e7">&#9670;&#160;</a></span>checkVector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.checkVector </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>elemChannels</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elemChannels</td><td>Number of channels or number of columns the matrix should have. For a 2-D matrix, when the matrix has only 1 column, then it should have elemChannels channels; When the matrix has only 1 channel, then it should have elemChannels columns. For a 3-D matrix, it should have only one channel. Furthermore, if the number of planes is not one, then the number of rows within every plane has to be 1; if the number of rows within every plane is not 1, then the number of planes has to be 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the requirement is not satisfied. Otherwise, it returns the number of elements in the matrix.Note that an element may have multiple channels. </dd></dl>
<p>The following code demonstrates its usage for a 2-d matrix: </p><div class="fragment"><div class="line">cv::Mat mat(20, 1, CV_32FC2);</div>
<div class="line"><span class="keywordtype">int</span> n = mat.checkVector(2);</div>
<div class="line">CV_Assert(n == 20); <span class="comment">// mat has 20 elements</span></div>
<div class="line"> </div>
<div class="line">mat.create(20, 2, CV_32FC1);</div>
<div class="line">n = mat.checkVector(1);</div>
<div class="line">CV_Assert(n == -1); <span class="comment">// mat is neither a column nor a row vector</span></div>
<div class="line"> </div>
<div class="line">n = mat.checkVector(2);</div>
<div class="line">CV_Assert(n == 20); <span class="comment">// the 2 columns are considered as 1 element</span></div>
</div><!-- fragment --> <p>The following code demonstrates its usage for a 3-d matrix: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="#a7d1325b9e0d8749f1aeb01fa0603143f">dims</a>[] = { 1, 3, 5 }; <span class="comment">// 1 plane, every plane has 3 rows and 5 columns</span></div>
<div class="line">mat.create(3, <a class="code hl_function" href="#a7d1325b9e0d8749f1aeb01fa0603143f">dims</a>, CV_32FC1); <span class="comment">// for 3-d mat, it MUST have only 1 channel</span></div>
<div class="line">n = mat.checkVector(5); <span class="comment">// the 5 columns are considered as 1 element</span></div>
<div class="line">CV_Assert(n == 3);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> dims2[] = { 3, 1, 5 }; <span class="comment">// 3 planes, every plane has 1 row and 5 columns</span></div>
<div class="line">mat.create(3, dims2, CV_32FC1);</div>
<div class="line">n = mat.checkVector(5); <span class="comment">// the 5 columns are considered as 1 element</span></div>
<div class="line">CV_Assert(n == 3);</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a7d1325b9e0d8749f1aeb01fa0603143f"><div class="ttname"><a href="#a7d1325b9e0d8749f1aeb01fa0603143f">OpenCVForUnity.CoreModule.Mat.dims</a></div><div class="ttdeci">int dims()</div><div class="ttdef"><b>Definition</b> Mat.cs:846</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a65f4fb0ff44f1e760cc48ec5d576b2f0" name="a65f4fb0ff44f1e760cc48ec5d576b2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f4fb0ff44f1e760cc48ec5d576b2f0">&#9670;&#160;</a></span>checkVector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.checkVector </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>elemChannels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elemChannels</td><td>Number of channels or number of columns the matrix should have. For a 2-D matrix, when the matrix has only 1 column, then it should have elemChannels channels; When the matrix has only 1 channel, then it should have elemChannels columns. For a 3-D matrix, it should have only one channel. Furthermore, if the number of planes is not one, then the number of rows within every plane has to be 1; if the number of rows within every plane is not 1, then the number of planes has to be 1. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth the matrix should have. Set it to -1 when any depth is fine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the requirement is not satisfied. Otherwise, it returns the number of elements in the matrix.Note that an element may have multiple channels. </dd></dl>
<p>The following code demonstrates its usage for a 2-d matrix: </p><div class="fragment"><div class="line">cv::Mat mat(20, 1, CV_32FC2);</div>
<div class="line"><span class="keywordtype">int</span> n = mat.checkVector(2);</div>
<div class="line">CV_Assert(n == 20); <span class="comment">// mat has 20 elements</span></div>
<div class="line"> </div>
<div class="line">mat.create(20, 2, CV_32FC1);</div>
<div class="line">n = mat.checkVector(1);</div>
<div class="line">CV_Assert(n == -1); <span class="comment">// mat is neither a column nor a row vector</span></div>
<div class="line"> </div>
<div class="line">n = mat.checkVector(2);</div>
<div class="line">CV_Assert(n == 20); <span class="comment">// the 2 columns are considered as 1 element</span></div>
</div><!-- fragment --> <p>The following code demonstrates its usage for a 3-d matrix: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="#a7d1325b9e0d8749f1aeb01fa0603143f">dims</a>[] = { 1, 3, 5 }; <span class="comment">// 1 plane, every plane has 3 rows and 5 columns</span></div>
<div class="line">mat.create(3, <a class="code hl_function" href="#a7d1325b9e0d8749f1aeb01fa0603143f">dims</a>, CV_32FC1); <span class="comment">// for 3-d mat, it MUST have only 1 channel</span></div>
<div class="line">n = mat.checkVector(5); <span class="comment">// the 5 columns are considered as 1 element</span></div>
<div class="line">CV_Assert(n == 3);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> dims2[] = { 3, 1, 5 }; <span class="comment">// 3 planes, every plane has 1 row and 5 columns</span></div>
<div class="line">mat.create(3, dims2, CV_32FC1);</div>
<div class="line">n = mat.checkVector(5); <span class="comment">// the 5 columns are considered as 1 element</span></div>
<div class="line">CV_Assert(n == 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6118bdf829063d8563b5b08446867342" name="a6118bdf829063d8563b5b08446867342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6118bdf829063d8563b5b08446867342">&#9670;&#160;</a></span>checkVector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.checkVector </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>elemChannels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>requireContinuous</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elemChannels</td><td>Number of channels or number of columns the matrix should have. For a 2-D matrix, when the matrix has only 1 column, then it should have elemChannels channels; When the matrix has only 1 channel, then it should have elemChannels columns. For a 3-D matrix, it should have only one channel. Furthermore, if the number of planes is not one, then the number of rows within every plane has to be 1; if the number of rows within every plane is not 1, then the number of planes has to be 1. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth the matrix should have. Set it to -1 when any depth is fine. </td></tr>
    <tr><td class="paramname">requireContinuous</td><td>Set it to true to require the matrix to be continuous </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the requirement is not satisfied. Otherwise, it returns the number of elements in the matrix.Note that an element may have multiple channels. </dd></dl>
<p>The following code demonstrates its usage for a 2-d matrix: </p><div class="fragment"><div class="line">cv::Mat mat(20, 1, CV_32FC2);</div>
<div class="line"><span class="keywordtype">int</span> n = mat.checkVector(2);</div>
<div class="line">CV_Assert(n == 20); <span class="comment">// mat has 20 elements</span></div>
<div class="line"> </div>
<div class="line">mat.create(20, 2, CV_32FC1);</div>
<div class="line">n = mat.checkVector(1);</div>
<div class="line">CV_Assert(n == -1); <span class="comment">// mat is neither a column nor a row vector</span></div>
<div class="line"> </div>
<div class="line">n = mat.checkVector(2);</div>
<div class="line">CV_Assert(n == 20); <span class="comment">// the 2 columns are considered as 1 element</span></div>
</div><!-- fragment --> <p>The following code demonstrates its usage for a 3-d matrix: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="#a7d1325b9e0d8749f1aeb01fa0603143f">dims</a>[] = { 1, 3, 5 }; <span class="comment">// 1 plane, every plane has 3 rows and 5 columns</span></div>
<div class="line">mat.create(3, <a class="code hl_function" href="#a7d1325b9e0d8749f1aeb01fa0603143f">dims</a>, CV_32FC1); <span class="comment">// for 3-d mat, it MUST have only 1 channel</span></div>
<div class="line">n = mat.checkVector(5); <span class="comment">// the 5 columns are considered as 1 element</span></div>
<div class="line">CV_Assert(n == 3);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> dims2[] = { 3, 1, 5 }; <span class="comment">// 3 planes, every plane has 1 row and 5 columns</span></div>
<div class="line">mat.create(3, dims2, CV_32FC1);</div>
<div class="line">n = mat.checkVector(5); <span class="comment">// the 5 columns are considered as 1 element</span></div>
<div class="line">CV_Assert(n == 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a727f0d641cd857acdd14bfce16c3aa54" name="a727f0d641cd857acdd14bfce16c3aa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727f0d641cd857acdd14bfce16c3aa54">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a full copy of the array and the underlying data. </p>
<p>The method creates a full copy of the array. The original step[] is not taken into account. So, the array copy is a continuous array occupying <a class="el" href="#ac2049918ee53b9b95746cbec329515bd" title="Returns the total number of array elements.">total()</a>*elemSize() bytes. </p>

</div>
</div>
<a id="a506138d3fb9e7f4ba618b93e0455fa86" name="a506138d3fb9e7f4ba618b93e0455fa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506138d3fb9e7f4ba618b93e0455fa86">&#9670;&#160;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.col </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified matrix column. </p>
<p>The method makes a new header for the specified matrix column and returns it. This is an O(1) operation, regardless of the matrix size.The underlying data of the new matrix is shared with the original matrix.See also the <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A 0-based column index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3d51a7584b20dbcac11949f0540f9f8" name="af3d51a7584b20dbcac11949f0540f9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d51a7584b20dbcac11949f0540f9f8">&#9670;&#160;</a></span>colRange() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.colRange </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified column span. </p>
<p>The method makes a new header for the specified column span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a> , this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> structure containing both the start and the end indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3619e6f5d94467149f4cff25f2f95ad" name="ae3619e6f5d94467149f4cff25f2f95ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3619e6f5d94467149f4cff25f2f95ad">&#9670;&#160;</a></span>colRange() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.colRange </td>
          <td>(</td>
          <td class="paramtype">in(int start, int end)</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified column span. </p>
<p>The method makes a new header for the specified column span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a> , this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> structure containing both the start and the end indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0ebb50b3a9213bad850944413013a90" name="ab0ebb50b3a9213bad850944413013a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ebb50b3a9213bad850944413013a90">&#9670;&#160;</a></span>colRange() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.colRange </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startcol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>endcol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified column span. </p>
<p>The method makes a new header for the specified column span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a> , this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startcol</td><td>An inclusive 0-based start index of the column span. </td></tr>
    <tr><td class="paramname">endcol</td><td>An exclusive 0-based ending index of the column span. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5716f7648a36e01b51c1107b1a1d5c24" name="a5716f7648a36e01b51c1107b1a1d5c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5716f7648a36e01b51c1107b1a1d5c24">&#9670;&#160;</a></span>colRange() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.colRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified column span. </p>
<p>The method makes a new header for the specified column span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a> , this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> structure containing both the start and the end indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6b006c4c77d88cbeb2463f09ead6fb" name="afb6b006c4c77d88cbeb2463f09ead6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6b006c4c77d88cbeb2463f09ead6fb">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.cols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of columns in the matrix; -1 when the matrix has more than 2 dimensions </p>

</div>
</div>
<a id="a8b83526a304f477005ee15e26924c222" name="a8b83526a304f477005ee15e26924c222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b83526a304f477005ee15e26924c222">&#9670;&#160;</a></span>convertTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rtype</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an array to another data type with optional scaling. </p>
<p>The method converts source pixel values to the target data type. saturate_cast&lt;&gt; is applied at the end to avoid possible overflows: </p>
<p class="formulaDsp">
\[m(x,y) = saturate \_ cast&lt;rType&gt;( \alpha (*this)(x,y) +  \beta )\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Output matrix; if it does not have a proper size or type before the operation, it is reallocated. </td></tr>
    <tr><td class="paramname">rtype</td><td>Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88d994b1fde7037d5d10bb417b0066f2" name="a88d994b1fde7037d5d10bb417b0066f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d994b1fde7037d5d10bb417b0066f2">&#9670;&#160;</a></span>convertTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an array to another data type with optional scaling. </p>
<p>The method converts source pixel values to the target data type. saturate_cast&lt;&gt; is applied at the end to avoid possible overflows:</p>
<p class="formulaDsp">
\[m(x,y) = saturate \_ cast&lt;rType&gt;( \alpha (*this)(x,y) +  \beta )\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Output matrix; if it does not have a proper size or type before the operation, it is reallocated. </td></tr>
    <tr><td class="paramname">rtype</td><td>Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input. </td></tr>
    <tr><td class="paramname">alpha</td><td>Optional scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae89d02605d9843365941fa911908a7f1" name="ae89d02605d9843365941fa911908a7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d02605d9843365941fa911908a7f1">&#9670;&#160;</a></span>convertTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an array to another data type with optional scaling. </p>
<p>The method converts source pixel values to the target data type. saturate_cast&lt;&gt; is applied at the end to avoid possible overflows:</p>
<p class="formulaDsp">
\[m(x,y) = saturate \_ cast&lt;rType&gt;( \alpha (*this)(x,y) +  \beta )\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Output matrix; if it does not have a proper size or type before the operation, it is reallocated. </td></tr>
    <tr><td class="paramname">rtype</td><td>Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input. </td></tr>
    <tr><td class="paramname">alpha</td><td>Optional scale factor. </td></tr>
    <tr><td class="paramname">beta</td><td>Optional delta added to the scaled values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f6547e08b4259c708ee85a5015ce35e" name="a0f6547e08b4259c708ee85a5015ce35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6547e08b4259c708ee85a5015ce35e">&#9670;&#160;</a></span>copySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.copySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>internal use function; properly re-allocates _size, _step arrays </p>

</div>
</div>
<a id="a2acada63cfb833b34c63965b16be65d6" name="a2acada63cfb833b34c63965b16be65d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acada63cfb833b34c63965b16be65d6">&#9670;&#160;</a></span>copyTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the matrix to another one. </p>
<p>The method copies the matrix data to another matrix. Before copying the data, the method invokes : </p>
<div class="fragment"><div class="line">m.create(this-&gt;<a class="code hl_function" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>(), this-&gt;<a class="code hl_function" href="#ab50fde5c175a561068025df6b35363f1">type</a>());</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_ab50fde5c175a561068025df6b35363f1"><div class="ttname"><a href="#ab50fde5c175a561068025df6b35363f1">OpenCVForUnity.CoreModule.Mat.type</a></div><div class="ttdeci">int type()</div><div class="ttdoc">Returns the type of a matrix element.</div><div class="ttdef"><b>Definition</b> Mat.cs:2605</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_abd78d83d7206bf4c4ee61850bf4d0375"><div class="ttname"><a href="#abd78d83d7206bf4c4ee61850bf4d0375">OpenCVForUnity.CoreModule.Mat.size</a></div><div class="ttdeci">Size size()</div><div class="ttdef"><b>Definition</b> Mat.cs:2354</div></div>
</div><!-- fragment --> <p>so that the destination matrix is reallocated if needed. While m.copyTo(m); works flawlessly, the function does not handle the case of a partial overlap between the source and the destination matrices.</p>
<p>When the operation mask is specified, if the <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create</a> call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Destination matrix. If it does not have a proper size or type before the operation, it is reallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f9e5ee6218e000f2e294edd3db5b9b0" name="a7f9e5ee6218e000f2e294edd3db5b9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9e5ee6218e000f2e294edd3db5b9b0">&#9670;&#160;</a></span>copyTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the matrix to another one. </p>
<p>The method copies the matrix data to another matrix. Before copying the data, the method invokes : </p>
<div class="fragment"><div class="line">m.create(this-&gt;<a class="code hl_function" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>(), this-&gt;<a class="code hl_function" href="#ab50fde5c175a561068025df6b35363f1">type</a>());</div>
</div><!-- fragment --> <p>so that the destination matrix is reallocated if needed. While m.copyTo(m); works flawlessly, the function does not handle the case of a partial overlap between the source and the destination matrices.</p>
<p>When the operation mask is specified, if the <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create</a> call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Destination matrix. If it does not have a proper size or type before the operation, it is reallocated. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied.The mask has to be of type CV_8U and can have 1 or multiple channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49bc90c913081151e338dfc1b3d4b0f7" name="a49bc90c913081151e338dfc1b3d4b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bc90c913081151e338dfc1b3d4b0f7">&#9670;&#160;</a></span>create() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.create </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates new array data if needed. </p>
<p>This is one of the key <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol>
<li>
If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling <a class="el" href="#a034d3e2b4ce0d37e7058ce55e8b1899b" title="Decrements the reference counter and deallocates the matrix if needed.">Mat.release</a>. </li>
<li>
Initialize the new header. </li>
<li>
Allocate the new data of <a class="el" href="#ac2049918ee53b9b95746cbec329515bd" title="Returns the total number of array elements.">total()</a>*elemSize() bytes. </li>
<li>
Allocate the new, associated with the data, reference counter and set it to 1. </li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray(color.<a class="code hl_function" href="#a9877819470ffa970b88727037342d458">rows</a>, color.<a class="code hl_function" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, color.<a class="code hl_function" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a>());</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html"><div class="ttname"><a href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">OpenCVForUnity.CoreModule.Mat</a></div><div class="ttdoc">n-dimensional dense array class</div><div class="ttdef"><b>Definition</b> Mat_ValueTuple.cs:11</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a3ca862341a7b26b18e96e41933ee9a49"><div class="ttname"><a href="#a3ca862341a7b26b18e96e41933ee9a49">OpenCVForUnity.CoreModule.Mat.depth</a></div><div class="ttdeci">int depth()</div><div class="ttdoc">Returns the depth of a matrix element.</div><div class="ttdef"><b>Definition</b> Mat.cs:1289</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a9877819470ffa970b88727037342d458"><div class="ttname"><a href="#a9877819470ffa970b88727037342d458">OpenCVForUnity.CoreModule.Mat.rows</a></div><div class="ttdeci">int rows()</div><div class="ttdef"><b>Definition</b> Mat.cs:2243</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_aa72bf9d9607cbb0af6e4e3f11bd8b9ba"><div class="ttname"><a href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">OpenCVForUnity.CoreModule.Mat.Mat</a></div><div class="ttdeci">Mat(IntPtr addr)</div><div class="ttdef"><b>Definition</b> Mat.cs:64</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_afb6b006c4c77d88cbeb2463f09ead6fb"><div class="ttname"><a href="#afb6b006c4c77d88cbeb2463f09ead6fb">OpenCVForUnity.CoreModule.Mat.cols</a></div><div class="ttdeci">int cols()</div><div class="ttdef"><b>Definition</b> Mat.cs:861</div></div>
</div><!-- fragment --> <p>you can simply write: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray;</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>because cvtColor, as well as the most of OpenCV functions, calls <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create()</a> for the output array internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative new matrix size specification: Size(cols, rows) </td></tr>
    <tr><td class="paramname">type</td><td>New matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6313a0050006863c58044802f2acb683" name="a6313a0050006863c58044802f2acb683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6313a0050006863c58044802f2acb683">&#9670;&#160;</a></span>create() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.create </td>
          <td>(</td>
          <td class="paramtype">in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates new array data if needed. </p>
<p>This is one of the key <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol>
<li>
If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling <a class="el" href="#a034d3e2b4ce0d37e7058ce55e8b1899b" title="Decrements the reference counter and deallocates the matrix if needed.">Mat.release</a>. </li>
<li>
Initialize the new header. </li>
<li>
Allocate the new data of <a class="el" href="#ac2049918ee53b9b95746cbec329515bd" title="Returns the total number of array elements.">total()</a>*elemSize() bytes. </li>
<li>
Allocate the new, associated with the data, reference counter and set it to 1. </li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray(color.<a class="code hl_function" href="#a9877819470ffa970b88727037342d458">rows</a>, color.<a class="code hl_function" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, color.<a class="code hl_function" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a>());</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>you can simply write: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray;</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>because cvtColor, as well as the most of OpenCV functions, calls <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create()</a> for the output array internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative new matrix size specification: Size(cols, rows) </td></tr>
    <tr><td class="paramname">type</td><td>New matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18f5d2799293f7fe5219451eb9ac7f1" name="ab18f5d2799293f7fe5219451eb9ac7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18f5d2799293f7fe5219451eb9ac7f1">&#9670;&#160;</a></span>create() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.create </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates new array data if needed. </p>
<p>This is one of the key <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol>
<li>
If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling <a class="el" href="#a034d3e2b4ce0d37e7058ce55e8b1899b" title="Decrements the reference counter and deallocates the matrix if needed.">Mat.release</a>. </li>
<li>
Initialize the new header. </li>
<li>
Allocate the new data of <a class="el" href="#ac2049918ee53b9b95746cbec329515bd" title="Returns the total number of array elements.">total()</a>*elemSize() bytes. </li>
<li>
Allocate the new, associated with the data, reference counter and set it to 1. </li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray(color.<a class="code hl_function" href="#a9877819470ffa970b88727037342d458">rows</a>, color.<a class="code hl_function" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, color.<a class="code hl_function" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a>());</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>you can simply write: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray;</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>because cvtColor, as well as the most of OpenCV functions, calls <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create()</a> for the output array internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>New number of rows. </td></tr>
    <tr><td class="paramname">cols</td><td>New number of columns. </td></tr>
    <tr><td class="paramname">type</td><td>New matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a085b7a8e4934f0a520f1e7e594654495" name="a085b7a8e4934f0a520f1e7e594654495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085b7a8e4934f0a520f1e7e594654495">&#9670;&#160;</a></span>create() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.create </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates new array data if needed. </p>
<p>This is one of the key <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol>
<li>
If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling <a class="el" href="#a034d3e2b4ce0d37e7058ce55e8b1899b" title="Decrements the reference counter and deallocates the matrix if needed.">Mat.release</a>. </li>
<li>
Initialize the new header. </li>
<li>
Allocate the new data of <a class="el" href="#ac2049918ee53b9b95746cbec329515bd" title="Returns the total number of array elements.">total()</a>*elemSize() bytes. </li>
<li>
Allocate the new, associated with the data, reference counter and set it to 1. </li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray(color.<a class="code hl_function" href="#a9877819470ffa970b88727037342d458">rows</a>, color.<a class="code hl_function" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, color.<a class="code hl_function" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a>());</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>you can simply write: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray;</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>because cvtColor, as well as the most of OpenCV functions, calls <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create()</a> for the output array internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Array of integers specifying a new array shape. </td></tr>
    <tr><td class="paramname">type</td><td>New matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada5113257c73c9f0fe2893056b0eb8f1" name="ada5113257c73c9f0fe2893056b0eb8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5113257c73c9f0fe2893056b0eb8f1">&#9670;&#160;</a></span>create() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates new array data if needed. </p>
<p>This is one of the key <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol>
<li>
If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling <a class="el" href="#a034d3e2b4ce0d37e7058ce55e8b1899b" title="Decrements the reference counter and deallocates the matrix if needed.">Mat.release</a>. </li>
<li>
Initialize the new header. </li>
<li>
Allocate the new data of <a class="el" href="#ac2049918ee53b9b95746cbec329515bd" title="Returns the total number of array elements.">total()</a>*elemSize() bytes. </li>
<li>
Allocate the new, associated with the data, reference counter and set it to 1. </li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray(color.<a class="code hl_function" href="#a9877819470ffa970b88727037342d458">rows</a>, color.<a class="code hl_function" href="#afb6b006c4c77d88cbeb2463f09ead6fb">cols</a>, color.<a class="code hl_function" href="#a3ca862341a7b26b18e96e41933ee9a49">depth</a>());</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>you can simply write: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> color;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_function" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat</a> gray;</div>
<div class="line">cvtColor(color, gray, COLOR_BGR2GRAY);</div>
</div><!-- fragment --> <p>because cvtColor, as well as the most of OpenCV functions, calls <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create()</a> for the output array internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative new matrix size specification: Size(cols, rows) </td></tr>
    <tr><td class="paramname">type</td><td>New matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8b53dbbdaf1491f0cc3863f5e052885" name="ad8b53dbbdaf1491f0cc3863f5e052885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b53dbbdaf1491f0cc3863f5e052885">&#9670;&#160;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a cross-product of two 3-element vectors. </p>
<p>The method computes a cross-product of two 3-element vectors. The vectors must be 3-element floating-point vectors of the same shape and size. The result is another 3-element vector of the same shape and type as operands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Another cross-product operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8b372e9c678fe6c2e3d0fa3d7d43951" name="aa8b372e9c678fe6c2e3d0fa3d7d43951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b372e9c678fe6c2e3d0fa3d7d43951">&#9670;&#160;</a></span>dataAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long OpenCVForUnity.CoreModule.Mat.dataAddr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first pointer address of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the first pointer address of <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> data. </dd></dl>

</div>
</div>
<a id="a3ca862341a7b26b18e96e41933ee9a49" name="a3ca862341a7b26b18e96e41933ee9a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca862341a7b26b18e96e41933ee9a49">&#9670;&#160;</a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.depth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the depth of a matrix element. </p>
<p>The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-bit signed element array, the method returns CV_16S. A complete list of matrix types contains the following values: </p><ul>
<li>
CV_8U - 8-bit unsigned integers ( 0..255 ) </li>
<li>
CV_8S - 8-bit signed integers ( -128..127 ) </li>
<li>
CV_16U - 16-bit unsigned integers ( 0..65535 ) </li>
<li>
CV_16S - 16-bit signed integers ( -32768..32767 ) </li>
<li>
CV_32S - 32-bit signed integers ( -2147483648..2147483647 ) </li>
<li>
CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN ) </li>
<li>
CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN ) </li>
</ul>

</div>
</div>
<a id="a5493cbddeaf7b18dfb15cd983e027be3" name="a5493cbddeaf7b18dfb15cd983e027be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5493cbddeaf7b18dfb15cd983e027be3">&#9670;&#160;</a></span>diag() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.diag </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a diagonal from a matrix. </p>
<p>The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-column matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, this is an O(1) operation. </p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m = (Mat_&lt;int&gt;(3,3) &lt;&lt;</div>
<div class="line">            1,2,3,</div>
<div class="line">            4,5,6,</div>
<div class="line">            7,8,9);</div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> d0 = m.<a class="code hl_function" href="#a26cdf2367d666a83f6af334d01475672">diag</a>(0);</div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> d1 = m.<a class="code hl_function" href="#a26cdf2367d666a83f6af334d01475672">diag</a>(1);</div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> d_1 = m.<a class="code hl_function" href="#a26cdf2367d666a83f6af334d01475672">diag</a>(-1);</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a26cdf2367d666a83f6af334d01475672"><div class="ttname"><a href="#a26cdf2367d666a83f6af334d01475672">OpenCVForUnity.CoreModule.Mat.diag</a></div><div class="ttdeci">Mat diag(int d)</div><div class="ttdoc">Extracts a diagonal from a matrix.</div><div class="ttdef"><b>Definition</b> Mat.cs:1346</div></div>
</div><!-- fragment --><p> The resulting matrices are: </p><div class="fragment"><div class="line">d0 =</div>
<div class="line">  [1;</div>
<div class="line">   5;</div>
<div class="line">   9]</div>
<div class="line">d1 =</div>
<div class="line">  [2;</div>
<div class="line">   6]</div>
<div class="line">d_1 =</div>
<div class="line">  [4;</div>
<div class="line">   8]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a26cdf2367d666a83f6af334d01475672" name="a26cdf2367d666a83f6af334d01475672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cdf2367d666a83f6af334d01475672">&#9670;&#160;</a></span>diag() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.diag </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a diagonal from a matrix. </p>
<p>The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-column matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Index of the diagonal, with the following values: <ul>
<li>
<code>d=0</code> is the main diagonal. </li>
<li>
<code>d&lt;0</code> is a diagonal from the lower half. For example, <code>d=-1</code> means the diagonal is set immediately below the main one. </li>
<li>
<code>d&gt;0</code> is a diagonal from the upper half. For example, <code>d=1</code> means the diagonal is set immediately above the main one. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m = (Mat_&lt;int&gt;(3,3) &lt;&lt;</div>
<div class="line">            1,2,3,</div>
<div class="line">            4,5,6,</div>
<div class="line">            7,8,9);</div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> d0 = m.<a class="code hl_function" href="#a26cdf2367d666a83f6af334d01475672">diag</a>(0);</div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> d1 = m.<a class="code hl_function" href="#a26cdf2367d666a83f6af334d01475672">diag</a>(1);</div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> d_1 = m.<a class="code hl_function" href="#a26cdf2367d666a83f6af334d01475672">diag</a>(-1);</div>
</div><!-- fragment --><p> The resulting matrices are: </p><div class="fragment"><div class="line">d0 =</div>
<div class="line">  [1;</div>
<div class="line">   5;</div>
<div class="line">   9]</div>
<div class="line">d1 =</div>
<div class="line">  [2;</div>
<div class="line">   6]</div>
<div class="line">d_1 =</div>
<div class="line">  [4;</div>
<div class="line">   8]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abc55b2c3ac6281bccf89d57d5eb2c7bb" name="abc55b2c3ac6281bccf89d57d5eb2c7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc55b2c3ac6281bccf89d57d5eb2c7bb">&#9670;&#160;</a></span>diag() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a diagonal matrix </p>
<p>The method creates a square diagonal matrix from specified main diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>One-dimensional matrix that represents the main diagonal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d1325b9e0d8749f1aeb01fa0603143f" name="a7d1325b9e0d8749f1aeb01fa0603143f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1325b9e0d8749f1aeb01fa0603143f">&#9670;&#160;</a></span>dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.dims </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the matrix dimensionality </p>

</div>
</div>
<a id="af3b146269cffa68caa39cf512e869567" name="af3b146269cffa68caa39cf512e869567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b146269cffa68caa39cf512e869567">&#9670;&#160;</a></span>Dispose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override void OpenCVForUnity.CoreModule.Mat.Dispose </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>disposing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates the matrix data and releases resources. </p>
<p>This method decrements the reference counter associated with the matrix data. If the reference counter reaches zero, the matrix data is deallocated, and the data and reference counter pointers are set to null. It is generally not necessary to call this method manually, as it is automatically invoked in the destructor or by any other method that changes the data pointer. The reference counter decrement and check for zero is an atomic operation on supported platforms, ensuring thread safety when operating on the same matrices asynchronously. </p>

<p>Reimplemented from <a class="el" href="class_open_c_v_for_unity_1_1_disposable_open_c_v_object.html#af60676d60f2ec562a162ff126628c8d5">OpenCVForUnity.DisposableOpenCVObject</a>.</p>

</div>
</div>
<a id="a87394e8979587ef2f5cf9a062ba2a62a" name="a87394e8979587ef2f5cf9a062ba2a62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87394e8979587ef2f5cf9a062ba2a62a">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenCVForUnity.CoreModule.Mat.dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a dot-product of two vectors. </p>
<p>The method computes a dot-product of two matrices. If the matrices are not single-column or single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D vectors. The vectors must have the same size and type. If the matrices have more than one channel, the dot products from all the channels are summed together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Another dot-product operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a489ff76fb92b63ba47628f0f568499eb" name="a489ff76fb92b63ba47628f0f568499eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489ff76fb92b63ba47628f0f568499eb">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string OpenCVForUnity.CoreModule.Mat.dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of the visualized matrix in String format. </p>
<p>This method returns the matrix elements in String format, formatted in a human-readable format. This is useful for debugging to quickly visualize the matrix contents. Only works with two-dimensional <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the contents of the visualized matrix in String format. </dd></dl>

</div>
</div>
<a id="a2df92b8f53f26ad2a6b2a7654a153bcc" name="a2df92b8f53f26ad2a6b2a7654a153bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df92b8f53f26ad2a6b2a7654a153bcc">&#9670;&#160;</a></span>elemSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long OpenCVForUnity.CoreModule.Mat.elemSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matrix element size in bytes. </p>
<p>The method returns the matrix element size in bytes. For example, if the matrix type is CV_16SC3, the method returns 3 * sizeof(short) or 6. </p>

</div>
</div>
<a id="a725885019d65746f656ff5697b00033f" name="a725885019d65746f656ff5697b00033f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725885019d65746f656ff5697b00033f">&#9670;&#160;</a></span>elemSize1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long OpenCVForUnity.CoreModule.Mat.elemSize1 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of each matrix element channel in bytes. </p>
<p>The method returns the matrix element channel size in bytes, that is, it ignores the number of channels. For example, if the matrix type is CV_16SC3, the method returns sizeof(short) or 2. </p>

</div>
</div>
<a id="a21bd1b40a4d9b9b1c0df4deb795b5295" name="a21bd1b40a4d9b9b1c0df4deb795b5295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bd1b40a4d9b9b1c0df4deb795b5295">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenCVForUnity.CoreModule.Mat.empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the array has no elements. </p>
<p>The method returns true if <code><a class="el" href="#ac2049918ee53b9b95746cbec329515bd" title="Returns the total number of array elements.">Mat.total()</a> == 0</code> or if <code>Mat::data == null</code>. Because of <code>pop_back()</code> and <code>resize()</code> methods, <code>M.total() == 0</code> does not imply that <code>M.data == null</code>. </p>

</div>
</div>
<a id="ad3a15f8376b1d95d29f38d0615f43050" name="ad3a15f8376b1d95d29f38d0615f43050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a15f8376b1d95d29f38d0615f43050">&#9670;&#160;</a></span>eye() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.eye </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity matrix of the specified size and type. </p>
<p>The method returns a Matlab-style identity matrix initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Similarly to <a class="el" href="#a87787208caf135e9a0530b74c9c2633d" title="Returns an array of all 1&#39;s of the specified size and type.">Mat.ones</a>, you can use a scale operation to create a scaled identity matrix efficiently: </p>
<div class="fragment"><div class="line"><span class="comment">// make a 4x4 diagonal matrix with 0.1&#39;s on the diagonal.</span></div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a789d7a929b3e052d35581cc7f19b1845">Mat::eye</a>(4, 4, CV_32F)*0.1;</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a789d7a929b3e052d35581cc7f19b1845"><div class="ttname"><a href="#a789d7a929b3e052d35581cc7f19b1845">OpenCVForUnity.CoreModule.Mat.eye</a></div><div class="ttdeci">static Mat eye(int rows, int cols, int type)</div><div class="ttdoc">Returns an identity matrix of the specified size and type.</div><div class="ttdef"><b>Definition</b> Mat.cs:1526</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, identity matrix will be initialized only for the first channel, the others will be set to 0's </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative matrix size specification as Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a725cd7bad4718524c64a9a113b103a13" name="a725cd7bad4718524c64a9a113b103a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725cd7bad4718524c64a9a113b103a13">&#9670;&#160;</a></span>eye() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.eye </td>
          <td>(</td>
          <td class="paramtype">in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity matrix of the specified size and type. </p>
<p>The method returns a Matlab-style identity matrix initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Similarly to <a class="el" href="#a87787208caf135e9a0530b74c9c2633d" title="Returns an array of all 1&#39;s of the specified size and type.">Mat.ones</a>, you can use a scale operation to create a scaled identity matrix efficiently: </p>
<div class="fragment"><div class="line"><span class="comment">// make a 4x4 diagonal matrix with 0.1&#39;s on the diagonal.</span></div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a789d7a929b3e052d35581cc7f19b1845">Mat::eye</a>(4, 4, CV_32F)*0.1;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, identity matrix will be initialized only for the first channel, the others will be set to 0's </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative matrix size specification as Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a789d7a929b3e052d35581cc7f19b1845" name="a789d7a929b3e052d35581cc7f19b1845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789d7a929b3e052d35581cc7f19b1845">&#9670;&#160;</a></span>eye() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.eye </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity matrix of the specified size and type. </p>
<p>The method returns a Matlab-style identity matrix initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Similarly to <a class="el" href="#a87787208caf135e9a0530b74c9c2633d" title="Returns an array of all 1&#39;s of the specified size and type.">Mat.ones</a>, you can use a scale operation to create a scaled identity matrix efficiently: </p>
<div class="fragment"><div class="line"><span class="comment">// make a 4x4 diagonal matrix with 0.1&#39;s on the diagonal.</span></div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a789d7a929b3e052d35581cc7f19b1845">Mat::eye</a>(4, 4, CV_32F)*0.1;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, identity matrix will be initialized only for the first channel, the others will be set to 0's </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a284bd6237e8afb19b2ccd266630bb450" name="a284bd6237e8afb19b2ccd266630bb450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284bd6237e8afb19b2ccd266630bb450">&#9670;&#160;</a></span>eye() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.eye </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity matrix of the specified size and type. </p>
<p>The method returns a Matlab-style identity matrix initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Similarly to <a class="el" href="#a87787208caf135e9a0530b74c9c2633d" title="Returns an array of all 1&#39;s of the specified size and type.">Mat.ones</a>, you can use a scale operation to create a scaled identity matrix efficiently: </p>
<div class="fragment"><div class="line"><span class="comment">// make a 4x4 diagonal matrix with 0.1&#39;s on the diagonal.</span></div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a789d7a929b3e052d35581cc7f19b1845">Mat::eye</a>(4, 4, CV_32F)*0.1;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, identity matrix will be initialized only for the first channel, the others will be set to 0's </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative matrix size specification as Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7525c41bb48e1f00560d6d072a8efe96" name="a7525c41bb48e1f00560d6d072a8efe96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7525c41bb48e1f00560d6d072a8efe96">&#9670;&#160;</a></span>get() <span class="overload">[1/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double[] OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the element values from the matrix at the specified row and column, returning them as an array of double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of double values representing the matrix element(s) at the specified row and column. The length of the array corresponds to the number of channels in the matrix at the specified location. If the read operation fails, returns null. </dd></dl>
<p>This method reads the element values at the specified row and column in the matrix and returns them as double values. Regardless of the matrix's actual data type, the values are cast to double. The size of the returned array depends on the number of channels in the matrix. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if an error occurs while retrieving the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf4ab7b8b3837945ec745b9cd716c4f4" name="acf4ab7b8b3837945ec745b9cd716c4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4ab7b8b3837945ec745b9cd716c4f4">&#9670;&#160;</a></span>get() <span class="overload">[2/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a byte array from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified byte array from the matrix at the given row and column. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c49506c0fefa5c37493a8911d269eb" name="a04c49506c0fefa5c37493a8911d269eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c49506c0fefa5c37493a8911d269eb">&#9670;&#160;</a></span>get() <span class="overload">[3/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of byte values from the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of byte values from the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77e5a67212f88d7d77fb6d43b2504c85" name="a77e5a67212f88d7d77fb6d43b2504c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e5a67212f88d7d77fb6d43b2504c85">&#9670;&#160;</a></span>get() <span class="overload">[4/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of byte values from the matrix at the given row and column, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of byte values from the matrix at the given row and column, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae779595270008b59c79d4d3170b174b6" name="ae779595270008b59c79d4d3170b174b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae779595270008b59c79d4d3170b174b6">&#9670;&#160;</a></span>get() <span class="overload">[5/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a double array from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The double array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified double array from the matrix at the given row and column. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_64F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_64F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a046487a4740bf4ad0966e8e795cf99b7" name="a046487a4740bf4ad0966e8e795cf99b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046487a4740bf4ad0966e8e795cf99b7">&#9670;&#160;</a></span>get() <span class="overload">[6/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of double values from the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The double array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of double values from the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_64F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_64F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef39668fb892353bb376ba142ac6be7b" name="aef39668fb892353bb376ba142ac6be7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef39668fb892353bb376ba142ac6be7b">&#9670;&#160;</a></span>get() <span class="overload">[7/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of double values from the matrix at the given row and column, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The double array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of double values from the matrix at the given row and column, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_64F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_64F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bc39ebf9af120b931ec051726d9b207" name="a1bc39ebf9af120b931ec051726d9b207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc39ebf9af120b931ec051726d9b207">&#9670;&#160;</a></span>get() <span class="overload">[8/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a float array from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The float array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified float array from the matrix at the given row and column. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab54a52deba32a3f2d0f4fa63452c5198" name="ab54a52deba32a3f2d0f4fa63452c5198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54a52deba32a3f2d0f4fa63452c5198">&#9670;&#160;</a></span>get() <span class="overload">[9/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of float values from the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The float array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of float values from the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f8bb0a83642e60ce2f869d4c26ca27f" name="a4f8bb0a83642e60ce2f869d4c26ca27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8bb0a83642e60ce2f869d4c26ca27f">&#9670;&#160;</a></span>get() <span class="overload">[10/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of float values from the matrix at the given row and column, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The float array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of float values from the matrix at the given row and column, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c5ae4fa818026cd60a795ccb903c89" name="ad2c5ae4fa818026cd60a795ccb903c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c5ae4fa818026cd60a795ccb903c89">&#9670;&#160;</a></span>get() <span class="overload">[11/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an int array from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The int array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified int array from the matrix at the given row and column. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad971b8a17c7fe69a8813d75f62df58eb" name="ad971b8a17c7fe69a8813d75f62df58eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad971b8a17c7fe69a8813d75f62df58eb">&#9670;&#160;</a></span>get() <span class="overload">[12/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of int values from the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The int array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of int values from the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32S</code>. &lt;/exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eeb0d140bcf4c4472d91696dab527f2" name="a0eeb0d140bcf4c4472d91696dab527f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eeb0d140bcf4c4472d91696dab527f2">&#9670;&#160;</a></span>get() <span class="overload">[13/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of int values from the matrix at the given row and column, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The int array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of int values from the matrix at the given row and column, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af59c958963a17765ea7e42c8c5ba0ce8" name="af59c958963a17765ea7e42c8c5ba0ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59c958963a17765ea7e42c8c5ba0ce8">&#9670;&#160;</a></span>get() <span class="overload">[14/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a sbyte array from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified sbyte array from the matrix at the given row and column. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ce6ec43c8537b19cc0ae7768048faea" name="a5ce6ec43c8537b19cc0ae7768048faea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce6ec43c8537b19cc0ae7768048faea">&#9670;&#160;</a></span>get() <span class="overload">[15/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of sbyte values from the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of sbyte values from the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecb0a70ac86e461c2b68a4d95ac879e9" name="aecb0a70ac86e461c2b68a4d95ac879e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb0a70ac86e461c2b68a4d95ac879e9">&#9670;&#160;</a></span>get() <span class="overload">[16/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of sbyte values from the matrix at the given row and column, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of sbyte values from the matrix at the given row and column, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5e7410365b11635f4d01814de38a5a5" name="ac5e7410365b11635f4d01814de38a5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e7410365b11635f4d01814de38a5a5">&#9670;&#160;</a></span>get() <span class="overload">[17/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a short array from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The short array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified short array from the matrix at the given row and column. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8cd6698974799a8e1d56f3786802869" name="ac8cd6698974799a8e1d56f3786802869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cd6698974799a8e1d56f3786802869">&#9670;&#160;</a></span>get() <span class="overload">[18/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of short values from the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The short array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of short values from the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa3ba4486a0c9f61ad0142b60e287af0" name="afa3ba4486a0c9f61ad0142b60e287af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3ba4486a0c9f61ad0142b60e287af0">&#9670;&#160;</a></span>get() <span class="overload">[19/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of short values from the matrix at the given row and column, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The short array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of short values from the matrix at the given row and column, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35dbaa076c9bd42a3fc4b8118f8aa168" name="a35dbaa076c9bd42a3fc4b8118f8aa168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dbaa076c9bd42a3fc4b8118f8aa168">&#9670;&#160;</a></span>get() <span class="overload">[20/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of byte data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of byte data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ea00f8c8f941aa341f0819a2cc3949f" name="a9ea00f8c8f941aa341f0819a2cc3949f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea00f8c8f941aa341f0819a2cc3949f">&#9670;&#160;</a></span>get() <span class="overload">[21/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of byte data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of byte data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a778ade749444d758a54c9c285de85a24" name="a778ade749444d758a54c9c285de85a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778ade749444d758a54c9c285de85a24">&#9670;&#160;</a></span>get() <span class="overload">[22/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of byte data from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of byte data from the matrix at the given row and column, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c2e7b0ec02fbc6446df221ea808330" name="ab1c2e7b0ec02fbc6446df221ea808330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c2e7b0ec02fbc6446df221ea808330">&#9670;&#160;</a></span>get() <span class="overload">[23/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of double data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of double data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6534eb1e415c7324e52ab852960f5a0" name="ad6534eb1e415c7324e52ab852960f5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6534eb1e415c7324e52ab852960f5a0">&#9670;&#160;</a></span>get() <span class="overload">[24/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of double data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of double data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cc5fc29237c6c9fa4d9255d75a1974f" name="a8cc5fc29237c6c9fa4d9255d75a1974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc5fc29237c6c9fa4d9255d75a1974f">&#9670;&#160;</a></span>get() <span class="overload">[25/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of double data from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of double data from the matrix at the given row and column, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c4e2095af5786229c6546fd6f6e11e" name="a02c4e2095af5786229c6546fd6f6e11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c4e2095af5786229c6546fd6f6e11e">&#9670;&#160;</a></span>get() <span class="overload">[26/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of float data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of float data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a188d0087ad364897bc05b74568aad18a" name="a188d0087ad364897bc05b74568aad18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188d0087ad364897bc05b74568aad18a">&#9670;&#160;</a></span>get() <span class="overload">[27/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of float data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of float data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ab4bb07fa1bdecfbaa84fb58d6fbcb0" name="a5ab4bb07fa1bdecfbaa84fb58d6fbcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab4bb07fa1bdecfbaa84fb58d6fbcb0">&#9670;&#160;</a></span>get() <span class="overload">[28/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of float data from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of float data from the matrix at the given row and column, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a339bf08ab76c2fd713ce8b5440b389" name="a5a339bf08ab76c2fd713ce8b5440b389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a339bf08ab76c2fd713ce8b5440b389">&#9670;&#160;</a></span>get() <span class="overload">[29/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of int data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of int data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdbc9a78b15e8314fb4ee737c00a723e" name="abdbc9a78b15e8314fb4ee737c00a723e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbc9a78b15e8314fb4ee737c00a723e">&#9670;&#160;</a></span>get() <span class="overload">[30/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of int data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of int data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8f73bc59134c3a8c4a73ce3ddd9d813" name="ab8f73bc59134c3a8c4a73ce3ddd9d813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f73bc59134c3a8c4a73ce3ddd9d813">&#9670;&#160;</a></span>get() <span class="overload">[31/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of int data from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of int data from the matrix at the given row and column, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3bd7436c8159a19ad40a93ad9c121b7" name="ad3bd7436c8159a19ad40a93ad9c121b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bd7436c8159a19ad40a93ad9c121b7">&#9670;&#160;</a></span>get() <span class="overload">[32/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of sbyte data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of sbyte data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1be756c29b04a90e97a83f24b1347f2" name="ab1be756c29b04a90e97a83f24b1347f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1be756c29b04a90e97a83f24b1347f2">&#9670;&#160;</a></span>get() <span class="overload">[33/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of sbyte data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of sbyte data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadde7837d60533bfb831c85f9239acea" name="aadde7837d60533bfb831c85f9239acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadde7837d60533bfb831c85f9239acea">&#9670;&#160;</a></span>get() <span class="overload">[34/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of sbyte data from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of sbyte data from the matrix at the given row and column, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af305d005e4ea2ce7204d3194db81e9ea" name="af305d005e4ea2ce7204d3194db81e9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af305d005e4ea2ce7204d3194db81e9ea">&#9670;&#160;</a></span>get() <span class="overload">[35/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of short data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of short data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82e81dd8f8e0bad658d6f211d3feb323" name="a82e81dd8f8e0bad658d6f211d3feb323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e81dd8f8e0bad658d6f211d3feb323">&#9670;&#160;</a></span>get() <span class="overload">[36/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of short data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of short data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50311598c7ef152f70e62e4b5c5d539a" name="a50311598c7ef152f70e62e4b5c5d539a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50311598c7ef152f70e62e4b5c5d539a">&#9670;&#160;</a></span>get() <span class="overload">[37/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of short data from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of short data from the matrix at the given row and column, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48502f2c6ca9d7c1124c06e321c91ec3" name="a48502f2c6ca9d7c1124c06e321c91ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48502f2c6ca9d7c1124c06e321c91ec3">&#9670;&#160;</a></span>get() <span class="overload">[38/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of ushort data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of ushort data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab35f14fa305eb3f159441d4e85b5664c" name="ab35f14fa305eb3f159441d4e85b5664c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35f14fa305eb3f159441d4e85b5664c">&#9670;&#160;</a></span>get() <span class="overload">[39/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of ushort data from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of ushort data from the matrix at the given row and column. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26d9b9f77b9b74879a7c9b9f21ef66ed" name="a26d9b9f77b9b74879a7c9b9f21ef66ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d9b9f77b9b74879a7c9b9f21ef66ed">&#9670;&#160;</a></span>get() <span class="overload">[40/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of ushort data from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of ushort data from the matrix at the given row and column, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef0c032e58142fc109362b381a30f69c" name="aef0c032e58142fc109362b381a30f69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0c032e58142fc109362b381a30f69c">&#9670;&#160;</a></span>get() <span class="overload">[41/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an ushort array from the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified ushort array from the matrix at the given row and column. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351db39339ba875c6679f08cd7d36279" name="a351db39339ba875c6679f08cd7d36279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351db39339ba875c6679f08cd7d36279">&#9670;&#160;</a></span>get() <span class="overload">[42/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of ushort values from the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of ushort values from the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a338c555a7fa694d97e855867250dd70d" name="a338c555a7fa694d97e855867250dd70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338c555a7fa694d97e855867250dd70d">&#9670;&#160;</a></span>get() <span class="overload">[43/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of ushort values from the matrix at the given row and column, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of ushort values from the matrix at the given row and column, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46e6ea0e3935176db035ca68e038fe5f" name="a46e6ea0e3935176db035ca68e038fe5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e6ea0e3935176db035ca68e038fe5f">&#9670;&#160;</a></span>get() <span class="overload">[44/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double[] OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the element values from the matrix at the specified indices, returning them as an array of double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of double values representing the matrix element(s) at the specified indices. The length of the array corresponds to the number of channels in the matrix at the specified location. If the read operation fails, returns null. </dd></dl>
<p>This method reads the element values at the specified indices in the matrix and returns them as double values. Regardless of the matrix's actual data type, the values are cast to double. The size of the returned array depends on the number of channels in the matrix. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if an error occurs while retrieving the data, if the number of indices is incorrect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a840d87423fdc2d48b3116db3a5ec3847" name="a840d87423fdc2d48b3116db3a5ec3847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840d87423fdc2d48b3116db3a5ec3847">&#9670;&#160;</a></span>get() <span class="overload">[45/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a byte array from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified byte array from the matrix at the given indices. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. The number of indices in <em>idx</em>  must match the matrix's dimension count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ba4d128b6e9af6fceaebecbea072608" name="a0ba4d128b6e9af6fceaebecbea072608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba4d128b6e9af6fceaebecbea072608">&#9670;&#160;</a></span>get() <span class="overload">[46/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of byte values from the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of byte values from the matrix at the given indices. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaad69938d5e2fdd185ec8067af5b356a" name="aaad69938d5e2fdd185ec8067af5b356a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad69938d5e2fdd185ec8067af5b356a">&#9670;&#160;</a></span>get() <span class="overload">[47/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of byte values from the matrix at the given indices, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of byte values from the matrix at the given indices, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a851638cab40e428725a162284c402b5c" name="a851638cab40e428725a162284c402b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851638cab40e428725a162284c402b5c">&#9670;&#160;</a></span>get() <span class="overload">[48/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a double array from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The double array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified double array from the matrix at the given indices. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. The number of indices in <em>idx</em>  must match the matrix's dimension count. Only matrices with a data type of <code>CV_64F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_64F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4bc60589f9d824011f0adba76132394" name="af4bc60589f9d824011f0adba76132394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bc60589f9d824011f0adba76132394">&#9670;&#160;</a></span>get() <span class="overload">[49/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of double values from the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The double array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of double values from the matrix at the given indices. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_64F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_64F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3a3ca8706b26b2f518e95264a350f9a" name="ae3a3ca8706b26b2f518e95264a350f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a3ca8706b26b2f518e95264a350f9a">&#9670;&#160;</a></span>get() <span class="overload">[50/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of double values from the matrix at the given indices, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The double array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of double values from the matrix at the given indices, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_64F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_64F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a9224a703f566c8c0a56f03cd59adba" name="a1a9224a703f566c8c0a56f03cd59adba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9224a703f566c8c0a56f03cd59adba">&#9670;&#160;</a></span>get() <span class="overload">[51/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a float array from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The float array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified float array from the matrix at the given indices. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. The number of indices in <em>idx</em>  must match the matrix's dimension count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a752bf34aac499908e4ba8475f40fd28f" name="a752bf34aac499908e4ba8475f40fd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752bf34aac499908e4ba8475f40fd28f">&#9670;&#160;</a></span>get() <span class="overload">[52/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of float values from the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The float array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of float values from the matrix at the given indices. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adba4a2a795bdaf3075ae12ad8c3b7f06" name="adba4a2a795bdaf3075ae12ad8c3b7f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba4a2a795bdaf3075ae12ad8c3b7f06">&#9670;&#160;</a></span>get() <span class="overload">[53/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of float values from the matrix at the given indices, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The float array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of float values from the matrix at the given indices, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad661c4b32d54fb322b5b94d162ebb583" name="ad661c4b32d54fb322b5b94d162ebb583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad661c4b32d54fb322b5b94d162ebb583">&#9670;&#160;</a></span>get() <span class="overload">[54/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an int array from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The int array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified int array from the matrix at the given indices. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. The number of indices in <em>idx</em>  must match the matrix's dimension count. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a312a2ef6bdeab9bcff4d239f50375537" name="a312a2ef6bdeab9bcff4d239f50375537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312a2ef6bdeab9bcff4d239f50375537">&#9670;&#160;</a></span>get() <span class="overload">[55/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of int values from the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The int array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of int values from the matrix at the given indices. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0429c78e1d49c590c6a73796a115d153" name="a0429c78e1d49c590c6a73796a115d153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0429c78e1d49c590c6a73796a115d153">&#9670;&#160;</a></span>get() <span class="overload">[56/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of int values from the matrix at the given indices, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The int array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of int values from the matrix at the given indices, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a6c3b1fd2793ea26593de44ab4cfb86" name="a4a6c3b1fd2793ea26593de44ab4cfb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6c3b1fd2793ea26593de44ab4cfb86">&#9670;&#160;</a></span>get() <span class="overload">[57/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a sbyte array from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified sbyte array from the matrix at the given indices. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. The number of indices in <em>idx</em>  must match the matrix's dimension count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a145e61dab3962bd0754d9c273686e036" name="a145e61dab3962bd0754d9c273686e036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145e61dab3962bd0754d9c273686e036">&#9670;&#160;</a></span>get() <span class="overload">[58/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of sbyte values from the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of sbyte values from the matrix at the given indices. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e31ed0c1e476f30a014c28146ef8ffc" name="a9e31ed0c1e476f30a014c28146ef8ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e31ed0c1e476f30a014c28146ef8ffc">&#9670;&#160;</a></span>get() <span class="overload">[59/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of sbyte values from the matrix at the given indices, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of sbyte values from the matrix at the given indices, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27c910eeb3c7de269b4ab09c089f888f" name="a27c910eeb3c7de269b4ab09c089f888f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c910eeb3c7de269b4ab09c089f888f">&#9670;&#160;</a></span>get() <span class="overload">[60/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a short array from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The short array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified short array from the matrix at the given indices. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. The number of indices in <em>idx</em>  must match the matrix's dimension count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6cf19e01367ed93c7571e058a46cc7a" name="ad6cf19e01367ed93c7571e058a46cc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cf19e01367ed93c7571e058a46cc7a">&#9670;&#160;</a></span>get() <span class="overload">[61/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of short values from the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The short array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of short values from the matrix at the given indices. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8b3903bbf8c3d33f5eba8d728e55f19" name="ad8b3903bbf8c3d33f5eba8d728e55f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b3903bbf8c3d33f5eba8d728e55f19">&#9670;&#160;</a></span>get() <span class="overload">[62/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of short values from the matrix at the given indices, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The short array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of short values from the matrix at the given indices, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50bdaa9115d473f7eb87ee5a1aa15d6f" name="a50bdaa9115d473f7eb87ee5a1aa15d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bdaa9115d473f7eb87ee5a1aa15d6f">&#9670;&#160;</a></span>get() <span class="overload">[63/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of byte data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of byte data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a385fe8c49502752fe02571b29f13f4fc" name="a385fe8c49502752fe02571b29f13f4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385fe8c49502752fe02571b29f13f4fc">&#9670;&#160;</a></span>get() <span class="overload">[64/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of byte data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of byte data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9e94186b979cba9bd4395cb1e2e38ff" name="ac9e94186b979cba9bd4395cb1e2e38ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e94186b979cba9bd4395cb1e2e38ff">&#9670;&#160;</a></span>get() <span class="overload">[65/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of byte data from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of byte data from the matrix at the given indices, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a418bff105e44fd78c91bfc6e54cf07" name="a5a418bff105e44fd78c91bfc6e54cf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a418bff105e44fd78c91bfc6e54cf07">&#9670;&#160;</a></span>get() <span class="overload">[66/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of double data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of double data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b33328dada72c3c81c393bbb2264b1" name="a20b33328dada72c3c81c393bbb2264b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b33328dada72c3c81c393bbb2264b1">&#9670;&#160;</a></span>get() <span class="overload">[67/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of double data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of double data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a2617f5d2aea4398d079d8a3ba314f" name="a32a2617f5d2aea4398d079d8a3ba314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a2617f5d2aea4398d079d8a3ba314f">&#9670;&#160;</a></span>get() <span class="overload">[68/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of double data from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of double data from the matrix at the given indices, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af408c95056fa314b4e58e0ae719c0594" name="af408c95056fa314b4e58e0ae719c0594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af408c95056fa314b4e58e0ae719c0594">&#9670;&#160;</a></span>get() <span class="overload">[69/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of float data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of float data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351e80c10592fc5032827367fcc23b9d" name="a351e80c10592fc5032827367fcc23b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351e80c10592fc5032827367fcc23b9d">&#9670;&#160;</a></span>get() <span class="overload">[70/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of float data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of float data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aaa83bdb315b4fd0c36b54433ecf9ca" name="a6aaa83bdb315b4fd0c36b54433ecf9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aaa83bdb315b4fd0c36b54433ecf9ca">&#9670;&#160;</a></span>get() <span class="overload">[71/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of float data from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of float data from the matrix at the given indices, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a329a4152e63d2b055afe483152def776" name="a329a4152e63d2b055afe483152def776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329a4152e63d2b055afe483152def776">&#9670;&#160;</a></span>get() <span class="overload">[72/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of int data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of int data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad598cb3f51e92d610a9757a0f48bead5" name="ad598cb3f51e92d610a9757a0f48bead5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad598cb3f51e92d610a9757a0f48bead5">&#9670;&#160;</a></span>get() <span class="overload">[73/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of int data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of int data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33b444804d4fd60d0419a5baede8c1d2" name="a33b444804d4fd60d0419a5baede8c1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b444804d4fd60d0419a5baede8c1d2">&#9670;&#160;</a></span>get() <span class="overload">[74/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of int data from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of int data from the matrix at the given indices, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b8dc424abae99ff2327cb2f69f93a9a" name="a6b8dc424abae99ff2327cb2f69f93a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8dc424abae99ff2327cb2f69f93a9a">&#9670;&#160;</a></span>get() <span class="overload">[75/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of sbyte data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of sbyte data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7075b85a2156156ef47ba77face30a27" name="a7075b85a2156156ef47ba77face30a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7075b85a2156156ef47ba77face30a27">&#9670;&#160;</a></span>get() <span class="overload">[76/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of sbyte data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of sbyte data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5edd365b68560da90c0cf10e69f6ace" name="aa5edd365b68560da90c0cf10e69f6ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5edd365b68560da90c0cf10e69f6ace">&#9670;&#160;</a></span>get() <span class="overload">[77/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of sbyte data from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of sbyte data from the matrix at the given indices, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebf0c733c11124891aa6e8c8400aa3a7" name="aebf0c733c11124891aa6e8c8400aa3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf0c733c11124891aa6e8c8400aa3a7">&#9670;&#160;</a></span>get() <span class="overload">[78/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of short data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of short data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33ea4de13632edbd2075275c1b2a2d4a" name="a33ea4de13632edbd2075275c1b2a2d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ea4de13632edbd2075275c1b2a2d4a">&#9670;&#160;</a></span>get() <span class="overload">[79/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of short data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of short data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a892c65d399e6ba9fba362177d45be44f" name="a892c65d399e6ba9fba362177d45be44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c65d399e6ba9fba362177d45be44f">&#9670;&#160;</a></span>get() <span class="overload">[80/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of short data from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of short data from the matrix at the given indices, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ebd7f8a301ac29f58a138f7f2cc9f36" name="a7ebd7f8a301ac29f58a138f7f2cc9f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebd7f8a301ac29f58a138f7f2cc9f36">&#9670;&#160;</a></span>get() <span class="overload">[81/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a ushort of byte data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of ushort data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5197fb7b64ce19fb57bc376471468b0" name="ac5197fb7b64ce19fb57bc376471468b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5197fb7b64ce19fb57bc376471468b0">&#9670;&#160;</a></span>get() <span class="overload">[82/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of ushort data from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of ushort data from the matrix at the given indices. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ed2b9e97da5538c607cdfff29a31fe" name="aa5ed2b9e97da5538c607cdfff29a31fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ed2b9e97da5538c607cdfff29a31fe">&#9670;&#160;</a></span>get() <span class="overload">[83/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of ushort data from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of ushort data from the matrix at the given indices, storing them in the data span starting at the specified offset. The length of the span read must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe41d2fabe6b82955f366a40e8654907" name="afe41d2fabe6b82955f366a40e8654907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe41d2fabe6b82955f366a40e8654907">&#9670;&#160;</a></span>get() <span class="overload">[84/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an ushort array from the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array where the read data elements will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified ushort array from the matrix at the given indices. The length of the <em>data</em>  array must be sufficient to hold the data, and it must be a multiple of the matrix's channel count. The number of indices in <em>idx</em>  must match the matrix's dimension count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the length of the data array is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affa2289abcc8008c0b69f28d2c1bc637" name="affa2289abcc8008c0b69f28d2c1bc637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa2289abcc8008c0b69f28d2c1bc637">&#9670;&#160;</a></span>get() <span class="overload">[85/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of ushort values from the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of ushort values from the matrix at the given indices. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17f83d145fbd5fac11ff10a3d8baed66" name="a17f83d145fbd5fac11ff10a3d8baed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f83d145fbd5fac11ff10a3d8baed66">&#9670;&#160;</a></span>get() <span class="overload">[86/86]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.get </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a specified number of ushort values from the matrix at the given indices, storing them in the data array starting at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices corresponding to the dimensions of the matrix.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array where the read data elements will be stored.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting point within the array from which the data will be placed.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read from the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified number of ushort values from the matrix at the given indices, storing them in the data array starting at the specified offset. The number of elements specified by <em>length</em>  must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99e13da2541074e28aae11c1c6848ffc" name="a99e13da2541074e28aae11c1c6848ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e13da2541074e28aae11c1c6848ffc">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T[] <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the element values from the matrix at the specified row and column, returning them as an array of type <em>T</em> . </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index from which the data will be read.</td></tr>
    <tr><td class="paramname">col</td><td>The column index from which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of type <em>T</em>  representing the matrix element(s) at the specified row and column. The size of the returned array corresponds to the number of matrix element bytes divided by the size of type <em>T</em> . If the read operation fails, returns null. </dd></dl>
<p>This method reads the element values at the specified row and column in the matrix and returns them as values of type <em>T</em> . Regardless of the matrix's actual data type, the values are cast to the specified type <em>T</em> . The size of the returned array depends on how many values of type <em>T</em>  can fit into the total byte size of the matrix element. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a07cc224d583b618dcda2524b4fc66ce9" name="a07cc224d583b618dcda2524b4fc66ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cc224d583b618dcda2524b4fc66ce9">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of type <em>T</em>  from the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of type <em>T</em>  from the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abed20f59737a1e296ba16f08ff0c74bc" name="abed20f59737a1e296ba16f08ff0c74bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed20f59737a1e296ba16f08ff0c74bc">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of type <em>T</em>  from the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of type <em>T</em>  from the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab181d24766a61e71f2577e9ab95e7044" name="ab181d24766a61e71f2577e9ab95e7044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab181d24766a61e71f2577e9ab95e7044">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of type <em>T</em>  from the matrix at the specified row and column, storing them in the data span starting at the specified offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of type <em>T</em>  from the matrix at the given row and column, storing them in the data span starting at the specified offset. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aacab7753a08f5e1ad53a4acaf1a10ceb" name="aacab7753a08f5e1ad53a4acaf1a10ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacab7753a08f5e1ad53a4acaf1a10ceb">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of type <em>T</em>  from the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified array of type <em>T</em>  from the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aec0925f2fadf976710c94156a974f638" name="aec0925f2fadf976710c94156a974f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0925f2fadf976710c94156a974f638">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of type <em>T</em>  from the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified array of type <em>T</em>  from the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a92e7b7cd4732b79479f70d2523b3392a" name="a92e7b7cd4732b79479f70d2523b3392a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e7b7cd4732b79479f70d2523b3392a">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of type <em>T</em>  from the matrix at the specified row and column, storing them in the data array starting at the specified offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the array at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified array of type <em>T</em>  from the matrix at the given row and column, storing them in the data array starting at the specified offset. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a62bd50ab046b9ecdac46da8684091ce0" name="a62bd50ab046b9ecdac46da8684091ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bd50ab046b9ecdac46da8684091ce0">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T[] <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the element values from the matrix at the specified indices, returning them as an array of type <em>T</em> . </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the location from which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of type <em>T</em>  representing the matrix element(s) at the specified indices. The size of the returned array corresponds to the number of matrix element bytes divided by the size of type <em>T</em> . If the read operation fails, returns null. </dd></dl>
<p>This method reads the element values at the specified indices in the matrix and returns them as values of type <em>T</em> . Regardless of the matrix's actual data type, the values are cast to the specified type <em>T</em> . The size of the returned array depends on how many values of type <em>T</em>  can fit into the total byte size of the matrix element. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a61d20fe8a15c16cd9cd04e6cb9fd8885" name="a61d20fe8a15c16cd9cd04e6cb9fd8885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d20fe8a15c16cd9cd04e6cb9fd8885">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of type <em>T</em>  from the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of type <em>T</em>  from the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a7579fc79f66980a6cc1834f4603ea211" name="a7579fc79f66980a6cc1834f4603ea211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7579fc79f66980a6cc1834f4603ea211">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of type <em>T</em>  from the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of type <em>T</em>  from the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1b677f00e590dddc94d7620aa225c1f8" name="a1b677f00e590dddc94d7620aa225c1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b677f00e590dddc94d7620aa225c1f8">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a span of type <em>T</em>  from the matrix at the specified indices, storing them in the data span starting at the specified offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the span at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified span of type <em>T</em>  from the matrix at the given indices, storing them in the data span starting at the specified offset. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a172101b25e8a47891b164213c9c7b6be" name="a172101b25e8a47891b164213c9c7b6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172101b25e8a47891b164213c9c7b6be">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of type <em>T</em>  from the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to store the read values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified array of type <em>T</em>  from the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac2659dc2a31e84631761bc31a17b50e9" name="ac2659dc2a31e84631761bc31a17b50e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2659dc2a31e84631761bc31a17b50e9">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of type <em>T</em>  from the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified array of type <em>T</em>  from the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad8f224dd682b161f070f253110407449" name="ad8f224dd682b161f070f253110407449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f224dd682b161f070f253110407449">&#9670;&#160;</a></span>get&lt; T &gt;() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#acf4ab7b8b3837945ec745b9cd716c4f4">OpenCVForUnity.CoreModule.Mat.get</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of type <em>T</em>  from the matrix at the specified indices, storing them in the data array starting at the specified offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix from which to read data.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to store the read values.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the array at which to start storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully read from the matrix.</dd></dl>
<p>This method reads the specified array of type <em>T</em>  from the matrix at the given indices, storing them in the data array starting at the specified offset. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aeb04de545c7edc06d906484571762561" name="aeb04de545c7edc06d906484571762561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb04de545c7edc06d906484571762561">&#9670;&#160;</a></span>getNativeObjAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr OpenCVForUnity.CoreModule.Mat.getNativeObjAddr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84f44328c9c29259e9545b1980ead568" name="a84f44328c9c29259e9545b1980ead568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f44328c9c29259e9545b1980ead568">&#9670;&#160;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.height </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of rows in the matrix. </p>
<p>The method returns the number of rows in the matrix, which corresponds to the height of the image represented by the matrix. If the matrix is empty (i.e., it has no elements), the method will return 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows in the matrix. </dd></dl>

</div>
</div>
<a id="ae8dc67d6f17bd8488bed57fdcfd8f630" name="ae8dc67d6f17bd8488bed57fdcfd8f630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8dc67d6f17bd8488bed57fdcfd8f630">&#9670;&#160;</a></span>inv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.inv </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverses a matrix. </p>
<p>The method performs a matrix inversion by means of matrix expressions. This means that a temporary matrix inversion object is returned by the method and can be used further as a part of more complex matrix expressions or can be assigned to a matrix. </p>

</div>
</div>
<a id="a265fa032291f4b8db3ad35239c7625f5" name="a265fa032291f4b8db3ad35239c7625f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265fa032291f4b8db3ad35239c7625f5">&#9670;&#160;</a></span>inv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.inv </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>method</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverses a matrix. </p>
<p>The method performs a matrix inversion by means of matrix expressions. This means that a temporary matrix inversion object is returned by the method and can be used further as a part of more complex matrix expressions or can be assigned to a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Matrix inversion method. One of cv::DecompTypes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63d3d12b95ce8f9bcb7b61dc78de6275" name="a63d3d12b95ce8f9bcb7b61dc78de6275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d3d12b95ce8f9bcb7b61dc78de6275">&#9670;&#160;</a></span>isContinuous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenCVForUnity.CoreModule.Mat.isContinuous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the matrix is continuous or not. </p>
<p>The method returns true if the matrix elements are stored continuously without gaps at the end of each row. Otherwise, it returns false. Obviously, 1x1 or 1xN matrices are always continuous. Matrices created with <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create</a> are always continuous. But if you extract a part of the matrix using <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#a26cdf2367d666a83f6af334d01475672" title="Extracts a diagonal from a matrix.">Mat.diag</a>, and so on, or constructed a matrix header for externally allocated data, such matrices may no longer have this property.</p>
<p>The continuity flag is stored as a bit in the Mat::flags field and is computed automatically when you construct a matrix header. Thus, the continuity check is a very fast operation, though theoretically it could be done as follows: </p>
<div class="fragment"><div class="line"><span class="comment">// alternative implementation of Mat::isContinuous()</span></div>
<div class="line"><span class="keywordtype">bool</span> myCheckMatContinuity(<span class="keyword">const</span> <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;amp; m)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//return (m.flags &amp;amp; Mat::CONTINUOUS_FLAG) != 0;</span></div>
<div class="line">    <span class="keywordflow">return</span> m.rows == 1 || m.step == m.cols*m.elemSize();</div>
<div class="line">}</div>
</div><!-- fragment --> <p>The method is used in quite a few of OpenCV functions. The point is that element-wise operations (such as arithmetic and logical operations, math functions, alpha blending, color space transformations, and others) do not depend on the image geometry. Thus, if all the input and output arrays are continuous, the functions can process them as very long single-row vectors. The example below illustrates how an alpha-blending function can be implemented: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> alphaBlendRGBA(<span class="keyword">const</span> <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;amp; src1, <span class="keyword">const</span> <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;amp; src2, <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;amp; dst)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> alpha_scale = (float)std::numeric_limits&lt;T&gt;::max(),</div>
<div class="line">                inv_scale = 1.f/alpha_scale;</div>
<div class="line"> </div>
<div class="line">    CV_Assert( src1.type() == src2.type() &amp;amp;&amp;amp;</div>
<div class="line">               src1.type() == CV_MAKETYPE(traits::Depth&lt;T&gt;::value, 4) &amp;amp;&amp;amp;</div>
<div class="line">               src1.size() == src2.size());</div>
<div class="line">    <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> <a class="code hl_function" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a> = src1.size();</div>
<div class="line">    dst.create(<a class="code hl_function" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>, src1.type());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// here is the idiom: check the arrays for continuity and,</span></div>
<div class="line">    <span class="comment">// if this is the case,</span></div>
<div class="line">    <span class="comment">// treat the arrays as 1D vectors</span></div>
<div class="line">    <span class="keywordflow">if</span>( src1.isContinuous() &amp;amp;&amp;amp; src2.isContinuous() &amp;amp;&amp;amp; dst.isContinuous() )</div>
<div class="line">    {</div>
<div class="line">        size.width *= <a class="code hl_function" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>.<a class="code hl_variable" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html#a70cee220eeeafcbdff37196fd7aedd8c">height</a>;</div>
<div class="line">        size.height = 1;</div>
<div class="line">    }</div>
<div class="line">    size.width *= 4;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_function" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>.<a class="code hl_variable" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html#a70cee220eeeafcbdff37196fd7aedd8c">height</a>; i++ )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// when the arrays are continuous,</span></div>
<div class="line">        <span class="comment">// the outer loop is executed only once</span></div>
<div class="line">        <span class="keyword">const</span> T* ptr1 = src1.ptr&lt;T&gt;(i);</div>
<div class="line">        <span class="keyword">const</span> T* ptr2 = src2.ptr&lt;T&gt;(i);</div>
<div class="line">        T* dptr = dst.ptr&lt;T&gt;(i);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = 0; j &lt; <a class="code hl_function" href="#abd78d83d7206bf4c4ee61850bf4d0375">size</a>.<a class="code hl_variable" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html#aded2b203f2d1583e936523a186887e62">width</a>; j += 4 )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">float</span> alpha = ptr1[j+3]*inv_scale, beta = ptr2[j+3]*inv_scale;</div>
<div class="line">            dptr[j] = saturate_cast&lt;T&gt;(ptr1[j]*alpha + ptr2[j]*beta);</div>
<div class="line">            dptr[j+1] = saturate_cast&lt;T&gt;(ptr1[j+1]*alpha + ptr2[j+1]*beta);</div>
<div class="line">            dptr[j+2] = saturate_cast&lt;T&gt;(ptr1[j+2]*alpha + ptr2[j+2]*beta);</div>
<div class="line">            dptr[j+3] = saturate_cast&lt;T&gt;((1 - (1-alpha)*(1-beta))*alpha_scale);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_size_html"><div class="ttname"><a href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">OpenCVForUnity.CoreModule.Size</a></div><div class="ttdoc">Template class for specifying the size of an image or rectangle.</div><div class="ttdef"><b>Definition</b> Size_Ex.cs:7</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_size_html_a70cee220eeeafcbdff37196fd7aedd8c"><div class="ttname"><a href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html#a70cee220eeeafcbdff37196fd7aedd8c">OpenCVForUnity.CoreModule.Size.height</a></div><div class="ttdeci">double height</div><div class="ttdef"><b>Definition</b> Size.cs:26</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_size_html_aded2b203f2d1583e936523a186887e62"><div class="ttname"><a href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html#aded2b203f2d1583e936523a186887e62">OpenCVForUnity.CoreModule.Size.width</a></div><div class="ttdeci">double width</div><div class="ttdef"><b>Definition</b> Size.cs:21</div></div>
</div><!-- fragment --> <p>This approach, while being very simple, can boost the performance of a simple element-operation by 10-20 percents, especially if the image is rather small and the operation is quite simple.</p>
<p>Another OpenCV idiom in this function, a call of <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create</a> for the destination array, that allocates the destination array unless it already has the proper size and type. And while the newly allocated arrays are always continuous, you still need to check the destination array because <a class="el" href="#ab18f5d2799293f7fe5219451eb9ac7f1" title="Allocates new array data if needed.">Mat.create</a> does not always allocate a new matrix. </p>

</div>
</div>
<a id="a2e89ce1e4e254e7ad3cfa7a11a41b3e9" name="a2e89ce1e4e254e7ad3cfa7a11a41b3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e89ce1e4e254e7ad3cfa7a11a41b3e9">&#9670;&#160;</a></span>isSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenCVForUnity.CoreModule.Mat.isSubmatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns true if the matrix is a submatrix of another matrix </p>

</div>
</div>
<a id="a0a7c585ef7e25c7867c76bdb1eff883a" name="a0a7c585ef7e25c7867c76bdb1eff883a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7c585ef7e25c7867c76bdb1eff883a">&#9670;&#160;</a></span>locateROI() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.locateROI </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>wholeSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the matrix header within a parent matrix. </p>
<p>After you extracted a submatrix from a matrix using <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a>, and others, the resultant submatrix points just to the part of the original big matrix. However, each submatrix contains information (represented by datastart and dataend fields) that helps reconstruct the original matrix size and the position of the extracted submatrix within the original matrix. The method locateROI does exactly that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wholeSize</td><td>Output parameter that contains the size of the whole matrix containing <em>this</em> as a part. </td></tr>
    <tr><td class="paramname">ofs</td><td>Output parameter that contains an offset of <em>this</em> inside the whole matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb8a0cc9ac24666fa83e4475e5cfbaca" name="adb8a0cc9ac24666fa83e4475e5cfbaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8a0cc9ac24666fa83e4475e5cfbaca">&#9670;&#160;</a></span>locateROI() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.locateROI </td>
          <td>(</td>
          <td class="paramtype">out(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>wholeSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out(double x, double y)</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the matrix header within a parent matrix. </p>
<p>After you extracted a submatrix from a matrix using <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a>, and others, the resultant submatrix points just to the part of the original big matrix. However, each submatrix contains information (represented by datastart and dataend fields) that helps reconstruct the original matrix size and the position of the extracted submatrix within the original matrix. The method locateROI does exactly that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wholeSize</td><td>Output parameter that contains the size of the whole matrix containing <em>this</em> as a part. </td></tr>
    <tr><td class="paramname">ofs</td><td>Output parameter that contains an offset of <em>this</em> inside the whole matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d0ba88c8c3ae6c0bd3531bfe2e1ef44" name="a3d0ba88c8c3ae6c0bd3531bfe2e1ef44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0ba88c8c3ae6c0bd3531bfe2e1ef44">&#9670;&#160;</a></span>locateROI() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.locateROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>wholeSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_point.html">Point</a></td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the matrix header within a parent matrix. </p>
<p>After you extracted a submatrix from a matrix using <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a>, and others, the resultant submatrix points just to the part of the original big matrix. However, each submatrix contains information (represented by datastart and dataend fields) that helps reconstruct the original matrix size and the position of the extracted submatrix within the original matrix. The method locateROI does exactly that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wholeSize</td><td>Output parameter that contains the size of the whole matrix containing <em>this</em> as a part. </td></tr>
    <tr><td class="paramname">ofs</td><td>Output parameter that contains an offset of <em>this</em> inside the whole matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b7c10c6469bf85b5245e23517c5ca7a" name="a6b7c10c6469bf85b5245e23517c5ca7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7c10c6469bf85b5245e23517c5ca7a">&#9670;&#160;</a></span>matMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.matMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>operand with with which to perform matrix multiplication </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object </dd></dl>

</div>
</div>
<a id="a379c0d4aad35e0cc1195fe6126c92e56" name="a379c0d4aad35e0cc1195fe6126c92e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379c0d4aad35e0cc1195fe6126c92e56">&#9670;&#160;</a></span>mul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>operand with with which to perform element-wise multiplication </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object </dd></dl>

</div>
</div>
<a id="a2f71afba9acec61497456f922282abdb" name="a2f71afba9acec61497456f922282abdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f71afba9acec61497456f922282abdb">&#9670;&#160;</a></span>mul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an element-wise multiplication or division of the two matrices. </p>
<p>The method returns a temporary object encoding per-element array multiplication, with optional scale. Note that this is not a matrix multiplication that corresponds to a simpler "*" operator. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> C = A.<a class="code hl_function" href="#a2f71afba9acec61497456f922282abdb">mul</a>(5/B); <span class="comment">// equivalent to divide(A, B, C, 5)</span></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a2f71afba9acec61497456f922282abdb"><div class="ttname"><a href="#a2f71afba9acec61497456f922282abdb">OpenCVForUnity.CoreModule.Mat.mul</a></div><div class="ttdeci">Mat mul(Mat m, double scale)</div><div class="ttdoc">Performs an element-wise multiplication or division of the two matrices.</div><div class="ttdef"><b>Definition</b> Mat.cs:1764</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Another array of the same type and the same size as *this, or a matrix expression. </td></tr>
    <tr><td class="paramname">scale</td><td>Optional scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7aaf70723220d0d2d2348c1832482e4" name="aa7aaf70723220d0d2d2348c1832482e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7aaf70723220d0d2d2348c1832482e4">&#9670;&#160;</a></span>ones() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.ones </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all 1's of the specified size and type. </p>
<p>The method returns a Matlab-style 1's array initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a87787208caf135e9a0530b74c9c2633d">Mat::ones</a>(100, 100, CV_8U)*3; <span class="comment">// make 100x100 matrix filled with 3.</span></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a87787208caf135e9a0530b74c9c2633d"><div class="ttname"><a href="#a87787208caf135e9a0530b74c9c2633d">OpenCVForUnity.CoreModule.Mat.ones</a></div><div class="ttdeci">static Mat ones(int rows, int cols, int type)</div><div class="ttdoc">Returns an array of all 1's of the specified size and type.</div><div class="ttdef"><b>Definition</b> Mat.cs:1835</div></div>
</div><!-- fragment --> <p>The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer. </p><dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, only the first channel will be initialized with 1's, the others will be set to 0's. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative to the matrix size specification Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f393e2a8f60b97b0ea219d5820173c6" name="a4f393e2a8f60b97b0ea219d5820173c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f393e2a8f60b97b0ea219d5820173c6">&#9670;&#160;</a></span>ones() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.ones </td>
          <td>(</td>
          <td class="paramtype">in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all 1's of the specified size and type. </p>
<p>The method returns a Matlab-style 1's array initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a87787208caf135e9a0530b74c9c2633d">Mat::ones</a>(100, 100, CV_8U)*3; <span class="comment">// make 100x100 matrix filled with 3.</span></div>
</div><!-- fragment --> <p>The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer. </p><dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, only the first channel will be initialized with 1's, the others will be set to 0's. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative to the matrix size specification Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87787208caf135e9a0530b74c9c2633d" name="a87787208caf135e9a0530b74c9c2633d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87787208caf135e9a0530b74c9c2633d">&#9670;&#160;</a></span>ones() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.ones </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all 1's of the specified size and type. </p>
<p>The method returns a Matlab-style 1's array initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a87787208caf135e9a0530b74c9c2633d">Mat::ones</a>(100, 100, CV_8U)*3; <span class="comment">// make 100x100 matrix filled with 3.</span></div>
</div><!-- fragment --> <p>The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer. </p><dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, only the first channel will be initialized with 1's, the others will be set to 0's. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace7cfa6c7a1ab1c82c0c27c1eb516bc0" name="ace7cfa6c7a1ab1c82c0c27c1eb516bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7cfa6c7a1ab1c82c0c27c1eb516bc0">&#9670;&#160;</a></span>ones() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.ones </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all 1's of the specified size and type. </p>
<p>The method returns a Matlab-style 1's array initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a87787208caf135e9a0530b74c9c2633d">Mat::ones</a>(100, 100, CV_8U)*3; <span class="comment">// make 100x100 matrix filled with 3.</span></div>
</div><!-- fragment --> <p>The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer. </p><dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, only the first channel will be initialized with 1's, the others will be set to 0's. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Array of integers specifying an n-dimensional array shape. </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a206a45993387da30305f25c771a92468" name="a206a45993387da30305f25c771a92468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206a45993387da30305f25c771a92468">&#9670;&#160;</a></span>ones() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all 1's of the specified size and type. </p>
<p>The method returns a Matlab-style 1's array initializer, similarly to <a class="el" href="#a415b6818d16ea2a7a1dcd571e04e14ab" title="Returns a zero array of the specified size and type.">Mat.zeros</a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A = <a class="code hl_function" href="#a87787208caf135e9a0530b74c9c2633d">Mat::ones</a>(100, 100, CV_8U)*3; <span class="comment">// make 100x100 matrix filled with 3.</span></div>
</div><!-- fragment --> <p>The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer. </p><dl class="section note"><dt>Note</dt><dd>In case of multi-channels type, only the first channel will be initialized with 1's, the others will be set to 0's. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative to the matrix size specification Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15e8540445e9cf2fb0bfc71a2887562b" name="a15e8540445e9cf2fb0bfc71a2887562b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e8540445e9cf2fb0bfc71a2887562b">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise AND operation between two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first matrix.</td></tr>
    <tr><td class="paramname">b</td><td>The second matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise AND operation between <em>a</em>  and <em>b</em> .</dd></dl>
<p>This operator performs an element-wise bitwise AND operation between the matrices <em>a</em>  and <em>b</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="ac0adf03ae616e4be68fc84ac9ce2e83b" name="ac0adf03ae616e4be68fc84ac9ce2e83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0adf03ae616e4be68fc84ac9ce2e83b">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise AND operation between a matrix and a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise AND operation between <em>a</em>  and <em>s</em> .</dd></dl>
<p>This operator performs an element-wise bitwise AND operation between the matrix <em>a</em>  and the scalar <em>s</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="ae3789629cd268308f1a850ae02758b41" name="ae3789629cd268308f1a850ae02758b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3789629cd268308f1a850ae02758b41">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise AND operation between a scalar and a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The scalar value.</td></tr>
    <tr><td class="paramname">a</td><td>The matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise AND operation between <em>s</em>  and <em>a</em> .</dd></dl>
<p>This operator performs an element-wise bitwise AND operation between the scalar <em>s</em>  and the matrix <em>a</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="acf648be03572f34508ac2c71bdaff577" name="acf648be03572f34508ac2c71bdaff577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf648be03572f34508ac2c71bdaff577">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a matrix by a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix to be multiplied.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value to multiply the matrix by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of multiplying <em>a</em>  by <em>s</em> .</dd></dl>
<p>This operator performs element-wise multiplication of the matrix <em>a</em>  by the scalar <em>s</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a8a599422317dbb86c27ecf8240c6f076" name="a8a599422317dbb86c27ecf8240c6f076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a599422317dbb86c27ecf8240c6f076">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a matrix by a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix to be multiplied.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value to multiply the matrix by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of multiplying <em>a</em>  by <em>s</em> .</dd></dl>
<p>This operator performs element-wise multiplication of the matrix <em>a</em>  by the scalar <em>s</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a30a3577b30d182d13554beb9dbbd82c8" name="a30a3577b30d182d13554beb9dbbd82c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a3577b30d182d13554beb9dbbd82c8">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies two matrices using the General Matrix Multiply (GEMM) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first matrix.</td></tr>
    <tr><td class="paramname">b</td><td>The second matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of multiplying <em>a</em>  by <em>b</em> .</dd></dl>
<p>This operator performs matrix multiplication of the matrices <em>a</em>  and <em>b</em>  using the GEMM function and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a648a5f171a6e4196ccc5c8df11cf7677" name="a648a5f171a6e4196ccc5c8df11cf7677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648a5f171a6e4196ccc5c8df11cf7677">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two matrices element-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first input matrix.</td></tr>
    <tr><td class="paramname">b</td><td>The second input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the sum of the two input matrices.</dd></dl>
<p>This operator performs element-wise addition of the matrices <em>a</em>  and <em>b</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a395fd8de6fae3a7153a6d75aa21d2e46" name="a395fd8de6fae3a7153a6d75aa21d2e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395fd8de6fae3a7153a6d75aa21d2e46">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scalar value to each element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The input matrix.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of adding the scalar to each element of the input matrix.</dd></dl>
<p>This operator performs element-wise addition of the matrix <em>a</em>  and the scalar <em>s</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a613581d9344659fd48b90a2dfce3bd61" name="a613581d9344659fd48b90a2dfce3bd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613581d9344659fd48b90a2dfce3bd61">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scalar value to each element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The scalar value to add.</td></tr>
    <tr><td class="paramname">a</td><td>The input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of adding the scalar to each element of the input matrix.</dd></dl>
<p>This operator performs element-wise addition of the scalar <em>s</em>  and the matrix <em>a</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a4c90b9fbca79f20d6a880f626bafab39" name="a4c90b9fbca79f20d6a880f626bafab39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c90b9fbca79f20d6a880f626bafab39">&#9670;&#160;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates all elements of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The input matrix to be negated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix where each element is the negation of the corresponding element in the input matrix.</dd></dl>
<p>This operator negates all elements in the matrix <em>a</em>  by multiplying them by -1. A new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object is created and returned. </p>

</div>
</div>
<a id="a308a81a6707d46d353d499fccc5dee89" name="a308a81a6707d46d353d499fccc5dee89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308a81a6707d46d353d499fccc5dee89">&#9670;&#160;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts one matrix from another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The minuend matrix.</td></tr>
    <tr><td class="paramname">b</td><td>The subtrahend matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of subtracting <em>b</em>  from <em>a</em> .</dd></dl>
<p>This operator performs element-wise subtraction of the matrix <em>b</em>  from the matrix <em>a</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a2264f6ca764b160987e3fb2d47488c68" name="a2264f6ca764b160987e3fb2d47488c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2264f6ca764b160987e3fb2d47488c68">&#9670;&#160;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a scalar value from each element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix from which the scalar will be subtracted.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value to subtract from each element of the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of subtracting <em>s</em>  from each element of <em>a</em> .</dd></dl>
<p>This operator performs element-wise subtraction of the scalar <em>s</em>  from the matrix <em>a</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a1174189ddafc673708799798f82b6b74" name="a1174189ddafc673708799798f82b6b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1174189ddafc673708799798f82b6b74">&#9670;&#160;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a scalar value from each element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix from which the scalar will be subtracted.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value to subtract from each element of the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of subtracting <em>s</em>  from each element of <em>a</em> .</dd></dl>
<p>This operator performs element-wise subtraction of the scalar <em>s</em>  from the matrix <em>a</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="aaf9791cb41a056ea93bc571851a1f8e8" name="aaf9791cb41a056ea93bc571851a1f8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9791cb41a056ea93bc571851a1f8e8">&#9670;&#160;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator/ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides a scalar value by a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The scalar value (dividend).</td></tr>
    <tr><td class="paramname">a</td><td>The divisor matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of dividing the scalar <em>s</em>  by the matrix <em>a</em> .</dd></dl>
<p>This operator creates a new matrix filled with the scalar value <em>s</em>  and performs element-wise division of this matrix by <em>a</em> . It returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="ab93c827d80f58bd4b34b827b51d63f4a" name="ab93c827d80f58bd4b34b827b51d63f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93c827d80f58bd4b34b827b51d63f4a">&#9670;&#160;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides a matrix by a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The dividend matrix.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value (divisor).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of dividing the matrix <em>a</em>  by the scalar <em>s</em> .</dd></dl>
<p>This operator performs element-wise division of the matrix <em>a</em>  by the scalar <em>s</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="aaa5b75c4b11d912ee598f280e5f82adb" name="aaa5b75c4b11d912ee598f280e5f82adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5b75c4b11d912ee598f280e5f82adb">&#9670;&#160;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides one matrix by another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The dividend matrix.</td></tr>
    <tr><td class="paramname">b</td><td>The divisor matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of dividing <em>a</em>  by <em>b</em> .</dd></dl>
<p>This operator performs element-wise division of the matrix <em>a</em>  by the matrix <em>b</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a59aa026973ac82aab6572df8d5bb3114" name="a59aa026973ac82aab6572df8d5bb3114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59aa026973ac82aab6572df8d5bb3114">&#9670;&#160;</a></span>operator^() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise XOR operation between two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first matrix.</td></tr>
    <tr><td class="paramname">b</td><td>The second matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise XOR operation between <em>a</em>  and <em>b</em> .</dd></dl>
<p>This operator performs an element-wise bitwise XOR operation between the two matrices <em>a</em>  and <em>b</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a93513201a3e2e088241a71a97feeadb8" name="a93513201a3e2e088241a71a97feeadb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93513201a3e2e088241a71a97feeadb8">&#9670;&#160;</a></span>operator^() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise XOR operation between a matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise XOR operation between <em>a</em>  and <em>s</em> .</dd></dl>
<p>This operator performs an element-wise bitwise XOR operation between the matrix <em>a</em>  and the scalar <em>s</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a8de3ca7c4a52ca2630251704748ff0b8" name="a8de3ca7c4a52ca2630251704748ff0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de3ca7c4a52ca2630251704748ff0b8">&#9670;&#160;</a></span>operator^() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise XOR operation between a scalar value and a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The scalar value.</td></tr>
    <tr><td class="paramname">a</td><td>The matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise XOR operation between <em>s</em>  and <em>a</em> .</dd></dl>
<p>This operator performs an element-wise bitwise XOR operation between the scalar <em>s</em>  and the matrix <em>a</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="ad2f68cd26e43262116c27cd70319173e" name="ad2f68cd26e43262116c27cd70319173e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f68cd26e43262116c27cd70319173e">&#9670;&#160;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise OR operation between two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first matrix.</td></tr>
    <tr><td class="paramname">b</td><td>The second matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise OR operation between <em>a</em>  and <em>b</em> .</dd></dl>
<p>This operator performs an element-wise bitwise OR operation between the two matrices <em>a</em>  and <em>b</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="ac0ec36d8053add40646b7fb0a2d25856" name="ac0ec36d8053add40646b7fb0a2d25856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ec36d8053add40646b7fb0a2d25856">&#9670;&#160;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise OR operation between a matrix and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix.</td></tr>
    <tr><td class="paramname">s</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise OR operation between <em>a</em>  and the scalar <em>s</em> .</dd></dl>
<p>This operator performs an element-wise bitwise OR operation between the matrix <em>a</em>  and a new matrix created from the scalar <em>s</em> . The new matrix has the same size and type as <em>a</em> . It returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a0b2fc6d1894eb9981076b21ca407f526" name="a0b2fc6d1894eb9981076b21ca407f526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2fc6d1894eb9981076b21ca407f526">&#9670;&#160;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise OR operation between a scalar value and a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The scalar value.</td></tr>
    <tr><td class="paramname">a</td><td>The matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of the bitwise OR operation between the scalar <em>s</em>  and the matrix <em>a</em> .</dd></dl>
<p>This operator performs an element-wise bitwise OR operation between a new matrix created from the scalar <em>s</em>  and the matrix <em>a</em> . The new matrix has the same size and type as <em>a</em> . It returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object containing the result.</p>
<p><b>Note:</b> In C++, the left-hand operand of compound assignment operators like "&lt;c&gt;A += B&lt;/c&gt;" is reused, and operations such as "&lt;c&gt;Core.add(A, B, A)&lt;/c&gt;" are performed internally. However, in C#, it is not possible to explicitly overload compound assignment operators. Instead, binary operator overloading is used implicitly, which results in a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object being created and assigned to A each time an operator is used. This behavior leads to different memory management between C++ and C#. </p>

</div>
</div>
<a id="a6a91923ac94fd6031f12766f44c52991" name="a6a91923ac94fd6031f12766f44c52991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a91923ac94fd6031f12766f44c52991">&#9670;&#160;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a bitwise NOT operation on the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix with each bit in the input matrix inverted.</dd></dl>
<p>This operator applies a bitwise NOT operation to the matrix <em>a</em>  and returns a new <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object with each bit in the matrix inverted. </p>

</div>
</div>
<a id="a29ff27d3859fb5f6ce1670245f9506af" name="a29ff27d3859fb5f6ce1670245f9506af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ff27d3859fb5f6ce1670245f9506af">&#9670;&#160;</a></span>ptr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr OpenCVForUnity.CoreModule.Mat.ptr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the specified row of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the data at the specified row index in a multi-dimensional OpenCV <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. It performs basic checks to ensure the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> has not been disposed, but does not perform bounds checking on the specified index.</p>
<p>The pointer returned points to the first element of the specified row, allowing for direct manipulation of the underlying data.</p>
<p><b>Note:</b> If the row index is out of bounds, an invalid or out-of-bounds pointer may be returned, leading to undefined behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The row index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer (IntPtr) to the data at the specified row of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </dd></dl>

</div>
</div>
<a id="a05ca48c0e8bdbf6fa6daec4820b50bbc" name="a05ca48c0e8bdbf6fa6daec4820b50bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ca48c0e8bdbf6fa6daec4820b50bbc">&#9670;&#160;</a></span>ptr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr OpenCVForUnity.CoreModule.Mat.ptr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the specified row and column of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. </p>
<p>This method returns a pointer to the data at the specified row and column indices in a multi-dimensional OpenCV <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. It ensures that the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> is valid and not disposed, but does not perform bounds checking on the specified indices.</p>
<p>The pointer returned points to the first element at the specified row and column, enabling direct manipulation of the underlying data.</p>
<p><b>Note:</b> If the indices are out of bounds, an invalid or out-of-bounds pointer may be returned, leading to undefined behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The row index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of rows. </td></tr>
    <tr><td class="paramname">i1</td><td>The column index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer (IntPtr) to the data at the specified row and column of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </dd></dl>

</div>
</div>
<a id="a043ada76d46721035aa0acfc91e873be" name="a043ada76d46721035aa0acfc91e873be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043ada76d46721035aa0acfc91e873be">&#9670;&#160;</a></span>ptr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr OpenCVForUnity.CoreModule.Mat.ptr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the specified element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object based on the given row, column, and third dimension indices. </p>
<p>This method returns a pointer to the data at the specified row, column, and third dimension indices in a multi-dimensional OpenCV <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. It verifies that the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> is not disposed but does not check the validity of the indices provided.</p>
<p>The pointer returned allows direct manipulation of the data at the specified coordinates.</p>
<p><b>Note:</b> If any of the indices are out of bounds, an invalid or out-of-bounds pointer may be returned, resulting in undefined behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>The row index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of rows. </td></tr>
    <tr><td class="paramname">i1</td><td>The column index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of columns. </td></tr>
    <tr><td class="paramname">i2</td><td>The third dimension index of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> from which the pointer should be returned. Must be within the valid range of third dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer (IntPtr) to the data at the specified row, column, and third dimension of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </dd></dl>

</div>
</div>
<a id="addd23f70bc6de11173882e6b1953d470" name="addd23f70bc6de11173882e6b1953d470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd23f70bc6de11173882e6b1953d470">&#9670;&#160;</a></span>ptr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr OpenCVForUnity.CoreModule.Mat.ptr </td>
          <td>(</td>
          <td class="paramtype">params int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the specified element of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object based on the provided indices for each dimension. </p>
<p>This method returns a pointer to the data at the specified multi-dimensional indices in an OpenCV <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> object. It ensures that the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> is valid and not disposed, but does not perform bounds checking on the provided indices.</p>
<p>The pointer returned allows direct manipulation of the data at the coordinates specified by the indices.</p>
<p><b>Note:</b> If any of the indices are out of bounds, an invalid or out-of-bounds pointer may be returned, leading to undefined behavior. Ensure that the provided indices are within the valid range for each dimension of the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices specifying the coordinates in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a> across all dimensions. Each index must be within the valid range of its respective dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer (IntPtr) to the data at the specified coordinates in the <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>. </dd></dl>

</div>
</div>
<a id="a241b8ed3b4fb1ea7c8decb10b0a1087a" name="a241b8ed3b4fb1ea7c8decb10b0a1087a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241b8ed3b4fb1ea7c8decb10b0a1087a">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds elements to the bottom of the matrix. </p>
<p>The methods add one or more elements to the bottom of the matrix. They emulate the corresponding method of the STL vector class. When elem is <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html" title="n-dimensional dense array class">Mat</a>, its type and the number of columns must be the same as in the container matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Added line(s). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b1982f8a07596740a1639b0be4727e" name="a70b1982f8a07596740a1639b0be4727e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b1982f8a07596740a1639b0be4727e">&#9670;&#160;</a></span>put() <span class="overload">[1/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a byte array to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified byte array to the matrix at the given row and column. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a458a080104cbaf422917e49b0bc7e370" name="a458a080104cbaf422917e49b0bc7e370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458a080104cbaf422917e49b0bc7e370">&#9670;&#160;</a></span>put() <span class="overload">[2/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a byte array to the matrix at a specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the byte array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified byte array to the matrix at the given row and column. The number of elements specified by <em>length</em>  must be a multiple of the matrix channel count. If the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>, an exception will be thrown. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible with byte data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a9edfa2271a1985a9f071eea7cc21d2" name="a1a9edfa2271a1985a9f071eea7cc21d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9edfa2271a1985a9f071eea7cc21d2">&#9670;&#160;</a></span>put() <span class="overload">[3/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of byte values to the matrix at the given row and column, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of byte values to the matrix at the provided row and column indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaecceb90744aa8027d7b4c97017bf636" name="aaecceb90744aa8027d7b4c97017bf636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecceb90744aa8027d7b4c97017bf636">&#9670;&#160;</a></span>put() <span class="overload">[4/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of double values to the matrix at the given row and column, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The double array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of double values to the matrix at the provided row and column indices. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c5164a4fc6739c6e269ed6af0bf2c7e" name="a2c5164a4fc6739c6e269ed6af0bf2c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5164a4fc6739c6e269ed6af0bf2c7e">&#9670;&#160;</a></span>put() <span class="overload">[5/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of double values to the matrix at the given row and column, starting from the specified offset within the data array, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The double array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of double values to the matrix at the provided row and column indices, starting from the specified offset within the data array. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e1c0f854f0d9b759ebc9b2fc1d4ae33" name="a5e1c0f854f0d9b759ebc9b2fc1d4ae33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c0f854f0d9b759ebc9b2fc1d4ae33">&#9670;&#160;</a></span>put() <span class="overload">[6/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a float array to the matrix at a specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The float array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified float array to the matrix at the given row and column. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8e63442b80488044468124015bb8e21" name="aa8e63442b80488044468124015bb8e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e63442b80488044468124015bb8e21">&#9670;&#160;</a></span>put() <span class="overload">[7/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of float values to the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The float array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of float values to the matrix at the provided row and column indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32F</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f1bee0eedc737207e9f4d58c29950ce" name="a8f1bee0eedc737207e9f4d58c29950ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1bee0eedc737207e9f4d58c29950ce">&#9670;&#160;</a></span>put() <span class="overload">[8/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of float values to the matrix at the given row and column, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The float array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of float values to the matrix at the provided row and column indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32F</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeb551cdc8d566708b45513ef4702ce6" name="aeeb551cdc8d566708b45513ef4702ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb551cdc8d566708b45513ef4702ce6">&#9670;&#160;</a></span>put() <span class="overload">[9/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an int array to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The int array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified int array to the matrix at the given row and column indices. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1635016e6b7614038cd82b75d195e181" name="a1635016e6b7614038cd82b75d195e181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1635016e6b7614038cd82b75d195e181">&#9670;&#160;</a></span>put() <span class="overload">[10/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of int values to the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The int array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of int values to the matrix at the provided row and column indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1428edf5ac92c32af049a34fa5c40fc3" name="a1428edf5ac92c32af049a34fa5c40fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1428edf5ac92c32af049a34fa5c40fc3">&#9670;&#160;</a></span>put() <span class="overload">[11/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of int values to the matrix at the given row and column, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The int array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of int values to the matrix at the provided row and column indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a33d0eae5471f567303c0905ef1e75c" name="a8a33d0eae5471f567303c0905ef1e75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a33d0eae5471f567303c0905ef1e75c">&#9670;&#160;</a></span>put() <span class="overload">[12/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a double array to the matrix at the given row and column, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The double array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified double array to the matrix at the provided row and column indices. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a840a6f50d01c6ccb93525b7c51555767" name="a840a6f50d01c6ccb93525b7c51555767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840a6f50d01c6ccb93525b7c51555767">&#9670;&#160;</a></span>put() <span class="overload">[13/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a sbyte array to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified sbyte array to the matrix at the specified position. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1dbd74c6cc7b118654118f6902fe153" name="ac1dbd74c6cc7b118654118f6902fe153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dbd74c6cc7b118654118f6902fe153">&#9670;&#160;</a></span>put() <span class="overload">[14/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of sbyte values to the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of sbyte values to the matrix at the provided row and column indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3f35c7f6da6ec7972bd218c8603825b" name="ae3f35c7f6da6ec7972bd218c8603825b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f35c7f6da6ec7972bd218c8603825b">&#9670;&#160;</a></span>put() <span class="overload">[15/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of sbyte values to the matrix at the given row and column, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of sbyte values to the matrix at the provided row and column indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89935206629d1acbc59e2dc0d33ed5f3" name="a89935206629d1acbc59e2dc0d33ed5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89935206629d1acbc59e2dc0d33ed5f3">&#9670;&#160;</a></span>put() <span class="overload">[16/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short array to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The short array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified short array to the matrix at the given row and column. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea600f52b1964f3c1f543e464d2b69ef" name="aea600f52b1964f3c1f543e464d2b69ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea600f52b1964f3c1f543e464d2b69ef">&#9670;&#160;</a></span>put() <span class="overload">[17/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of short values to the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The short array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of short values to the matrix at the provided row and column indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebbd23d26022438f40106f27e2adae57" name="aebbd23d26022438f40106f27e2adae57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbd23d26022438f40106f27e2adae57">&#9670;&#160;</a></span>put() <span class="overload">[18/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of short values to the matrix at the given row and column, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The short array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of short values to the matrix at the provided row and column indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c010033f5fa376044824ba3399d483c" name="a1c010033f5fa376044824ba3399d483c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c010033f5fa376044824ba3399d483c">&#9670;&#160;</a></span>put() <span class="overload">[19/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of byte data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of byte data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8d69274812793dd61c5178a49c7b9d5" name="aa8d69274812793dd61c5178a49c7b9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d69274812793dd61c5178a49c7b9d5">&#9670;&#160;</a></span>put() <span class="overload">[20/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of byte data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of byte data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a185c509b1c77e6af866e423854fb780f" name="a185c509b1c77e6af866e423854fb780f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185c509b1c77e6af866e423854fb780f">&#9670;&#160;</a></span>put() <span class="overload">[21/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of byte data to the matrix at the specified row and column, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of byte data to the matrix at the given row and column, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b6372917b40b6cd21b90e24a83f0f40" name="a3b6372917b40b6cd21b90e24a83f0f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6372917b40b6cd21b90e24a83f0f40">&#9670;&#160;</a></span>put() <span class="overload">[22/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of double data to the matrix at the specified row and column, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of double data to the matrix at the given row and column. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc387c2b834d1616d454b874a8f145dc" name="abc387c2b834d1616d454b874a8f145dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc387c2b834d1616d454b874a8f145dc">&#9670;&#160;</a></span>put() <span class="overload">[23/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of double data to the matrix at the specified row and column, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of double data to the matrix at the given row and column The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de2107e69f0ccf3487e4ff2fe5b6403" name="a6de2107e69f0ccf3487e4ff2fe5b6403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de2107e69f0ccf3487e4ff2fe5b6403">&#9670;&#160;</a></span>put() <span class="overload">[24/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of double data to the matrix at the specified row and column, starting from the specified offset within the data array, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of double data to the matrix at the given row and column, starting from the specified offset within the data span. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28a4ff4910758c2bfd611cdf292cb788" name="a28a4ff4910758c2bfd611cdf292cb788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a4ff4910758c2bfd611cdf292cb788">&#9670;&#160;</a></span>put() <span class="overload">[25/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of float data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of float data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15235248bec15b6a4a57a8502f411bda" name="a15235248bec15b6a4a57a8502f411bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15235248bec15b6a4a57a8502f411bda">&#9670;&#160;</a></span>put() <span class="overload">[26/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of float data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of float data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa405e7aace3a490b6529035e92570af0" name="aa405e7aace3a490b6529035e92570af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa405e7aace3a490b6529035e92570af0">&#9670;&#160;</a></span>put() <span class="overload">[27/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of float data to the matrix at the specified row and column, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of float data to the matrix at the given row and column, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a755175818f61126f880bb01649ed2d" name="a7a755175818f61126f880bb01649ed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a755175818f61126f880bb01649ed2d">&#9670;&#160;</a></span>put() <span class="overload">[28/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of int data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of int data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2c97123db0c4580801810ff1cad84ff" name="af2c97123db0c4580801810ff1cad84ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c97123db0c4580801810ff1cad84ff">&#9670;&#160;</a></span>put() <span class="overload">[29/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of int data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of int data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17fb38ae971309f9c23b6429629eeed3" name="a17fb38ae971309f9c23b6429629eeed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fb38ae971309f9c23b6429629eeed3">&#9670;&#160;</a></span>put() <span class="overload">[30/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of int data to the matrix at the specified row and column, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of int data to the matrix at the given row and column, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab29611f961a387dc09c25111e60fe44d" name="ab29611f961a387dc09c25111e60fe44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29611f961a387dc09c25111e60fe44d">&#9670;&#160;</a></span>put() <span class="overload">[31/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of sbyte data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of sbyte data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a5a5dc6014a9bfa07b5df3e0d2cdb48" name="a6a5a5dc6014a9bfa07b5df3e0d2cdb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5a5dc6014a9bfa07b5df3e0d2cdb48">&#9670;&#160;</a></span>put() <span class="overload">[32/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of sbyte data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of sbyte data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac12a63d3f06b55790c4152aba3c44007" name="ac12a63d3f06b55790c4152aba3c44007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12a63d3f06b55790c4152aba3c44007">&#9670;&#160;</a></span>put() <span class="overload">[33/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of sbyte data to the matrix at the specified row and column, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of sbyte data to the matrix at the given row and column, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8883bb1a68951a35512bb601897f127" name="ab8883bb1a68951a35512bb601897f127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8883bb1a68951a35512bb601897f127">&#9670;&#160;</a></span>put() <span class="overload">[34/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of short data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of short data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2c536370f7981b652bc82f63b42f4db" name="aa2c536370f7981b652bc82f63b42f4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c536370f7981b652bc82f63b42f4db">&#9670;&#160;</a></span>put() <span class="overload">[35/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of short data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of short data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7779f949bbf3da76e84b0d8bff579e3a" name="a7779f949bbf3da76e84b0d8bff579e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7779f949bbf3da76e84b0d8bff579e3a">&#9670;&#160;</a></span>put() <span class="overload">[36/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of short data to the matrix at the specified row and column, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of short data to the matrix at the given row and column, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fcc5a7e708e665717df8d95243c24ea" name="a1fcc5a7e708e665717df8d95243c24ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcc5a7e708e665717df8d95243c24ea">&#9670;&#160;</a></span>put() <span class="overload">[37/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of ushort data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of ushort data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6994a26d34b87fad1b8127f078263012" name="a6994a26d34b87fad1b8127f078263012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6994a26d34b87fad1b8127f078263012">&#9670;&#160;</a></span>put() <span class="overload">[38/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of ushort data to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of ushort data to the matrix at the given row and column. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb155af47b321126e6ca1ca5891c4d3c" name="abb155af47b321126e6ca1ca5891c4d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb155af47b321126e6ca1ca5891c4d3c">&#9670;&#160;</a></span>put() <span class="overload">[39/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of ushort data to the matrix at the specified row and column, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of ushort data to the matrix at the given row and column, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01d27f118e5864c514f40eb30cf26e79" name="a01d27f118e5864c514f40eb30cf26e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d27f118e5864c514f40eb30cf26e79">&#9670;&#160;</a></span>put() <span class="overload">[40/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an ushort array to the matrix at the specified row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified ushort array to the matrix at the given row and column. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a7c3550577239b4df6fc6387d0d8437" name="a9a7c3550577239b4df6fc6387d0d8437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7c3550577239b4df6fc6387d0d8437">&#9670;&#160;</a></span>put() <span class="overload">[41/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of ushort values to the matrix at the given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of ushort values to the matrix at the provided row and column indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa18f92dc319fe415e6bd1ef4257d3565" name="aa18f92dc319fe415e6bd1ef4257d3565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18f92dc319fe415e6bd1ef4257d3565">&#9670;&#160;</a></span>put() <span class="overload">[42/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of ushort values to the matrix at the given row and column, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of ushort values to the matrix at the provided row and column indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53c1ea9be6b9bfe9b8eda8374620aad0" name="a53c1ea9be6b9bfe9b8eda8374620aad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c1ea9be6b9bfe9b8eda8374620aad0">&#9670;&#160;</a></span>put() <span class="overload">[43/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a byte array to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified byte array to the matrix at the given indices. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. The number of indices provided in <em>idx</em>  must match the number of dimensions of the matrix. Only matrices with a data type of <code>CV_8U</code> or <code>CV_8S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices does not match the matrix's dimensions, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea08d7e5c39fac456b829b802c188ef2" name="aea08d7e5c39fac456b829b802c188ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea08d7e5c39fac456b829b802c188ef2">&#9670;&#160;</a></span>put() <span class="overload">[44/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of byte values to the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of byte values to the matrix at the provided indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices does not match the matrix's dimensionality, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee4da73bb973f1229e675722fbd83e9e" name="aee4da73bb973f1229e675722fbd83e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4da73bb973f1229e675722fbd83e9e">&#9670;&#160;</a></span>put() <span class="overload">[45/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of byte values to the matrix at the given indices, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The byte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of byte values to the matrix at the provided indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4684d58ac209bbbfc5f2a8182f234049" name="a4684d58ac209bbbfc5f2a8182f234049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4684d58ac209bbbfc5f2a8182f234049">&#9670;&#160;</a></span>put() <span class="overload">[46/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of double values to the matrix at the given indices, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array specifying the multi-dimensional indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The double array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of double values to the matrix at the provided indices indices. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51558bab992c19081c6257bd9c11689b" name="a51558bab992c19081c6257bd9c11689b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51558bab992c19081c6257bd9c11689b">&#9670;&#160;</a></span>put() <span class="overload">[47/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of double values to the matrix at the given indices, starting from the specified offset within the data array, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array specifying the multi-dimensional indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The double array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of double values to the matrix at the provided indices, starting from the specified offset within the data array. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b03be1fc4ae6ec9f25952e14e96d71b" name="a0b03be1fc4ae6ec9f25952e14e96d71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b03be1fc4ae6ec9f25952e14e96d71b">&#9670;&#160;</a></span>put() <span class="overload">[48/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a float array to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array specifying the multi-dimensional indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The float array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified float array to the matrix at the given multi-dimensional indices. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. Only matrices with a data type of <code>CV_32F</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices in <em>idx</em>  does not match the matrix's dimensionality, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac61ed515651bf3db5272de8464556dd" name="aac61ed515651bf3db5272de8464556dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac61ed515651bf3db5272de8464556dd">&#9670;&#160;</a></span>put() <span class="overload">[49/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of float values to the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The float array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of float values to the matrix at the provided indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32F</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a097204bc9674e65bc16c480d226bfc9f" name="a097204bc9674e65bc16c480d226bfc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097204bc9674e65bc16c480d226bfc9f">&#9670;&#160;</a></span>put() <span class="overload">[50/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of float values to the matrix at the given indices, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The float array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of float values to the matrix at the provided indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32F</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32F</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a177c81a4ebb2675512257f5e9cb06c76" name="a177c81a4ebb2675512257f5e9cb06c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c81a4ebb2675512257f5e9cb06c76">&#9670;&#160;</a></span>put() <span class="overload">[51/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an int array to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The int array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified int array to the matrix at the given indices. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. The number of indices provided must match the number of dimensions of the matrix. Only matrices with a data type of <code>CV_32S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices does not match the matrix's dimensions, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae074f0b994aa9adb1158bc8e94af2cc" name="aae074f0b994aa9adb1158bc8e94af2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae074f0b994aa9adb1158bc8e94af2cc">&#9670;&#160;</a></span>put() <span class="overload">[52/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of int values to the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The int array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of int values to the matrix at the provided indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6b1957c5e5185ffc41303d4d81f84a8" name="ae6b1957c5e5185ffc41303d4d81f84a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b1957c5e5185ffc41303d4d81f84a8">&#9670;&#160;</a></span>put() <span class="overload">[53/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of int values to the matrix at the given indices, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The int array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of int values to the matrix at the provided indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_32S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_32S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7638db6178dda563562d3b23415e7dd5" name="a7638db6178dda563562d3b23415e7dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7638db6178dda563562d3b23415e7dd5">&#9670;&#160;</a></span>put() <span class="overload">[54/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params double[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a double array to the matrix at the given indices, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array specifying the multi-dimensional indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The double array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified double array to the matrix at the provided indices. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5a10e4a652ee3416e8ac181e2a8e0ec" name="aa5a10e4a652ee3416e8ac181e2a8e0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a10e4a652ee3416e8ac181e2a8e0ec">&#9670;&#160;</a></span>put() <span class="overload">[55/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a sbyte array to the matrix at the specified multi-dimensional indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices specifying the position in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified array of sbyte array to the matrix at the given multi-dimensional indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of provided indices does not match the matrix's dimensions, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1928333f566024fe466e9e43f3d11f2" name="ae1928333f566024fe466e9e43f3d11f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1928333f566024fe466e9e43f3d11f2">&#9670;&#160;</a></span>put() <span class="overload">[56/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of sbyte values to the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of sbyte values to the matrix at the provided indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23eeac63b6ed70fd59b86f49782f15d5" name="a23eeac63b6ed70fd59b86f49782f15d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23eeac63b6ed70fd59b86f49782f15d5">&#9670;&#160;</a></span>put() <span class="overload">[57/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sbyte[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of sbyte values to the matrix at the given indices, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The sbyte array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of sbyte values to the matrix at the provided indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_8U</code> or <code>CV_8S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_8U</code> or <code>CV_8S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d0d9cb266e6ef1240342a0a1e0c8ad4" name="a9d0d9cb266e6ef1240342a0a1e0c8ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0d9cb266e6ef1240342a0a1e0c8ad4">&#9670;&#160;</a></span>put() <span class="overload">[58/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short array to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>An array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The short array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified short array to the matrix at the given indices. The number of elements in the <em>data</em>  array must be a multiple of the matrix's channel count. The number of indices provided must match the matrix's dimensions. Only matrices with a data type of <code>CV_16U</code> or <code>CV_16S</code> are compatible with this method. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices does not match the matrix's dimensions, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4d995539c1551c152eeb6d7427fd1a2" name="ab4d995539c1551c152eeb6d7427fd1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d995539c1551c152eeb6d7427fd1a2">&#9670;&#160;</a></span>put() <span class="overload">[59/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of short values to the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The short array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of short values to the matrix at the provided indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8b4522f397514f9f18655ccc1101943" name="ad8b4522f397514f9f18655ccc1101943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b4522f397514f9f18655ccc1101943">&#9670;&#160;</a></span>put() <span class="overload">[60/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of short values to the matrix at the given indices, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The short array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of short values to the matrix at the provided indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0060c259f71a7e9a1361637c9da8a307" name="a0060c259f71a7e9a1361637c9da8a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0060c259f71a7e9a1361637c9da8a307">&#9670;&#160;</a></span>put() <span class="overload">[61/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of byte data to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of byte data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711c294050473ea988d9815ecc78f93b" name="a711c294050473ea988d9815ecc78f93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711c294050473ea988d9815ecc78f93b">&#9670;&#160;</a></span>put() <span class="overload">[62/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of byte data to the matrix at the specified indices with a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of byte data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff98250bb5468e5134cc06cb9f9c5335" name="aff98250bb5468e5134cc06cb9f9c5335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff98250bb5468e5134cc06cb9f9c5335">&#9670;&#160;</a></span>put() <span class="overload">[63/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; byte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of byte data to the matrix at the specified indices, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of byte data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of byte data to the matrix at the given indices, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add99fd4a8b4fd9474714a28a1b6a5a96" name="add99fd4a8b4fd9474714a28a1b6a5a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add99fd4a8b4fd9474714a28a1b6a5a96">&#9670;&#160;</a></span>put() <span class="overload">[64/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of double data to the matrix at the specified indices, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of double data to the matrix at the given indices. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1833cfc7e8d9ed5764fb388645f1805" name="ab1833cfc7e8d9ed5764fb388645f1805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1833cfc7e8d9ed5764fb388645f1805">&#9670;&#160;</a></span>put() <span class="overload">[65/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of double data to the matrix at the specified indices with a specified length, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of double data to the matrix at the given indices. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82cdb6066f5b97dc0af037f1246121e9" name="a82cdb6066f5b97dc0af037f1246121e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cdb6066f5b97dc0af037f1246121e9">&#9670;&#160;</a></span>put() <span class="overload">[66/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of double data to the matrix at the specified indices, starting from the specified offset within the data span, casting them to match the matrix's data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of double data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of double data to the matrix at the given indices, starting from the specified offset within the data span. The values are automatically cast to match the matrix's data type. The number of elements written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, or if the number of elements is not a multiple of the matrix's channel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac68a9d3a799117a67b33ff74bdc45c8e" name="ac68a9d3a799117a67b33ff74bdc45c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68a9d3a799117a67b33ff74bdc45c8e">&#9670;&#160;</a></span>put() <span class="overload">[67/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of float data to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of float data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d753cae687adb4eb2d34e0989ed79f" name="a03d753cae687adb4eb2d34e0989ed79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d753cae687adb4eb2d34e0989ed79f">&#9670;&#160;</a></span>put() <span class="overload">[68/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of float data to the matrix at the specified indices with a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of float data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a698f6ca3d869a7b5b9a7f22328b521c5" name="a698f6ca3d869a7b5b9a7f22328b521c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698f6ca3d869a7b5b9a7f22328b521c5">&#9670;&#160;</a></span>put() <span class="overload">[69/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of float data to the matrix at the specified indices, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of float data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of float data to the matrix at the given indices, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e9ec1223720689f3c92a3d4c16967de" name="a6e9ec1223720689f3c92a3d4c16967de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9ec1223720689f3c92a3d4c16967de">&#9670;&#160;</a></span>put() <span class="overload">[70/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of int data to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of int data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42c0e5a543242cb372829a8f5cb7785e" name="a42c0e5a543242cb372829a8f5cb7785e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c0e5a543242cb372829a8f5cb7785e">&#9670;&#160;</a></span>put() <span class="overload">[71/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of int data to the matrix at the specified indices with a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of int data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f95fb756eae6b1381e5b5e21551994e" name="a7f95fb756eae6b1381e5b5e21551994e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f95fb756eae6b1381e5b5e21551994e">&#9670;&#160;</a></span>put() <span class="overload">[72/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of int data to the matrix at the specified indices, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of int data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of int data to the matrix at the given indices, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac13bf7a15739caf8cd7dbeac551bf454" name="ac13bf7a15739caf8cd7dbeac551bf454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13bf7a15739caf8cd7dbeac551bf454">&#9670;&#160;</a></span>put() <span class="overload">[73/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of sbyte data to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of sbyte data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f2c8b7a51dc27b5e49472765051e4fa" name="a7f2c8b7a51dc27b5e49472765051e4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2c8b7a51dc27b5e49472765051e4fa">&#9670;&#160;</a></span>put() <span class="overload">[74/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of sbyte data to the matrix at the specified indices with a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of sbyte data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fd89e629b8a297e7696be7329a129b3" name="a4fd89e629b8a297e7696be7329a129b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd89e629b8a297e7696be7329a129b3">&#9670;&#160;</a></span>put() <span class="overload">[75/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; sbyte &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of sbyte data to the matrix at the specified indices, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of sbyte data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of sbyte data to the matrix at the given indices, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ad3142478dff00671b03c7f8ebad5c5" name="a5ad3142478dff00671b03c7f8ebad5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad3142478dff00671b03c7f8ebad5c5">&#9670;&#160;</a></span>put() <span class="overload">[76/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of short data to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of short data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98fa1b06e45811cc69b83b28f9eb6b70" name="a98fa1b06e45811cc69b83b28f9eb6b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fa1b06e45811cc69b83b28f9eb6b70">&#9670;&#160;</a></span>put() <span class="overload">[77/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of short data to the matrix at the specified indices with a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of short data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b16bcdcbe70000c0af293d5dd6445ed" name="a2b16bcdcbe70000c0af293d5dd6445ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b16bcdcbe70000c0af293d5dd6445ed">&#9670;&#160;</a></span>put() <span class="overload">[78/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; short &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of short data to the matrix at the specified indices, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of short data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of short data to the matrix at the given indices, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e75e9682cf316d61b248368ba47585e" name="a7e75e9682cf316d61b248368ba47585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e75e9682cf316d61b248368ba47585e">&#9670;&#160;</a></span>put() <span class="overload">[79/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of ushort data to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of ushort data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a648f1531b9c06928338338d0b868752c" name="a648f1531b9c06928338338d0b868752c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648f1531b9c06928338338d0b868752c">&#9670;&#160;</a></span>put() <span class="overload">[80/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of ushort data to the matrix at the specified indices with a specified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of ushort data to the matrix at the given indices. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd86b7ed985f2f2a91c685a71efd0f27" name="afd86b7ed985f2f2a91c685a71efd0f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd86b7ed985f2f2a91c685a71efd0f27">&#9670;&#160;</a></span>put() <span class="overload">[81/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; ushort &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of ushort data to the matrix at the specified indices, starting from the specified offset within the data span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of ushort data to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the span from which to start writing data.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of ushort data to the matrix at the given indices, starting from the specified offset within the data span. The length of the span written must be a multiple of the matrix's channel count. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the length of the provided span is not a multiple of the matrix's channel count, or if the matrix's data type is not compatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af311092c6edc12608a6b6dd1f5e55212" name="af311092c6edc12608a6b6dd1f5e55212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af311092c6edc12608a6b6dd1f5e55212">&#9670;&#160;</a></span>put() <span class="overload">[82/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an ushort array to the matrix at the specified indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array containing the data elements to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified nsigned short array to the matrix at the given indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, if the number of indices does not match the matrix's dimensionality, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7667e0db1ebf4c64c8a0fc9d879af5a" name="ab7667e0db1ebf4c64c8a0fc9d879af5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7667e0db1ebf4c64c8a0fc9d879af5a">&#9670;&#160;</a></span>put() <span class="overload">[83/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of ushort values to the matrix at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array containing the data elements to write.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of ushort values to the matrix at the provided indices. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8087fb8cf28d3870e19fd1038ff5823e" name="a8087fb8cf28d3870e19fd1038ff5823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087fb8cf28d3870e19fd1038ff5823e">&#9670;&#160;</a></span>put() <span class="overload">[84/84]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.put </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a specified number of ushort values to the matrix at the given indices, starting from the specified offset within the data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array of indices where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The ushort array containing the data elements to write.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the data array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified number of ushort values to the matrix at the provided indices, starting from the specified offset within the data array. The number of elements written must be a multiple of the matrix's channel count. The matrix must be of type <code>CV_16U</code> or <code>CV_16S</code> for compatibility. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the data array is null, if the number of elements is not a multiple of the matrix's channel count, or if the number of indices is incorrect, or if the matrix's data type is not <code>CV_16U</code> or <code>CV_16S</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfadb4e5cf544d0ddf5fd7d0812c4957" name="adfadb4e5cf544d0ddf5fd7d0812c4957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfadb4e5cf544d0ddf5fd7d0812c4957">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of type <em>T</em>  to the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of type <em>T</em>  to the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aeeb6e2df44000fbd0ede92a60db8e120" name="aeeb6e2df44000fbd0ede92a60db8e120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb6e2df44000fbd0ede92a60db8e120">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of type <em>T</em>  to the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified span of type <em>T</em>  to the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa6f484c619d8399d1b1de59bae102933" name="aa6f484c619d8399d1b1de59bae102933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f484c619d8399d1b1de59bae102933">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of type <em>T</em>  to the matrix at the specified row and column, starting from the specified offset within the data span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data span from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified span of type <em>T</em>  to the matrix at the given row and column, starting from the specified offset within the data span. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abd3f76992056753813d3dc8eee761f2b" name="abd3f76992056753813d3dc8eee761f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3f76992056753813d3dc8eee761f2b">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of type <em>T</em>  to the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified array of type <em>T</em>  to the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a126fd9e18f2aac899c766a213fea56b1" name="a126fd9e18f2aac899c766a213fea56b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126fd9e18f2aac899c766a213fea56b1">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of type <em>T</em>  to the matrix at the specified row and column. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified array of type <em>T</em>  to the matrix at the given row and column. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abbb61a0d7dcc4e6a0b7020777439ca42" name="abbb61a0d7dcc4e6a0b7020777439ca42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb61a0d7dcc4e6a0b7020777439ca42">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of type <em>T</em>  to the matrix at the specified row and column, starting from the specified offset within the data array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">col</td><td>The column index in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified array of type <em>T</em>  to the matrix at the given row and column, starting from the specified offset within the data array. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1a4790a0a803cc0912650ea64c7658d8" name="a1a4790a0a803cc0912650ea64c7658d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4790a0a803cc0912650ea64c7658d8">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of type <em>T</em>  to the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified span of type <em>T</em>  to the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a712b0311ea2e60a653b5c6df70fa682c" name="a712b0311ea2e60a653b5c6df70fa682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712b0311ea2e60a653b5c6df70fa682c">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of type <em>T</em>  to the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified span of type <em>T</em>  to the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa0d4549bbe0af7d6e16e43beb769c1bd" name="aa0d4549bbe0af7d6e16e43beb769c1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d4549bbe0af7d6e16e43beb769c1bd">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a span of type <em>T</em>  to the matrix at the specified indices, starting from the specified offset within the data span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The span of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data span from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified span of type <em>T</em>  to the matrix at the given indices, starting from the specified offset within the data span. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aaa1bea47833afc5a89791a4c11e29e25" name="aaa1bea47833afc5a89791a4c11e29e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1bea47833afc5a89791a4c11e29e25">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of type <em>T</em>  to the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to write to the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes the specified array of type <em>T</em>  to the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a10f3018291ff94083b1ce03235be36f2" name="a10f3018291ff94083b1ce03235be36f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f3018291ff94083b1ce03235be36f2">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of type <em>T</em>  to the matrix at the specified indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified array of type <em>T</em>  to the matrix at the given indices. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="adcc7e469a1e61374e4c99515080e5edf" name="adcc7e469a1e61374e4c99515080e5edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc7e469a1e61374e4c99515080e5edf">&#9670;&#160;</a></span>put&lt; T &gt;() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="#a8a33d0eae5471f567303c0905ef1e75c">OpenCVForUnity.CoreModule.Mat.put</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of type <em>T</em>  to the matrix at the specified indices, starting from the specified offset within the data array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The unmanaged type of the data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The indices in the matrix where the data will be written.</td></tr>
    <tr><td class="paramname">data</td><td>The array of type <em>T</em>  to write to the matrix.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset in the data array from which to start writing elements.</td></tr>
    <tr><td class="paramname">length</td><td>The number of elements to write from the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements successfully written to the matrix.</dd></dl>
<p>This method writes a specified array of type <em>T</em>  to the matrix at the given indices, starting from the specified offset within the data array. The size of the type <em>T</em>  must be compatible with the matrix element size. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_cv_exception.html" title="The exception that is thrown by OpenCVForUntiy.">CvException</a></td><td>Thrown if the matrix is disposed or if the size of the provided type <em>T</em>  is not compatible with the matrix element size. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a034d3e2b4ce0d37e7058ce55e8b1899b" name="a034d3e2b4ce0d37e7058ce55e8b1899b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034d3e2b4ce0d37e7058ce55e8b1899b">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVForUnity.CoreModule.Mat.release </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the reference counter and deallocates the matrix if needed. </p>
<p>The method decrements the reference counter associated with the matrix data. When the reference counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers are set to NULL's. If the matrix header points to an external data set (see <a class="el" href="#aa72bf9d9607cbb0af6e4e3f11bd8b9ba">Mat.Mat</a>), the reference counter is NULL, and the method has no effect in this case.</p>
<p>This method can be called manually to force the matrix data deallocation. But since this method is automatically called in the destructor, or by any other method that changes the data pointer, it is usually not needed. The reference counter decrement and check for 0 is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads. </p>

</div>
</div>
<a id="a5af58355f22f240f11903799c4715d71" name="a5af58355f22f240f11903799c4715d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af58355f22f240f11903799c4715d71">&#9670;&#160;</a></span>reshape() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.reshape </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the shape and/or the number of channels of a 2D matrix without copying the data. </p>
<p>The method makes a new matrix header for *this elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if:</p><ul>
<li>No extra elements are included into the new matrix and no elements are excluded. Consequently, the product rows*cols*channels() must stay the same after the transformation.</li>
<li>No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row in some other way, the matrix must be continuous. See <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous</a>.</li>
</ul>
<p>For example, if there is a set of 3D points stored as an STL vector, and you want to represent the points as a 3xN matrix, do the following: </p>
<div class="fragment"><div class="line">std::vector&lt;Point3f&gt; vec;</div>
<div class="line">...</div>
<div class="line">Mat pointMat = <a class="code hl_function" href="#a2dab3c9cf93248d9ebe1d13a4b453e3e">Mat</a>(vec). <span class="comment">// convert vector to Mat, O(1) operation</span></div>
<div class="line">                  <a class="code hl_function" href="#a9494b45ba5c2e9a65d753ca6a11ffe1a">reshape</a>(1). <span class="comment">// make Nx3 1-channel matrix out of Nx1 3-channel.</span></div>
<div class="line">                              <span class="comment">// Also, an O(1) operation</span></div>
<div class="line">                     <a class="code hl_function" href="#a2c93fdb9e80d98c05d7167ef747de2c1">t</a>(); <span class="comment">// finally, transpose the Nx3 matrix.</span></div>
<div class="line">                              <span class="comment">// This involves copying all the elements</span></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a2c93fdb9e80d98c05d7167ef747de2c1"><div class="ttname"><a href="#a2c93fdb9e80d98c05d7167ef747de2c1">OpenCVForUnity.CoreModule.Mat.t</a></div><div class="ttdeci">Mat t()</div><div class="ttdoc">Transposes a matrix.</div><div class="ttdef"><b>Definition</b> Mat.cs:2567</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a2dab3c9cf93248d9ebe1d13a4b453e3e"><div class="ttname"><a href="#a2dab3c9cf93248d9ebe1d13a4b453e3e">OpenCVForUnity.CoreModule.Mat.Mat</a></div><div class="ttdeci">Mat()</div><div class="ttdef"><b>Definition</b> Mat.cs:83</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a9494b45ba5c2e9a65d753ca6a11ffe1a"><div class="ttname"><a href="#a9494b45ba5c2e9a65d753ca6a11ffe1a">OpenCVForUnity.CoreModule.Mat.reshape</a></div><div class="ttdeci">Mat reshape(int cn, int rows)</div><div class="ttdoc">Changes the shape and/or the number of channels of a 2D matrix without copying the data.</div><div class="ttdef"><b>Definition</b> Mat.cs:2011</div></div>
</div><!-- fragment --> <p>3-channel 2x2 matrix reshaped to 1-channel 4x3 matrix, each column has values from one of original channels: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m(<a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(2, 2), CV_8UC3, <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(1, 2, 3));</div>
<div class="line">vector&lt;int&gt; new_shape {4, 3};</div>
<div class="line">m = m.reshape(1, new_shape);</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_scalar_html"><div class="ttname"><a href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">OpenCVForUnity.CoreModule.Scalar</a></div><div class="ttdoc">Template class for a 4-element vector derived from Vec.</div><div class="ttdef"><b>Definition</b> Scalar_Ex.cs:9</div></div>
</div><!-- fragment --> <p>or: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m(<a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(2, 2), CV_8UC3, <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(1, 2, 3));</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> new_shape[] = {4, 3};</div>
<div class="line">m = m.reshape(1, 2, new_shape);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>New number of channels. If the parameter is 0, the number of channels remains the same. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9494b45ba5c2e9a65d753ca6a11ffe1a" name="a9494b45ba5c2e9a65d753ca6a11ffe1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9494b45ba5c2e9a65d753ca6a11ffe1a">&#9670;&#160;</a></span>reshape() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.reshape </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the shape and/or the number of channels of a 2D matrix without copying the data. </p>
<p>The method makes a new matrix header for *this elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if:</p><ul>
<li>No extra elements are included into the new matrix and no elements are excluded. Consequently, the product rows*cols*channels() must stay the same after the transformation.</li>
<li>No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row in some other way, the matrix must be continuous. See <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous</a>.</li>
</ul>
<p>For example, if there is a set of 3D points stored as an STL vector, and you want to represent the points as a 3xN matrix, do the following: </p>
<div class="fragment"><div class="line">std::vector&lt;Point3f&gt; vec;</div>
<div class="line">...</div>
<div class="line">Mat pointMat = <a class="code hl_function" href="#a2dab3c9cf93248d9ebe1d13a4b453e3e">Mat</a>(vec). <span class="comment">// convert vector to Mat, O(1) operation</span></div>
<div class="line">                  <a class="code hl_function" href="#a9494b45ba5c2e9a65d753ca6a11ffe1a">reshape</a>(1). <span class="comment">// make Nx3 1-channel matrix out of Nx1 3-channel.</span></div>
<div class="line">                              <span class="comment">// Also, an O(1) operation</span></div>
<div class="line">                     <a class="code hl_function" href="#a2c93fdb9e80d98c05d7167ef747de2c1">t</a>(); <span class="comment">// finally, transpose the Nx3 matrix.</span></div>
<div class="line">                              <span class="comment">// This involves copying all the elements</span></div>
</div><!-- fragment --> <p>3-channel 2x2 matrix reshaped to 1-channel 4x3 matrix, each column has values from one of original channels: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m(<a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(2, 2), CV_8UC3, <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(1, 2, 3));</div>
<div class="line">vector&lt;int&gt; new_shape {4, 3};</div>
<div class="line">m = m.reshape(1, new_shape);</div>
</div><!-- fragment --> <p>or: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m(<a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(2, 2), CV_8UC3, <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(1, 2, 3));</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> new_shape[] = {4, 3};</div>
<div class="line">m = m.reshape(1, 2, new_shape);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>New number of channels. If the parameter is 0, the number of channels remains the same. </td></tr>
    <tr><td class="paramname">rows</td><td>New number of rows. If the parameter is 0, the number of rows remains the same. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada118abf428f03501c6c89f94d8aa36b" name="ada118abf428f03501c6c89f94d8aa36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada118abf428f03501c6c89f94d8aa36b">&#9670;&#160;</a></span>reshape() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.reshape </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>newshape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the shape and/or the number of channels of a 2D matrix without copying the data. </p>
<p>The method makes a new matrix header for *this elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if:</p><ul>
<li>No extra elements are included into the new matrix and no elements are excluded. Consequently, the product rows*cols*channels() must stay the same after the transformation.</li>
<li>No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row in some other way, the matrix must be continuous. See <a class="el" href="#a63d3d12b95ce8f9bcb7b61dc78de6275" title="Reports whether the matrix is continuous or not.">Mat.isContinuous</a>.</li>
</ul>
<p>For example, if there is a set of 3D points stored as an STL vector, and you want to represent the points as a 3xN matrix, do the following: </p>
<div class="fragment"><div class="line">std::vector&lt;Point3f&gt; vec;</div>
<div class="line">...</div>
<div class="line">Mat pointMat = <a class="code hl_function" href="#a2dab3c9cf93248d9ebe1d13a4b453e3e">Mat</a>(vec). <span class="comment">// convert vector to Mat, O(1) operation</span></div>
<div class="line">                  <a class="code hl_function" href="#a9494b45ba5c2e9a65d753ca6a11ffe1a">reshape</a>(1). <span class="comment">// make Nx3 1-channel matrix out of Nx1 3-channel.</span></div>
<div class="line">                              <span class="comment">// Also, an O(1) operation</span></div>
<div class="line">                     <a class="code hl_function" href="#a2c93fdb9e80d98c05d7167ef747de2c1">t</a>(); <span class="comment">// finally, transpose the Nx3 matrix.</span></div>
<div class="line">                              <span class="comment">// This involves copying all the elements</span></div>
</div><!-- fragment --> <p>3-channel 2x2 matrix reshaped to 1-channel 4x3 matrix, each column has values from one of original channels: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m(<a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(2, 2), CV_8UC3, <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(1, 2, 3));</div>
<div class="line">vector&lt;int&gt; new_shape {4, 3};</div>
<div class="line">m = m.reshape(1, new_shape);</div>
</div><!-- fragment --> <p>or: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> m(<a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a>(2, 2), CV_8UC3, <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a>(1, 2, 3));</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> new_shape[] = {4, 3};</div>
<div class="line">m = m.reshape(1, 2, new_shape);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>New number of channels. If the parameter is 0, the number of channels remains the same. </td></tr>
    <tr><td class="paramname">newshape</td><td>Vector with new matrix size by all dimentions. If some sizes are zero, the original sizes in those dimensions are presumed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0109de8c8bfbbd232a29268091ffdbb" name="ab0109de8c8bfbbd232a29268091ffdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0109de8c8bfbbd232a29268091ffdbb">&#9670;&#160;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.row </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified matrix row. </p>
<p>The method makes a new header for the specified matrix row and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. Here is the example of one of the classical basic matrix processing operations, axpy, used by LU and many other algorithms: </p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> matrix_axpy(<a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>&amp;amp; A, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">double</span> alpha)</div>
<div class="line">{</div>
<div class="line">    A.row(i) += A.row(j)*alpha;</div>
<div class="line">}</div>
</div><!-- fragment --> <p>In the current implementation, the following code does not work as expected: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A;</div>
<div class="line">...</div>
<div class="line">A.<a class="code hl_function" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>(i) = A.<a class="code hl_function" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>(j); <span class="comment">// will not work</span></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_ab0109de8c8bfbbd232a29268091ffdbb"><div class="ttname"><a href="#ab0109de8c8bfbbd232a29268091ffdbb">OpenCVForUnity.CoreModule.Mat.row</a></div><div class="ttdeci">Mat row(int y)</div><div class="ttdoc">Creates a matrix header for the specified matrix row.</div><div class="ttdef"><b>Definition</b> Mat.cs:2181</div></div>
</div><!-- fragment --> <p>This happens because A.row(i) forms a temporary header that is further assigned to another header. Remember that each of these operations is O(1), that is, no data is copied. Thus, the above assignment is not true if you may have expected the j-th row to be copied to the i-th row. To achieve that, you should either turn this simple assignment into an expression or use the <a class="el" href="#a2acada63cfb833b34c63965b16be65d6" title="Copies the matrix to another one.">Mat.copyTo</a> method: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// works, but looks a bit obscure.</span></div>
<div class="line">A.<a class="code hl_function" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>(i) = A.<a class="code hl_function" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>(j) + 0;</div>
<div class="line"><span class="comment">// this is a bit longer, but the recommended method.</span></div>
<div class="line">A.<a class="code hl_function" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>(j).<a class="code hl_function" href="#a2acada63cfb833b34c63965b16be65d6">copyTo</a>(A.<a class="code hl_function" href="#ab0109de8c8bfbbd232a29268091ffdbb">row</a>(i));</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a2acada63cfb833b34c63965b16be65d6"><div class="ttname"><a href="#a2acada63cfb833b34c63965b16be65d6">OpenCVForUnity.CoreModule.Mat.copyTo</a></div><div class="ttdeci">void copyTo(Mat m)</div><div class="ttdoc">Copies the matrix to another one.</div><div class="ttdef"><b>Definition</b> Mat.cs:988</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A 0-based row index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f5d7d7e581010f0d65684c417ce3787" name="a9f5d7d7e581010f0d65684c417ce3787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5d7d7e581010f0d65684c417ce3787">&#9670;&#160;</a></span>rowRange() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.rowRange </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified row span. </p>
<p>The method makes a new header for the specified row span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> structure containing both the start and the end indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e2fe9e9b0b54ac6163baf6ca13cc982" name="a6e2fe9e9b0b54ac6163baf6ca13cc982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2fe9e9b0b54ac6163baf6ca13cc982">&#9670;&#160;</a></span>rowRange() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.rowRange </td>
          <td>(</td>
          <td class="paramtype">in(int start, int end)</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified row span. </p>
<p>The method makes a new header for the specified row span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> structure containing both the start and the end indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfb0424ec8cde559cb1c2343e863e127" name="acfb0424ec8cde559cb1c2343e863e127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb0424ec8cde559cb1c2343e863e127">&#9670;&#160;</a></span>rowRange() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.rowRange </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>endrow</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified row span. </p>
<p>The method makes a new header for the specified row span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startrow</td><td>An inclusive 0-based start index of the row span. </td></tr>
    <tr><td class="paramname">endrow</td><td>An exclusive 0-based ending index of the row span. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a743deb2f14606f07ebba5a4a0722e5d6" name="a743deb2f14606f07ebba5a4a0722e5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743deb2f14606f07ebba5a4a0722e5d6">&#9670;&#160;</a></span>rowRange() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.rowRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix header for the specified row span. </p>
<p>The method makes a new header for the specified row span of the matrix. Similarly to <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a> and <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, this is an O(1) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> structure containing both the start and the end indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9877819470ffa970b88727037342d458" name="a9877819470ffa970b88727037342d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9877819470ffa970b88727037342d458">&#9670;&#160;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of rows in the matrix; -1 when the matrix has more than 2 dimensions </p>

</div>
</div>
<a id="a1d3f11b681d473739b68617b63dc56dd" name="a1d3f11b681d473739b68617b63dc56dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3f11b681d473739b68617b63dc56dd">&#9670;&#160;</a></span>setTo() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Assigned scalar converted to the actual array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1452b509297dca05f465f611c1425436" name="a1452b509297dca05f465f611c1425436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1452b509297dca05f465f611c1425436">&#9670;&#160;</a></span>setTo() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4d.html">Vec4d</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Assigned scalar converted to the actual array type. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab196de2dc7dd6f6bbb05215c7af684f5" name="ab196de2dc7dd6f6bbb05215c7af684f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab196de2dc7dd6f6bbb05215c7af684f5">&#9670;&#160;</a></span>setTo() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype">in(double v0, double v1, double v2, double v3)</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Assigned scalar converted to the actual array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef63f701bcf60dc6a28251ac4cb6015" name="aeef63f701bcf60dc6a28251ac4cb6015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef63f701bcf60dc6a28251ac4cb6015">&#9670;&#160;</a></span>setTo() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype">in(double v0, double v1, double v2, double v3)</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Assigned scalar converted to the actual array type. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c5fc0fe15f1f8a7631ad1a93359537c" name="a5c5fc0fe15f1f8a7631ad1a93359537c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5fc0fe15f1f8a7631ad1a93359537c">&#9670;&#160;</a></span>setTo() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Assigned scalar converted to the actual array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa10091848ca8380610a2b0fed62c5891" name="aa10091848ca8380610a2b0fed62c5891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10091848ca8380610a2b0fed62c5891">&#9670;&#160;</a></span>setTo() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Assigned scalar converted to the actual array type. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad18e915ae5367254558ae21a1b45664c" name="ad18e915ae5367254558ae21a1b45664c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18e915ae5367254558ae21a1b45664c">&#9670;&#160;</a></span>setTo() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Assigned scalar converted to the actual array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae059646f6d862a774822dfed11c1bbb5" name="ae059646f6d862a774822dfed11c1bbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae059646f6d862a774822dfed11c1bbb5">&#9670;&#160;</a></span>setTo() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.setTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html">Scalar</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specified value. </p>
<p>This is an advanced variant of the Mat.operator=(const <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_scalar.html" title="Template class for a 4-element vector derived from Vec.">Scalar</a>&amp; s) operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Assigned scalar converted to the actual array type. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask of the same size as *this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd78d83d7206bf4c4ee61850bf4d0375" name="abd78d83d7206bf4c4ee61850bf4d0375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd78d83d7206bf4c4ee61850bf4d0375">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a> OpenCVForUnity.CoreModule.Mat.size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the array of sizes, or NULL if the matrix is not allocated </p>

</div>
</div>
<a id="ac5c01e126e9f2b5ac5753377907c34fc" name="ac5c01e126e9f2b5ac5753377907c34fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c01e126e9f2b5ac5753377907c34fc">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.size </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the size of i-th matrix dimension (or 0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20c11d62ff655b5786f29ac391dc7d50" name="a20c11d62ff655b5786f29ac391dc7d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c11d62ff655b5786f29ac391dc7d50">&#9670;&#160;</a></span>sizeAsValueTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a> OpenCVForUnity.CoreModule.Mat.sizeAsValueTuple </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a310afd4ff744ff488066b972403b90cd" name="a310afd4ff744ff488066b972403b90cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310afd4ff744ff488066b972403b90cd">&#9670;&#160;</a></span>sizeAsVec2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a> OpenCVForUnity.CoreModule.Mat.sizeAsVec2d </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the array of sizes, or NULL if the matrix is not allocated </p>

</div>
</div>
<a id="a8b88cb2fd7eb23ae0d60e657f8d579aa" name="a8b88cb2fd7eb23ae0d60e657f8d579aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b88cb2fd7eb23ae0d60e657f8d579aa">&#9670;&#160;</a></span>step1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long OpenCVForUnity.CoreModule.Mat.step1 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a normalized step. </p>
<p>The method returns a matrix step divided by <a class="el" href="#a725885019d65746f656ff5697b00033f" title="Returns the size of each matrix element channel in bytes.">Mat.elemSize1()</a>. It can be useful to quickly access an arbitrary matrix element. </p>

</div>
</div>
<a id="a2c5af46909a86d548e62e64912547f20" name="a2c5af46909a86d548e62e64912547f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5af46909a86d548e62e64912547f20">&#9670;&#160;</a></span>step1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long OpenCVForUnity.CoreModule.Mat.step1 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a normalized step. </p>
<p>The method returns a matrix step divided by <a class="el" href="#a725885019d65746f656ff5697b00033f" title="Returns the size of each matrix element channel in bytes.">Mat.elemSize1()</a>. It can be useful to quickly access an arbitrary matrix element. </p>

</div>
</div>
<a id="a71af73d3b035f9cf935e762604f63f20" name="a71af73d3b035f9cf935e762604f63f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71af73d3b035f9cf935e762604f63f20">&#9670;&#160;</a></span>submat() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a></td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a></td>          <td class="paramname"><span class="paramname"><em>colRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
<div class="ttc" id="a_imgcodecs_8cs_html_a95a9660ae50043791ee5175022933c91"><div class="ttname"><a href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a></div><div class="ttdeci">OpenCVForUnity.CoreModule.Range Range</div><div class="ttdef"><b>Definition</b> Imgcodecs.cs:7</div></div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_acfb0424ec8cde559cb1c2343e863e127"><div class="ttname"><a href="#acfb0424ec8cde559cb1c2343e863e127">OpenCVForUnity.CoreModule.Mat.rowRange</a></div><div class="ttdeci">Mat rowRange(int startrow, int endrow)</div><div class="ttdoc">Creates a matrix header for the specified row span.</div><div class="ttdef"><b>Definition</b> Mat.cs:2206</div></div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowRange</td><td>Start and end row of the extracted submatrix. The upper boundary is not included. To select all the rows, use Range.all(). </td></tr>
    <tr><td class="paramname">colRange</td><td>Start and end column of the extracted submatrix. The upper boundary is not included. To select all the columns, use Range.all(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61dd57838fcea7c87e4021dc8141695e" name="a61dd57838fcea7c87e4021dc8141695e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dd57838fcea7c87e4021dc8141695e">&#9670;&#160;</a></span>submat() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2i.html">Vec2i</a>[]</td>          <td class="paramname"><span class="paramname"><em>ranges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>Array of selected ranges along each array dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7d23c9833db2eaabdceacf7a40e5a68" name="af7d23c9833db2eaabdceacf7a40e5a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d23c9833db2eaabdceacf7a40e5a68">&#9670;&#160;</a></span>submat() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec4i.html">Vec4i</a></td>          <td class="paramname"><span class="paramname"><em>roi</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>Extracted submatrix specified as a rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afffd8efb759c40098f239563a93c1b88" name="afffd8efb759c40098f239563a93c1b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffd8efb759c40098f239563a93c1b88">&#9670;&#160;</a></span>submat() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype">in(int start, int end)</td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(int start, int end)</td>          <td class="paramname"><span class="paramname"><em>colRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowRange</td><td>Start and end row of the extracted submatrix. The upper boundary is not included. To select all the rows, use Range.all(). </td></tr>
    <tr><td class="paramname">colRange</td><td>Start and end column of the extracted submatrix. The upper boundary is not included. To select all the columns, use Range.all(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59918f042f0a5248eb72dab9a45c0f50" name="a59918f042f0a5248eb72dab9a45c0f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59918f042f0a5248eb72dab9a45c0f50">&#9670;&#160;</a></span>submat() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype">in(int start, int end)[]</td>          <td class="paramname"><span class="paramname"><em>ranges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>Array of selected ranges along each array dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34d753f6967100c9cec3c974ecb5326" name="af34d753f6967100c9cec3c974ecb5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34d753f6967100c9cec3c974ecb5326">&#9670;&#160;</a></span>submat() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype">in(int x, int y, int <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, int <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>roi</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>Extracted submatrix specified as a rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ac9038fdbdc543453a7a2a825100484" name="a1ac9038fdbdc543453a7a2a825100484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac9038fdbdc543453a7a2a825100484">&#9670;&#160;</a></span>submat() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rowStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rowEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>colStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>colEnd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowStart</td><td>Start row of the extracted submatrix. </td></tr>
    <tr><td class="paramname">rowEnd</td><td>End row of the extracted submatrix. </td></tr>
    <tr><td class="paramname">colStart</td><td>Start column of the extracted submatrix. </td></tr>
    <tr><td class="paramname">colEnd</td><td>End column of the extracted submatrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a852cafabddf1020464d6d9b26a6077c7" name="a852cafabddf1020464d6d9b26a6077c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852cafabddf1020464d6d9b26a6077c7">&#9670;&#160;</a></span>submat() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>rowRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>colRange</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowRange</td><td>Start and end row of the extracted submatrix. The upper boundary is not included. To select all the rows, use Range.all(). </td></tr>
    <tr><td class="paramname">colRange</td><td>Start and end column of the extracted submatrix. The upper boundary is not included. To select all the columns, use Range.all(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aa06bfabd37052cc5170e184769e644" name="a3aa06bfabd37052cc5170e184769e644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa06bfabd37052cc5170e184769e644">&#9670;&#160;</a></span>submat() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_range.html">Range</a>[]</td>          <td class="paramname"><span class="paramname"><em>ranges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>Array of selected ranges along each array dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af42bf1c582dd11f3968051296751f2fa" name="af42bf1c582dd11f3968051296751f2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42bf1c582dd11f3968051296751f2fa">&#9670;&#160;</a></span>submat() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.submat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_rect.html">Rect</a></td>          <td class="paramname"><span class="paramname"><em>roi</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a rectangular submatrix. </p>
<p>The operators make a new header for the specified sub-array of *this . They are the most generalized forms of <a class="el" href="#ab0109de8c8bfbbd232a29268091ffdbb" title="Creates a matrix header for the specified matrix row.">Mat.row</a>, <a class="el" href="#a506138d3fb9e7f4ba618b93e0455fa86" title="Creates a matrix header for the specified matrix column.">Mat.col</a>, <a class="el" href="#acfb0424ec8cde559cb1c2343e863e127" title="Creates a matrix header for the specified row span.">Mat.rowRange</a>, and <a class="el" href="#ab0ebb50b3a9213bad850944413013a90" title="Creates a matrix header for the specified column span.">Mat.colRange</a> . For example, </p>
<div class="fragment"><div class="line">A(<a class="code hl_typedef" href="_imgcodecs_8cs.html#a95a9660ae50043791ee5175022933c91">Range</a>(0, 10), Range::all()) is equivalent to A.<a class="code hl_function" href="#acfb0424ec8cde559cb1c2343e863e127">rowRange</a>(0, 10).</div>
</div><!-- fragment --> <p>Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>Extracted submatrix specified as a rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c93fdb9e80d98c05d7167ef747de2c1" name="a2c93fdb9e80d98c05d7167ef747de2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c93fdb9e80d98c05d7167ef747de2c1">&#9670;&#160;</a></span>t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes a matrix. </p>
<p>The method performs matrix transposition by means of matrix expressions. It does not perform the actual transposition but returns a temporary matrix transposition object that can be further used as a part of more complex matrix expressions or can be assigned to a matrix: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A1 = A + <a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a>.<a class="code hl_function" href="#a789d7a929b3e052d35581cc7f19b1845">eye</a>(A.size(), A.type())*lambda;</div>
<div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> C = A1.<a class="code hl_function" href="#a2c93fdb9e80d98c05d7167ef747de2c1">t</a>()*A1; <span class="comment">// compute (A + lambda*I)^t * (A + lamda*I)</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1b7ac403115ecf9d8c95df555e05adcc" name="a1b7ac403115ecf9d8c95df555e05adcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7ac403115ecf9d8c95df555e05adcc">&#9670;&#160;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override string OpenCVForUnity.CoreModule.Mat.ToString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2049918ee53b9b95746cbec329515bd" name="ac2049918ee53b9b95746cbec329515bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2049918ee53b9b95746cbec329515bd">&#9670;&#160;</a></span>total()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long OpenCVForUnity.CoreModule.Mat.total </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of array elements. </p>
<p>The method returns the number of array elements (a number of pixels if the array represents an image). </p>

</div>
</div>
<a id="ab50fde5c175a561068025df6b35363f1" name="ab50fde5c175a561068025df6b35363f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50fde5c175a561068025df6b35363f1">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of a matrix element. </p>
<p>The method returns a matrix element type. This is an identifier compatible with the CvMat type system, like CV_16SC3 or 16-bit signed 3-channel array, and so on. </p>

</div>
</div>
<a id="ae56037a2f49c55b0ecfb68f476acacb1" name="ae56037a2f49c55b0ecfb68f476acacb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56037a2f49c55b0ecfb68f476acacb1">&#9670;&#160;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenCVForUnity.CoreModule.Mat.width </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of columns in the matrix. </p>
<p>The method returns the number of columns in the matrix, which corresponds to the width of the image represented by the matrix. If the matrix is empty (i.e., it has no elements), the method will return 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns in the matrix. </dd></dl>

</div>
</div>
<a id="a4380ecf416bf0e066926a359a5ca08ef" name="a4380ecf416bf0e066926a359a5ca08ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4380ecf416bf0e066926a359a5ca08ef">&#9670;&#160;</a></span>zeros() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.zeros </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="struct_open_c_v_for_unity_1_1_unity_utils_1_1_vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero array of the specified size and type. </p>
<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A;</div>
<div class="line">A = <a class="code hl_function" href="#a415b6818d16ea2a7a1dcd571e04e14ab">Mat::zeros</a>(3, 3, CV_32F);</div>
<div class="ttc" id="aclass_open_c_v_for_unity_1_1_core_module_1_1_mat_html_a415b6818d16ea2a7a1dcd571e04e14ab"><div class="ttname"><a href="#a415b6818d16ea2a7a1dcd571e04e14ab">OpenCVForUnity.CoreModule.Mat.zeros</a></div><div class="ttdeci">static Mat zeros(int rows, int cols, int type)</div><div class="ttdoc">Returns a zero array of the specified size and type.</div><div class="ttdef"><b>Definition</b> Mat.cs:2641</div></div>
</div><!-- fragment --> <p>In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix. Otherwise, the existing matrix A is filled with zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative to the matrix size specification Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac550f7252eadad76b2d5945b85b37d99" name="ac550f7252eadad76b2d5945b85b37d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac550f7252eadad76b2d5945b85b37d99">&#9670;&#160;</a></span>zeros() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.zeros </td>
          <td>(</td>
          <td class="paramtype">in(double <a class="el" href="#ae93e9405d94937661d3d8fada5d0e008">width</a>, double <a class="el" href="#a84f44328c9c29259e9545b1980ead568">height</a>)</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero array of the specified size and type. </p>
<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A;</div>
<div class="line">A = <a class="code hl_function" href="#a415b6818d16ea2a7a1dcd571e04e14ab">Mat::zeros</a>(3, 3, CV_32F);</div>
</div><!-- fragment --> <p>In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix. Otherwise, the existing matrix A is filled with zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative to the matrix size specification Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415b6818d16ea2a7a1dcd571e04e14ab" name="a415b6818d16ea2a7a1dcd571e04e14ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415b6818d16ea2a7a1dcd571e04e14ab">&#9670;&#160;</a></span>zeros() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.zeros </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero array of the specified size and type. </p>
<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A;</div>
<div class="line">A = <a class="code hl_function" href="#a415b6818d16ea2a7a1dcd571e04e14ab">Mat::zeros</a>(3, 3, CV_32F);</div>
</div><!-- fragment --> <p>In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix. Otherwise, the existing matrix A is filled with zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a834aad696a6dff0391b449dba8d233b1" name="a834aad696a6dff0391b449dba8d233b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834aad696a6dff0391b449dba8d233b1">&#9670;&#160;</a></span>zeros() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.zeros </td>
          <td>(</td>
          <td class="paramtype">int[]</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero array of the specified size and type. </p>
<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A;</div>
<div class="line">A = <a class="code hl_function" href="#a415b6818d16ea2a7a1dcd571e04e14ab">Mat::zeros</a>(3, 3, CV_32F);</div>
</div><!-- fragment --> <p>In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix. Otherwise, the existing matrix A is filled with zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Array of integers specifying an n-dimensional array shape. </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13c168ba93b5458263423bba80d7e12b" name="a13c168ba93b5458263423bba80d7e12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c168ba93b5458263423bba80d7e12b">&#9670;&#160;</a></span>zeros() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> OpenCVForUnity.CoreModule.Mat.zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_c_v_for_unity_1_1_core_module_1_1_size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero array of the specified size and type. </p>
<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_open_c_v_for_unity_1_1_core_module_1_1_mat.html">Mat</a> A;</div>
<div class="line">A = <a class="code hl_function" href="#a415b6818d16ea2a7a1dcd571e04e14ab">Mat::zeros</a>(3, 3, CV_32F);</div>
</div><!-- fragment --> <p>In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix. Otherwise, the existing matrix A is filled with zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Alternative to the matrix size specification Size(cols, rows) . </td></tr>
    <tr><td class="paramname">type</td><td>Created matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7cee67ee777c199f7f0b02a32970bad5" name="a7cee67ee777c199f7f0b02a32970bad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cee67ee777c199f7f0b02a32970bad5">&#9670;&#160;</a></span>AUTO_STEP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.CoreModule.Mat.AUTO_STEP = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae93e9405d94937661d3d8fada5d0e008" name="ae93e9405d94937661d3d8fada5d0e008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93e9405d94937661d3d8fada5d0e008">&#9670;&#160;</a></span>width</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenCVForUnity.CoreModule.Mat.width</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the array of sizes, or NULL if the matrix is not allocated </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/core/<a class="el" href="_mat_8cs.html">Mat.cs</a></li>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/core/<a class="el" href="_mat___ex_8cs.html">Mat_Ex.cs</a></li>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/core/<a class="el" href="_mat___struct_8cs.html">Mat_Struct.cs</a></li>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/core/<a class="el" href="_mat___value_tuple_8cs.html">Mat_ValueTuple.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
