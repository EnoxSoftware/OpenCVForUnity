<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenCV for Unity: OpenCVForUnity.VideoModule.Video Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<script type="text/javascript" src="../../darkmode_toggle.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenCV for Unity<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">Enox Software / Please refer to OpenCV official document ( http://docs.opencv.org/4.12.0/index.html ) for the details of the argument of the method.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/da5/namespaceOpenCVForUnity.html">OpenCVForUnity</a></li><li class="navelem"><a class="el" href="../../d5/dce/namespaceOpenCVForUnity_1_1VideoModule.html">VideoModule</a></li><li class="navelem"><a class="el" href="../../df/d47/classOpenCVForUnity_1_1VideoModule_1_1Video.html">Video</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../d7/dc7/classOpenCVForUnity_1_1VideoModule_1_1Video-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OpenCVForUnity.VideoModule.Video Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a50fa05249af65e899bc6cdea0df0a881" id="r_a50fa05249af65e899bc6cdea0df0a881"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50fa05249af65e899bc6cdea0df0a881">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel)</td></tr>
<tr class="memdesc:a50fa05249af65e899bc6cdea0df0a881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a50fa05249af65e899bc6cdea0df0a881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21932de9d99679e39ead2ac5d174f06c" id="r_a21932de9d99679e39ead2ac5d174f06c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21932de9d99679e39ead2ac5d174f06c">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel, bool withDerivatives)</td></tr>
<tr class="memdesc:a21932de9d99679e39ead2ac5d174f06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a21932de9d99679e39ead2ac5d174f06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8777abbdeb7649d5572b9f867befa9c" id="r_ac8777abbdeb7649d5572b9f867befa9c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8777abbdeb7649d5572b9f867befa9c">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel, bool withDerivatives, int pyrBorder)</td></tr>
<tr class="memdesc:ac8777abbdeb7649d5572b9f867befa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:ac8777abbdeb7649d5572b9f867befa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8630637f61bea02db4384212e8621c" id="r_abf8630637f61bea02db4384212e8621c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf8630637f61bea02db4384212e8621c">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel, bool withDerivatives, int pyrBorder, int derivBorder)</td></tr>
<tr class="memdesc:abf8630637f61bea02db4384212e8621c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:abf8630637f61bea02db4384212e8621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1455f81fe59210f69074c37ee70a3cc9" id="r_a1455f81fe59210f69074c37ee70a3cc9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1455f81fe59210f69074c37ee70a3cc9">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel, bool withDerivatives, int pyrBorder, int derivBorder, bool tryReuseInputImage)</td></tr>
<tr class="memdesc:a1455f81fe59210f69074c37ee70a3cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a1455f81fe59210f69074c37ee70a3cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0224a2a73d1df3cf6ccb251545d961c6" id="r_a0224a2a73d1df3cf6ccb251545d961c6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0224a2a73d1df3cf6ccb251545d961c6">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel)</td></tr>
<tr class="memdesc:a0224a2a73d1df3cf6ccb251545d961c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a0224a2a73d1df3cf6ccb251545d961c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17a594f1110b0f19c5074327f7b454e" id="r_af17a594f1110b0f19c5074327f7b454e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af17a594f1110b0f19c5074327f7b454e">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel, bool withDerivatives)</td></tr>
<tr class="memdesc:af17a594f1110b0f19c5074327f7b454e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:af17a594f1110b0f19c5074327f7b454e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df31aaf188c9f5951ad1cbd8d1e3924" id="r_a3df31aaf188c9f5951ad1cbd8d1e3924"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3df31aaf188c9f5951ad1cbd8d1e3924">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel, bool withDerivatives, int pyrBorder)</td></tr>
<tr class="memdesc:a3df31aaf188c9f5951ad1cbd8d1e3924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a3df31aaf188c9f5951ad1cbd8d1e3924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286168d01a64faa5fc0783d812ae1670" id="r_a286168d01a64faa5fc0783d812ae1670"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a286168d01a64faa5fc0783d812ae1670">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel, bool withDerivatives, int pyrBorder, int derivBorder)</td></tr>
<tr class="memdesc:a286168d01a64faa5fc0783d812ae1670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a286168d01a64faa5fc0783d812ae1670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570cc74faad9f5cbd0caad13ea106dda" id="r_a570cc74faad9f5cbd0caad13ea106dda"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a570cc74faad9f5cbd0caad13ea106dda">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel, bool withDerivatives, int pyrBorder, int derivBorder, bool tryReuseInputImage)</td></tr>
<tr class="memdesc:a570cc74faad9f5cbd0caad13ea106dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a570cc74faad9f5cbd0caad13ea106dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ddff29f223b68a708bbe490888cb3" id="r_a710ddff29f223b68a708bbe490888cb3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710ddff29f223b68a708bbe490888cb3">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel)</td></tr>
<tr class="memdesc:a710ddff29f223b68a708bbe490888cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a710ddff29f223b68a708bbe490888cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f47c7a527435555b321f6be15a93c2" id="r_a64f47c7a527435555b321f6be15a93c2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64f47c7a527435555b321f6be15a93c2">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel, bool withDerivatives)</td></tr>
<tr class="memdesc:a64f47c7a527435555b321f6be15a93c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a64f47c7a527435555b321f6be15a93c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35b8d4f28fc7924203a9b65aa650ec3" id="r_ad35b8d4f28fc7924203a9b65aa650ec3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad35b8d4f28fc7924203a9b65aa650ec3">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel, bool withDerivatives, int pyrBorder)</td></tr>
<tr class="memdesc:ad35b8d4f28fc7924203a9b65aa650ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:ad35b8d4f28fc7924203a9b65aa650ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb6b5e2bd81a824d41c274486497f46" id="r_a8eb6b5e2bd81a824d41c274486497f46"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eb6b5e2bd81a824d41c274486497f46">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel, bool withDerivatives, int pyrBorder, int derivBorder)</td></tr>
<tr class="memdesc:a8eb6b5e2bd81a824d41c274486497f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a8eb6b5e2bd81a824d41c274486497f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e90ac88743ca10e136932ed77c35ba" id="r_a59e90ac88743ca10e136932ed77c35ba"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59e90ac88743ca10e136932ed77c35ba">buildOpticalFlowPyramid</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> img, List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt; pyramid, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel, bool withDerivatives, int pyrBorder, int derivBorder, bool tryReuseInputImage)</td></tr>
<tr class="memdesc:a59e90ac88743ca10e136932ed77c35ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.  <br /></td></tr>
<tr class="separator:a59e90ac88743ca10e136932ed77c35ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663fef9e35ea2601b03d41fe265c078f" id="r_a663fef9e35ea2601b03d41fe265c078f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a663fef9e35ea2601b03d41fe265c078f">calcOpticalFlowFarneback</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prev, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> next, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)</td></tr>
<tr class="memdesc:a663fef9e35ea2601b03d41fe265c078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a dense optical flow using the Gunnar Farneback's algorithm.  <br /></td></tr>
<tr class="separator:a663fef9e35ea2601b03d41fe265c078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1542f9af1eb13b294753e21fa21ffc5d" id="r_a1542f9af1eb13b294753e21fa21ffc5d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1542f9af1eb13b294753e21fa21ffc5d">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err)</td></tr>
<tr class="memdesc:a1542f9af1eb13b294753e21fa21ffc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a1542f9af1eb13b294753e21fa21ffc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449b422e2ad1d29cf7dd3f34e4d04585" id="r_a449b422e2ad1d29cf7dd3f34e4d04585"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a449b422e2ad1d29cf7dd3f34e4d04585">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize)</td></tr>
<tr class="memdesc:a449b422e2ad1d29cf7dd3f34e4d04585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a449b422e2ad1d29cf7dd3f34e4d04585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb1f786a19ec856db3d23bac99849c9" id="r_a6cb1f786a19ec856db3d23bac99849c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb1f786a19ec856db3d23bac99849c9">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel)</td></tr>
<tr class="memdesc:a6cb1f786a19ec856db3d23bac99849c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a6cb1f786a19ec856db3d23bac99849c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7047d4b80d22ea82976db96121704d" id="r_aec7047d4b80d22ea82976db96121704d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7047d4b80d22ea82976db96121704d">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria)</td></tr>
<tr class="memdesc:aec7047d4b80d22ea82976db96121704d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:aec7047d4b80d22ea82976db96121704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad5d1aee1a966f8c347dc88be8a652a" id="r_a2ad5d1aee1a966f8c347dc88be8a652a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad5d1aee1a966f8c347dc88be8a652a">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria, int flags)</td></tr>
<tr class="memdesc:a2ad5d1aee1a966f8c347dc88be8a652a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a2ad5d1aee1a966f8c347dc88be8a652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5d9b07fbd5ecdad57541bdd88608d5" id="r_afd5d9b07fbd5ecdad57541bdd88608d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd5d9b07fbd5ecdad57541bdd88608d5">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a> winSize, int maxLevel, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria, int flags, double minEigThreshold)</td></tr>
<tr class="memdesc:afd5d9b07fbd5ecdad57541bdd88608d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:afd5d9b07fbd5ecdad57541bdd88608d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98f5a17f1062c11d7f8b3854b2e937c" id="r_ad98f5a17f1062c11d7f8b3854b2e937c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98f5a17f1062c11d7f8b3854b2e937c">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize)</td></tr>
<tr class="memdesc:ad98f5a17f1062c11d7f8b3854b2e937c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:ad98f5a17f1062c11d7f8b3854b2e937c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9da708b5f33c8d406bc0a81e4dc3139" id="r_af9da708b5f33c8d406bc0a81e4dc3139"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9da708b5f33c8d406bc0a81e4dc3139">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel)</td></tr>
<tr class="memdesc:af9da708b5f33c8d406bc0a81e4dc3139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:af9da708b5f33c8d406bc0a81e4dc3139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112d84120da3c98433f18a093e0d8a92" id="r_a112d84120da3c98433f18a093e0d8a92"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a112d84120da3c98433f18a093e0d8a92">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel, in(double type, double maxCount, double epsilon) criteria)</td></tr>
<tr class="memdesc:a112d84120da3c98433f18a093e0d8a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a112d84120da3c98433f18a093e0d8a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5630e1b8e8d46a1907dafdec898f45f" id="r_ae5630e1b8e8d46a1907dafdec898f45f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5630e1b8e8d46a1907dafdec898f45f">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel, in(double type, double maxCount, double epsilon) criteria, int flags)</td></tr>
<tr class="memdesc:ae5630e1b8e8d46a1907dafdec898f45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:ae5630e1b8e8d46a1907dafdec898f45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454f0849ca5562b412f6175ce6a68ca5" id="r_a454f0849ca5562b412f6175ce6a68ca5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a454f0849ca5562b412f6175ce6a68ca5">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) winSize, int maxLevel, in(double type, double maxCount, double epsilon) criteria, int flags, double minEigThreshold)</td></tr>
<tr class="memdesc:a454f0849ca5562b412f6175ce6a68ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a454f0849ca5562b412f6175ce6a68ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ec951ae67f5d890ec149215b45e44e" id="r_a34ec951ae67f5d890ec149215b45e44e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34ec951ae67f5d890ec149215b45e44e">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize)</td></tr>
<tr class="memdesc:a34ec951ae67f5d890ec149215b45e44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a34ec951ae67f5d890ec149215b45e44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23e302b08e50af7ead50b10c385e22a" id="r_ab23e302b08e50af7ead50b10c385e22a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab23e302b08e50af7ead50b10c385e22a">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel)</td></tr>
<tr class="memdesc:ab23e302b08e50af7ead50b10c385e22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:ab23e302b08e50af7ead50b10c385e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1b0b3b31d018a71a27375ff230de1" id="r_a1fa1b0b3b31d018a71a27375ff230de1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fa1b0b3b31d018a71a27375ff230de1">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="memdesc:a1fa1b0b3b31d018a71a27375ff230de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:a1fa1b0b3b31d018a71a27375ff230de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6da46125348d92bf8f6ab3dff1b71c" id="r_abd6da46125348d92bf8f6ab3dff1b71c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6da46125348d92bf8f6ab3dff1b71c">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria, int flags)</td></tr>
<tr class="memdesc:abd6da46125348d92bf8f6ab3dff1b71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:abd6da46125348d92bf8f6ab3dff1b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af910fdade7cd2e754b553f9e180c4780" id="r_af910fdade7cd2e754b553f9e180c4780"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af910fdade7cd2e754b553f9e180c4780">calcOpticalFlowPyrLK</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> prevImg, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> nextImg, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> prevPts, <a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a> nextPts, <a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a> status, <a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a> err, <a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a> winSize, int maxLevel, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria, int flags, double minEigThreshold)</td></tr>
<tr class="memdesc:af910fdade7cd2e754b553f9e180c4780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.  <br /></td></tr>
<tr class="separator:af910fdade7cd2e754b553f9e180c4780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784baec5c69702aa15e2fd83aaccfc6b" id="r_a784baec5c69702aa15e2fd83aaccfc6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/dd9/classOpenCVForUnity_1_1CoreModule_1_1RotatedRect.html">RotatedRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a784baec5c69702aa15e2fd83aaccfc6b">CamShift</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> probImage, <a class="el" href="../../d0/d13/classOpenCVForUnity_1_1CoreModule_1_1Rect.html">Rect</a> window, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="memdesc:a784baec5c69702aa15e2fd83aaccfc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an object center, size, and orientation.  <br /></td></tr>
<tr class="separator:a784baec5c69702aa15e2fd83aaccfc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbd0c6a5ea4ae7ae14615a59d43ba9b" id="r_aabbd0c6a5ea4ae7ae14615a59d43ba9b"><td class="memItemLeft" align="right" valign="top">static double double double double double angle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabbd0c6a5ea4ae7ae14615a59d43ba9b">CamShiftAsValueTuple</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> probImage, ref(int <a class="el" href="#a9a170d1766ad9d2556a16cc2ff9befb5">x</a>, int <a class="el" href="#a2531b886525efd19cfc86c8c861b6284">y</a>, int <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, int <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) window, in(double type, double maxCount, double epsilon) criteria)</td></tr>
<tr class="separator:aabbd0c6a5ea4ae7ae14615a59d43ba9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d7033d24f7b9231d3ab1b044fb55cd" id="r_a70d7033d24f7b9231d3ab1b044fb55cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d2/d1b/structOpenCVForUnity_1_1UnityIntegration_1_1Vec5d.html">Vec5d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70d7033d24f7b9231d3ab1b044fb55cd">CamShiftAsVec5d</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> probImage, ref <a class="el" href="../../df/d63/structOpenCVForUnity_1_1UnityIntegration_1_1Vec4i.html">Vec4i</a> window, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria)</td></tr>
<tr class="memdesc:a70d7033d24f7b9231d3ab1b044fb55cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an object center, size, and orientation.  <br /></td></tr>
<tr class="separator:a70d7033d24f7b9231d3ab1b044fb55cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dcf5ed98ea8b52c40721996517c511" id="r_ae0dcf5ed98ea8b52c40721996517c511"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0dcf5ed98ea8b52c40721996517c511">computeECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage)</td></tr>
<tr class="memdesc:ae0dcf5ed98ea8b52c40721996517c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Enhanced Correlation Coefficient value between two images <b>[EP08]</b> .  <br /></td></tr>
<tr class="separator:ae0dcf5ed98ea8b52c40721996517c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674a2abce8e540ef9d043f30683fcd92" id="r_a674a2abce8e540ef9d043f30683fcd92"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a674a2abce8e540ef9d043f30683fcd92">computeECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputMask)</td></tr>
<tr class="memdesc:a674a2abce8e540ef9d043f30683fcd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Enhanced Correlation Coefficient value between two images <b>[EP08]</b> .  <br /></td></tr>
<tr class="separator:a674a2abce8e540ef9d043f30683fcd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3af3f2f22aac2c90a337ac4f8fcac12" id="r_ac3af3f2f22aac2c90a337ac4f8fcac12"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3af3f2f22aac2c90a337ac4f8fcac12">createBackgroundSubtractorKNN</a> ()</td></tr>
<tr class="memdesc:ac3af3f2f22aac2c90a337ac4f8fcac12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates KNN Background Subtractor.  <br /></td></tr>
<tr class="separator:ac3af3f2f22aac2c90a337ac4f8fcac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88a09bb290f8528ed3ba19e23f73ab8" id="r_ad88a09bb290f8528ed3ba19e23f73ab8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad88a09bb290f8528ed3ba19e23f73ab8">createBackgroundSubtractorKNN</a> (int history)</td></tr>
<tr class="memdesc:ad88a09bb290f8528ed3ba19e23f73ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates KNN Background Subtractor.  <br /></td></tr>
<tr class="separator:ad88a09bb290f8528ed3ba19e23f73ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98edfae98db5a6acbdddd0a702e05eb6" id="r_a98edfae98db5a6acbdddd0a702e05eb6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98edfae98db5a6acbdddd0a702e05eb6">createBackgroundSubtractorKNN</a> (int history, double dist2Threshold)</td></tr>
<tr class="memdesc:a98edfae98db5a6acbdddd0a702e05eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates KNN Background Subtractor.  <br /></td></tr>
<tr class="separator:a98edfae98db5a6acbdddd0a702e05eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf10f61e2c4fb27e8a7747e225a274d7" id="r_acf10f61e2c4fb27e8a7747e225a274d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf10f61e2c4fb27e8a7747e225a274d7">createBackgroundSubtractorKNN</a> (int history, double dist2Threshold, bool detectShadows)</td></tr>
<tr class="memdesc:acf10f61e2c4fb27e8a7747e225a274d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates KNN Background Subtractor.  <br /></td></tr>
<tr class="separator:acf10f61e2c4fb27e8a7747e225a274d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89136e8b74c649b65a834e185ab83233" id="r_a89136e8b74c649b65a834e185ab83233"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89136e8b74c649b65a834e185ab83233">createBackgroundSubtractorMOG2</a> ()</td></tr>
<tr class="memdesc:a89136e8b74c649b65a834e185ab83233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates MOG2 Background Subtractor.  <br /></td></tr>
<tr class="separator:a89136e8b74c649b65a834e185ab83233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f7817610c2214b39982c00cbd800ac" id="r_a64f7817610c2214b39982c00cbd800ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64f7817610c2214b39982c00cbd800ac">createBackgroundSubtractorMOG2</a> (int history)</td></tr>
<tr class="memdesc:a64f7817610c2214b39982c00cbd800ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates MOG2 Background Subtractor.  <br /></td></tr>
<tr class="separator:a64f7817610c2214b39982c00cbd800ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade94202828ddb3602d289cb00159fb2b" id="r_ade94202828ddb3602d289cb00159fb2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade94202828ddb3602d289cb00159fb2b">createBackgroundSubtractorMOG2</a> (int history, double varThreshold)</td></tr>
<tr class="memdesc:ade94202828ddb3602d289cb00159fb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates MOG2 Background Subtractor.  <br /></td></tr>
<tr class="separator:ade94202828ddb3602d289cb00159fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e254caa94f0e83dd3a4ca74ad626a" id="r_a4a4e254caa94f0e83dd3a4ca74ad626a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a4e254caa94f0e83dd3a4ca74ad626a">createBackgroundSubtractorMOG2</a> (int history, double varThreshold, bool detectShadows)</td></tr>
<tr class="memdesc:a4a4e254caa94f0e83dd3a4ca74ad626a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates MOG2 Background Subtractor.  <br /></td></tr>
<tr class="separator:a4a4e254caa94f0e83dd3a4ca74ad626a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed032a071801909b797ae068d5c0e936" id="r_aed032a071801909b797ae068d5c0e936"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed032a071801909b797ae068d5c0e936">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix)</td></tr>
<tr class="separator:aed032a071801909b797ae068d5c0e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5569c7c87c83dda72cb1033aa76f6c" id="r_a4f5569c7c87c83dda72cb1033aa76f6c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f5569c7c87c83dda72cb1033aa76f6c">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType)</td></tr>
<tr class="separator:a4f5569c7c87c83dda72cb1033aa76f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31922eefe0b7ed16d6914a054548f326" id="r_a31922eefe0b7ed16d6914a054548f326"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31922eefe0b7ed16d6914a054548f326">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria)</td></tr>
<tr class="separator:a31922eefe0b7ed16d6914a054548f326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318c2a5f8c005f08bb79bf107c264db" id="r_af318c2a5f8c005f08bb79bf107c264db"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af318c2a5f8c005f08bb79bf107c264db">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputMask)</td></tr>
<tr class="separator:af318c2a5f8c005f08bb79bf107c264db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9261ec617d3bc60a44d1f41d8a2e495" id="r_aa9261ec617d3bc60a44d1f41d8a2e495"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9261ec617d3bc60a44d1f41d8a2e495">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputMask, int gaussFiltSize)</td></tr>
<tr class="memdesc:aa9261ec617d3bc60a44d1f41d8a2e495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the geometric transform (warp) between two images in terms of the ECC criterion <b>[EP08]</b> .  <br /></td></tr>
<tr class="separator:aa9261ec617d3bc60a44d1f41d8a2e495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365e5f833a49e47d1916338c590e9113" id="r_a365e5f833a49e47d1916338c590e9113"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a365e5f833a49e47d1916338c590e9113">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, in(double type, double maxCount, double epsilon) criteria)</td></tr>
<tr class="separator:a365e5f833a49e47d1916338c590e9113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ff0986e4bca4eb996c11bc737144c2" id="r_a16ff0986e4bca4eb996c11bc737144c2"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16ff0986e4bca4eb996c11bc737144c2">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, in(double type, double maxCount, double epsilon) criteria, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputMask)</td></tr>
<tr class="separator:a16ff0986e4bca4eb996c11bc737144c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dddc07d4bc3912dc585e345b3f7e9a" id="r_a85dddc07d4bc3912dc585e345b3f7e9a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85dddc07d4bc3912dc585e345b3f7e9a">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, in(double type, double maxCount, double epsilon) criteria, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputMask, int gaussFiltSize)</td></tr>
<tr class="memdesc:a85dddc07d4bc3912dc585e345b3f7e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the geometric transform (warp) between two images in terms of the ECC criterion <b>[EP08]</b> .  <br /></td></tr>
<tr class="separator:a85dddc07d4bc3912dc585e345b3f7e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ec33b6f2832fedad26072d9f174bbe" id="r_ab7ec33b6f2832fedad26072d9f174bbe"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7ec33b6f2832fedad26072d9f174bbe">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="separator:ab7ec33b6f2832fedad26072d9f174bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bae8fc3159ec8424ff2a46c5203445" id="r_ae3bae8fc3159ec8424ff2a46c5203445"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3bae8fc3159ec8424ff2a46c5203445">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputMask)</td></tr>
<tr class="separator:ae3bae8fc3159ec8424ff2a46c5203445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d172864acc3481c3da801c7324a8834" id="r_a0d172864acc3481c3da801c7324a8834"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d172864acc3481c3da801c7324a8834">findTransformECC</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> templateImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputImage, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> warpMatrix, int motionType, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> inputMask, int gaussFiltSize)</td></tr>
<tr class="memdesc:a0d172864acc3481c3da801c7324a8834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the geometric transform (warp) between two images in terms of the ECC criterion <b>[EP08]</b> .  <br /></td></tr>
<tr class="separator:a0d172864acc3481c3da801c7324a8834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5533dd028a49ea8e443c748e219d26a" id="r_ac5533dd028a49ea8e443c748e219d26a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5533dd028a49ea8e443c748e219d26a">meanShift</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> probImage, <a class="el" href="../../d0/d13/classOpenCVForUnity_1_1CoreModule_1_1Rect.html">Rect</a> window, <a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="memdesc:ac5533dd028a49ea8e443c748e219d26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an object on a back projection image.  <br /></td></tr>
<tr class="separator:ac5533dd028a49ea8e443c748e219d26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89972d347a0dac846e3480f709b28924" id="r_a89972d347a0dac846e3480f709b28924"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89972d347a0dac846e3480f709b28924">meanShift</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> probImage, ref <a class="el" href="../../df/d63/structOpenCVForUnity_1_1UnityIntegration_1_1Vec4i.html">Vec4i</a> window, in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a> criteria)</td></tr>
<tr class="memdesc:a89972d347a0dac846e3480f709b28924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an object on a back projection image.  <br /></td></tr>
<tr class="separator:a89972d347a0dac846e3480f709b28924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051f68aa46593426a75355a4b310b06c" id="r_a051f68aa46593426a75355a4b310b06c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a051f68aa46593426a75355a4b310b06c">meanShift</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> probImage, ref(int <a class="el" href="#a9a170d1766ad9d2556a16cc2ff9befb5">x</a>, int <a class="el" href="#a2531b886525efd19cfc86c8c861b6284">y</a>, int <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, int <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>) window, in(double type, double maxCount, double epsilon) criteria)</td></tr>
<tr class="memdesc:a051f68aa46593426a75355a4b310b06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an object on a back projection image.  <br /></td></tr>
<tr class="separator:a051f68aa46593426a75355a4b310b06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692d44ba7b52672c2b7cacbbb3089942" id="r_a692d44ba7b52672c2b7cacbbb3089942"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692d44ba7b52672c2b7cacbbb3089942">readOpticalFlow</a> (string path)</td></tr>
<tr class="memdesc:a692d44ba7b52672c2b7cacbbb3089942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a .flo file.  <br /></td></tr>
<tr class="separator:a692d44ba7b52672c2b7cacbbb3089942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131494e1a4afc6d541687b0fcd35d6cb" id="r_a131494e1a4afc6d541687b0fcd35d6cb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a131494e1a4afc6d541687b0fcd35d6cb">writeOpticalFlow</a> (string path, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> flow)</td></tr>
<tr class="memdesc:a131494e1a4afc6d541687b0fcd35d6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a .flo to disk.  <br /></td></tr>
<tr class="separator:a131494e1a4afc6d541687b0fcd35d6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a88adc4d9e1bb4854198734216c3ee2de" id="r_a88adc4d9e1bb4854198734216c3ee2de"><td class="memItemLeft" align="right" valign="top">static double double double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a></td></tr>
<tr class="separator:a88adc4d9e1bb4854198734216c3ee2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe67e1b2e8db13461e6d79e39f33b2e5" id="r_afe67e1b2e8db13461e6d79e39f33b2e5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe67e1b2e8db13461e6d79e39f33b2e5">MOTION_AFFINE</a> = 2</td></tr>
<tr class="memdesc:afe67e1b2e8db13461e6d79e39f33b2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum &lt;unnamed&gt;  <br /></td></tr>
<tr class="separator:afe67e1b2e8db13461e6d79e39f33b2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64aa60a163d98d4c7afb6ed32d7ece67" id="r_a64aa60a163d98d4c7afb6ed32d7ece67"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64aa60a163d98d4c7afb6ed32d7ece67">MOTION_EUCLIDEAN</a> = 1</td></tr>
<tr class="memdesc:a64aa60a163d98d4c7afb6ed32d7ece67"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum &lt;unnamed&gt;  <br /></td></tr>
<tr class="separator:a64aa60a163d98d4c7afb6ed32d7ece67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d3de23bc2c4a5d2bfc20c9bca0b4f" id="r_a864d3de23bc2c4a5d2bfc20c9bca0b4f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a864d3de23bc2c4a5d2bfc20c9bca0b4f">MOTION_HOMOGRAPHY</a> = 3</td></tr>
<tr class="memdesc:a864d3de23bc2c4a5d2bfc20c9bca0b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum &lt;unnamed&gt;  <br /></td></tr>
<tr class="separator:a864d3de23bc2c4a5d2bfc20c9bca0b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172553c7ea86d511cb4581290dbdfb8a" id="r_a172553c7ea86d511cb4581290dbdfb8a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a172553c7ea86d511cb4581290dbdfb8a">MOTION_TRANSLATION</a> = 0</td></tr>
<tr class="memdesc:a172553c7ea86d511cb4581290dbdfb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum &lt;unnamed&gt;  <br /></td></tr>
<tr class="separator:a172553c7ea86d511cb4581290dbdfb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3947653ec7356fef015dc70f124f22c" id="r_aa3947653ec7356fef015dc70f124f22c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3947653ec7356fef015dc70f124f22c">OPTFLOW_FARNEBACK_GAUSSIAN</a> = 256</td></tr>
<tr class="memdesc:aa3947653ec7356fef015dc70f124f22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum &lt;unnamed&gt;  <br /></td></tr>
<tr class="separator:aa3947653ec7356fef015dc70f124f22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d66a0846b209d0ce4e089d1da7baf0" id="r_a38d66a0846b209d0ce4e089d1da7baf0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d66a0846b209d0ce4e089d1da7baf0">OPTFLOW_LK_GET_MIN_EIGENVALS</a> = 8</td></tr>
<tr class="memdesc:a38d66a0846b209d0ce4e089d1da7baf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum &lt;unnamed&gt;  <br /></td></tr>
<tr class="separator:a38d66a0846b209d0ce4e089d1da7baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef373d149dd26fd89d709252791efb1a" id="r_aef373d149dd26fd89d709252791efb1a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef373d149dd26fd89d709252791efb1a">OPTFLOW_USE_INITIAL_FLOW</a> = 4</td></tr>
<tr class="memdesc:aef373d149dd26fd89d709252791efb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum &lt;unnamed&gt;  <br /></td></tr>
<tr class="separator:aef373d149dd26fd89d709252791efb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4082bbbf4879d978d5fa838d4195a" id="r_abea4082bbbf4879d978d5fa838d4195a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abea4082bbbf4879d978d5fa838d4195a">TrackerSamplerCSC_MODE_DETECT</a> = 5</td></tr>
<tr class="memdesc:abea4082bbbf4879d978d5fa838d4195a"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE)  <br /></td></tr>
<tr class="separator:abea4082bbbf4879d978d5fa838d4195a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a937ccd26d061e7d546ab6b47793cdd" id="r_a7a937ccd26d061e7d546ab6b47793cdd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a937ccd26d061e7d546ab6b47793cdd">TrackerSamplerCSC_MODE_INIT_NEG</a> = 2</td></tr>
<tr class="memdesc:a7a937ccd26d061e7d546ab6b47793cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE)  <br /></td></tr>
<tr class="separator:a7a937ccd26d061e7d546ab6b47793cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbb75a4c95b60b36f72b47699db242c" id="r_a4dbb75a4c95b60b36f72b47699db242c"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dbb75a4c95b60b36f72b47699db242c">TrackerSamplerCSC_MODE_INIT_POS</a> = 1</td></tr>
<tr class="memdesc:a4dbb75a4c95b60b36f72b47699db242c"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE)  <br /></td></tr>
<tr class="separator:a4dbb75a4c95b60b36f72b47699db242c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4705123bac94d5a88e02f9c92de60eb" id="r_ac4705123bac94d5a88e02f9c92de60eb"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4705123bac94d5a88e02f9c92de60eb">TrackerSamplerCSC_MODE_TRACK_NEG</a> = 4</td></tr>
<tr class="memdesc:ac4705123bac94d5a88e02f9c92de60eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE)  <br /></td></tr>
<tr class="separator:ac4705123bac94d5a88e02f9c92de60eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e1acdb165507fd8768786f1f9fe115" id="r_a85e1acdb165507fd8768786f1f9fe115"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85e1acdb165507fd8768786f1f9fe115">TrackerSamplerCSC_MODE_TRACK_POS</a> = 3</td></tr>
<tr class="memdesc:a85e1acdb165507fd8768786f1f9fe115"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE)  <br /></td></tr>
<tr class="separator:a85e1acdb165507fd8768786f1f9fe115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9624b8d608cf8d05cd8d95a8ee12c35b" id="r_a9624b8d608cf8d05cd8d95a8ee12c35b"><td class="memItemLeft" align="right" valign="top">static double double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a></td></tr>
<tr class="separator:a9624b8d608cf8d05cd8d95a8ee12c35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a170d1766ad9d2556a16cc2ff9befb5" id="r_a9a170d1766ad9d2556a16cc2ff9befb5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a170d1766ad9d2556a16cc2ff9befb5">x</a></td></tr>
<tr class="memdesc:a9a170d1766ad9d2556a16cc2ff9befb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an object center, size, and orientation.  <br /></td></tr>
<tr class="separator:a9a170d1766ad9d2556a16cc2ff9befb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2531b886525efd19cfc86c8c861b6284" id="r_a2531b886525efd19cfc86c8c861b6284"><td class="memItemLeft" align="right" valign="top">static double double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2531b886525efd19cfc86c8c861b6284">y</a></td></tr>
<tr class="separator:a2531b886525efd19cfc86c8c861b6284"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a50fa05249af65e899bc6cdea0df0a881" name="a50fa05249af65e899bc6cdea0df0a881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fa05249af65e899bc6cdea0df0a881">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a21932de9d99679e39ead2ac5d174f06c" name="a21932de9d99679e39ead2ac5d174f06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21932de9d99679e39ead2ac5d174f06c">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="ac8777abbdeb7649d5572b9f867befa9c" name="ac8777abbdeb7649d5572b9f867befa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8777abbdeb7649d5572b9f867befa9c">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="abf8630637f61bea02db4384212e8621c" name="abf8630637f61bea02db4384212e8621c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8630637f61bea02db4384212e8621c">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivBorder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a1455f81fe59210f69074c37ee70a3cc9" name="a1455f81fe59210f69074c37ee70a3cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1455f81fe59210f69074c37ee70a3cc9">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tryReuseInputImage</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a0224a2a73d1df3cf6ccb251545d961c6" name="a0224a2a73d1df3cf6ccb251545d961c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0224a2a73d1df3cf6ccb251545d961c6">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="af17a594f1110b0f19c5074327f7b454e" name="af17a594f1110b0f19c5074327f7b454e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17a594f1110b0f19c5074327f7b454e">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a3df31aaf188c9f5951ad1cbd8d1e3924" name="a3df31aaf188c9f5951ad1cbd8d1e3924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df31aaf188c9f5951ad1cbd8d1e3924">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a286168d01a64faa5fc0783d812ae1670" name="a286168d01a64faa5fc0783d812ae1670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286168d01a64faa5fc0783d812ae1670">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivBorder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a570cc74faad9f5cbd0caad13ea106dda" name="a570cc74faad9f5cbd0caad13ea106dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570cc74faad9f5cbd0caad13ea106dda">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tryReuseInputImage</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a710ddff29f223b68a708bbe490888cb3" name="a710ddff29f223b68a708bbe490888cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710ddff29f223b68a708bbe490888cb3">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a64f47c7a527435555b321f6be15a93c2" name="a64f47c7a527435555b321f6be15a93c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f47c7a527435555b321f6be15a93c2">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="ad35b8d4f28fc7924203a9b65aa650ec3" name="ad35b8d4f28fc7924203a9b65aa650ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35b8d4f28fc7924203a9b65aa650ec3">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a8eb6b5e2bd81a824d41c274486497f46" name="a8eb6b5e2bd81a824d41c274486497f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb6b5e2bd81a824d41c274486497f46">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivBorder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a59e90ac88743ca10e136932ed77c35ba" name="a59e90ac88743ca10e136932ed77c35ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e90ac88743ca10e136932ed77c35ba">&#9670;&#160;</a></span>buildOpticalFlowPyramid() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.buildOpticalFlowPyramid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>pyramid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>withDerivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pyrBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivBorder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tryReuseInputImage</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">pyramid</td><td>output pyramid. </td></tr>
    <tr><td class="paramname">winSize</td><td>window size of optical flow algorithm. Must be not less than winSize argument of calcOpticalFlowPyrLK. It is needed to calculate required padding for pyramid levels. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number. </td></tr>
    <tr><td class="paramname">withDerivatives</td><td>set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calcOpticalFlowPyrLK will calculate them internally. </td></tr>
    <tr><td class="paramname">pyrBorder</td><td>the border mode for pyramid layers. </td></tr>
    <tr><td class="paramname">derivBorder</td><td>the border mode for gradients. </td></tr>
    <tr><td class="paramname">tryReuseInputImage</td><td>put ROI of input image into the pyramid if possible. You can pass false to force data copying. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of levels in constructed pyramid. Can be less than maxLevel. </dd></dl>

</div>
</div>
<a id="a663fef9e35ea2601b03d41fe265c078f" name="a663fef9e35ea2601b03d41fe265c078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663fef9e35ea2601b03d41fe265c078f">&#9670;&#160;</a></span>calcOpticalFlowFarneback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowFarneback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>next</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>flow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>pyr_scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>levels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>winsize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>poly_n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>poly_sigma</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a dense optical flow using the Gunnar Farneback's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>first 8-bit single-channel input image. </td></tr>
    <tr><td class="paramname">next</td><td>second input image of the same size and the same type as prev. </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as prev and type CV_32FC2. </td></tr>
    <tr><td class="paramname">pyr_scale</td><td>parameter, specifying the image scale (&lt;1) to build pyramids for each image; pyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one. </td></tr>
    <tr><td class="paramname">levels</td><td>number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used. </td></tr>
    <tr><td class="paramname">winsize</td><td>averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations the algorithm does at each pyramid level. </td></tr>
    <tr><td class="paramname">poly_n</td><td>size of the pixel neighborhood used to find polynomial expansion in each pixel; larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field, typically poly_n =5 or 7. </td></tr>
    <tr><td class="paramname">poly_sigma</td><td>standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a good value would be poly_sigma=1.5. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags that can be a combination of the following:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses the input flow as an initial flow approximation.</li>
<li><b>OPTFLOW_FARNEBACK_GAUSSIAN</b> uses the Gaussian \(\texttt{winsize}\times\texttt{winsize}\) filter instead of a box filter of the same size for optical flow estimation; usually, this option gives z more accurate flow than with a box filter, at the cost of lower speed; normally, winsize for a Gaussian window should be set to a larger value to achieve the same level of robustness. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds an optical flow for each prev pixel using the <b>[Farneback2003]</b> algorithm so that</p>
<p class="formulaDsp">
\[\texttt{prev} (y,x)  \sim \texttt{next} ( y + \texttt{flow} (y,x)[1],  x + \texttt{flow} (y,x)[0])\]
</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/cpp/fback.cpp</li>
<li>(Python) An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/python/opt_flow.py </li>
</ul>

</div>
</div>
<a id="a1542f9af1eb13b294753e21fa21ffc5d" name="a1542f9af1eb13b294753e21fa21ffc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1542f9af1eb13b294753e21fa21ffc5d">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a449b422e2ad1d29cf7dd3f34e4d04585" name="a449b422e2ad1d29cf7dd3f34e4d04585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449b422e2ad1d29cf7dd3f34e4d04585">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a6cb1f786a19ec856db3d23bac99849c9" name="a6cb1f786a19ec856db3d23bac99849c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb1f786a19ec856db3d23bac99849c9">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="aec7047d4b80d22ea82976db96121704d" name="aec7047d4b80d22ea82976db96121704d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7047d4b80d22ea82976db96121704d">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a2ad5d1aee1a966f8c347dc88be8a652a" name="a2ad5d1aee1a966f8c347dc88be8a652a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad5d1aee1a966f8c347dc88be8a652a">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="afd5d9b07fbd5ecdad57541bdd88608d5" name="afd5d9b07fbd5ecdad57541bdd88608d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5d9b07fbd5ecdad57541bdd88608d5">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d1/dbb/structOpenCVForUnity_1_1UnityIntegration_1_1Vec2d.html">Vec2d</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minEigThreshold</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="ad98f5a17f1062c11d7f8b3854b2e937c" name="ad98f5a17f1062c11d7f8b3854b2e937c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98f5a17f1062c11d7f8b3854b2e937c">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="af9da708b5f33c8d406bc0a81e4dc3139" name="af9da708b5f33c8d406bc0a81e4dc3139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9da708b5f33c8d406bc0a81e4dc3139">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a112d84120da3c98433f18a093e0d8a92" name="a112d84120da3c98433f18a093e0d8a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112d84120da3c98433f18a093e0d8a92">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="ae5630e1b8e8d46a1907dafdec898f45f" name="ae5630e1b8e8d46a1907dafdec898f45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5630e1b8e8d46a1907dafdec898f45f">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a454f0849ca5562b412f6175ce6a68ca5" name="a454f0849ca5562b412f6175ce6a68ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454f0849ca5562b412f6175ce6a68ca5">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, double <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minEigThreshold</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a34ec951ae67f5d890ec149215b45e44e" name="a34ec951ae67f5d890ec149215b45e44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ec951ae67f5d890ec149215b45e44e">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="ab23e302b08e50af7ead50b10c385e22a" name="ab23e302b08e50af7ead50b10c385e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23e302b08e50af7ead50b10c385e22a">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a1fa1b0b3b31d018a71a27375ff230de1" name="a1fa1b0b3b31d018a71a27375ff230de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa1b0b3b31d018a71a27375ff230de1">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="abd6da46125348d92bf8f6ab3dff1b71c" name="abd6da46125348d92bf8f6ab3dff1b71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6da46125348d92bf8f6ab3dff1b71c">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="af910fdade7cd2e754b553f9e180c4780" name="af910fdade7cd2e754b553f9e180c4780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af910fdade7cd2e754b553f9e180c4780">&#9670;&#160;</a></span>calcOpticalFlowPyrLK() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.VideoModule.Video.calcOpticalFlowPyrLK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>prevImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>nextImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>prevPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db0/classOpenCVForUnity_1_1CoreModule_1_1MatOfPoint2f.html">MatOfPoint2f</a></td>          <td class="paramname"><span class="paramname"><em>nextPts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/ddf/classOpenCVForUnity_1_1CoreModule_1_1MatOfByte.html">MatOfByte</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d22/classOpenCVForUnity_1_1CoreModule_1_1MatOfFloat.html">MatOfFloat</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d54/classOpenCVForUnity_1_1CoreModule_1_1Size.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>winSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minEigThreshold</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image or pyramid constructed by buildOpticalFlowPyramid. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second input image or pyramid of the same size and the same type as prevImg. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when OPTFLOW_USE_INITIAL_FLOW flag is passed, the vector must have the same size as in the input. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn't found then the error is not defined (use the status parameter to find such cases). </td></tr>
    <tr><td class="paramname">winSize</td><td>size of the search window at each pyramid level. </td></tr>
    <tr><td class="paramname">maxLevel</td><td>0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel. </td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon. </td></tr>
    <tr><td class="paramname">flags</td><td>operation flags:<ul>
<li><b>OPTFLOW_USE_INITIAL_FLOW</b> uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.</li>
<li><b>OPTFLOW_LK_GET_MIN_EIGENVALS</b> use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. </li>
</ul>
</td></tr>
    <tr><td class="paramname">minEigThreshold</td><td>the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <b>[Bouguet00]</b>), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. </td></tr>
  </table>
  </dd>
</dl>
<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <b>[Bouguet00]</b> . The function is parallelized with the TBB library.</p>
<dl class="section note"><dt>Note</dt><dd>Some examples:</dd></dl>
<ul>
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python/lk_homography.py </li>
</ul>

</div>
</div>
<a id="a784baec5c69702aa15e2fd83aaccfc6b" name="a784baec5c69702aa15e2fd83aaccfc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784baec5c69702aa15e2fd83aaccfc6b">&#9670;&#160;</a></span>CamShift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/dd9/classOpenCVForUnity_1_1CoreModule_1_1RotatedRect.html">RotatedRect</a> OpenCVForUnity.VideoModule.Video.CamShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>probImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d13/classOpenCVForUnity_1_1CoreModule_1_1Rect.html">Rect</a></td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an object center, size, and orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See calcBackProject. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the underlying meanShift. returns (in old interfaces) Number of iterations CAMSHIFT took to converge The function implements the CAMSHIFT object tracking algorithm <b>[Bradski98]</b> . First, it finds an object center using meanShift and then adjusts the window size and finds the optimal rotation. The function returns the rotated rectangle structure that includes the object position, size, and orientation. The next position of the search window can be obtained with <a class="el" href="../../dc/dd9/classOpenCVForUnity_1_1CoreModule_1_1RotatedRect.html#a04f328279b2ae8bac94e0bddb0c94a8d">RotatedRect.boundingRect()</a> </td></tr>
  </table>
  </dd>
</dl>
<p>See the OpenCV sample camshiftdemo.c that tracks colored objects.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>(Python) A sample explaining the camshift tracking algorithm can be found at opencv_source_code/samples/python/camshift.py </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aabbd0c6a5ea4ae7ae14615a59d43ba9b" name="aabbd0c6a5ea4ae7ae14615a59d43ba9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbd0c6a5ea4ae7ae14615a59d43ba9b">&#9670;&#160;</a></span>CamShiftAsValueTuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double double double double double angle OpenCVForUnity.VideoModule.Video.CamShiftAsValueTuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>probImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref(int <a class="el" href="#a9a170d1766ad9d2556a16cc2ff9befb5">x</a>, int <a class="el" href="#a2531b886525efd19cfc86c8c861b6284">y</a>, int <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, int <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70d7033d24f7b9231d3ab1b044fb55cd" name="a70d7033d24f7b9231d3ab1b044fb55cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d7033d24f7b9231d3ab1b044fb55cd">&#9670;&#160;</a></span>CamShiftAsVec5d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d2/d1b/structOpenCVForUnity_1_1UnityIntegration_1_1Vec5d.html">Vec5d</a> OpenCVForUnity.VideoModule.Video.CamShiftAsVec5d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>probImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="../../df/d63/structOpenCVForUnity_1_1UnityIntegration_1_1Vec4i.html">Vec4i</a></td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an object center, size, and orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See calcBackProject. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the underlying meanShift. returns (in old interfaces) Number of iterations CAMSHIFT took to converge The function implements the CAMSHIFT object tracking algorithm <b>[Bradski98]</b> . First, it finds an object center using meanShift and then adjusts the window size and finds the optimal rotation. The function returns the rotated rectangle structure that includes the object position, size, and orientation. The next position of the search window can be obtained with <a class="el" href="../../dc/dd9/classOpenCVForUnity_1_1CoreModule_1_1RotatedRect.html#a04f328279b2ae8bac94e0bddb0c94a8d">RotatedRect.boundingRect()</a> </td></tr>
  </table>
  </dd>
</dl>
<p>See the OpenCV sample camshiftdemo.c that tracks colored objects.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>(Python) A sample explaining the camshift tracking algorithm can be found at opencv_source_code/samples/python/camshift.py </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae0dcf5ed98ea8b52c40721996517c511" name="ae0dcf5ed98ea8b52c40721996517c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dcf5ed98ea8b52c40721996517c511">&#9670;&#160;</a></span>computeECC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.computeECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Enhanced Correlation Coefficient value between two images <b>[EP08]</b> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templateImage</td><td>single-channel template image; CV_8U or CV_32F array. </td></tr>
    <tr><td class="paramname">inputImage</td><td>single-channel input image to be warped to provide an image similar to templateImage, same type as templateImage. </td></tr>
    <tr><td class="paramname">inputMask</td><td>An optional mask to indicate valid values of inputImage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0d172864acc3481c3da801c7324a8834" title="Finds the geometric transform (warp) between two images in terms of the ECC criterion EP08 .">findTransformECC</a> </dd></dl>

</div>
</div>
<a id="a674a2abce8e540ef9d043f30683fcd92" name="a674a2abce8e540ef9d043f30683fcd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674a2abce8e540ef9d043f30683fcd92">&#9670;&#160;</a></span>computeECC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.computeECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputMask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Enhanced Correlation Coefficient value between two images <b>[EP08]</b> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templateImage</td><td>single-channel template image; CV_8U or CV_32F array. </td></tr>
    <tr><td class="paramname">inputImage</td><td>single-channel input image to be warped to provide an image similar to templateImage, same type as templateImage. </td></tr>
    <tr><td class="paramname">inputMask</td><td>An optional mask to indicate valid values of inputImage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0d172864acc3481c3da801c7324a8834" title="Finds the geometric transform (warp) between two images in terms of the ECC criterion EP08 .">findTransformECC</a> </dd></dl>

</div>
</div>
<a id="ac3af3f2f22aac2c90a337ac4f8fcac12" name="ac3af3f2f22aac2c90a337ac4f8fcac12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3af3f2f22aac2c90a337ac4f8fcac12">&#9670;&#160;</a></span>createBackgroundSubtractorKNN() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorKNN </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates KNN Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">dist2Threshold</td><td>Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad88a09bb290f8528ed3ba19e23f73ab8" name="ad88a09bb290f8528ed3ba19e23f73ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88a09bb290f8528ed3ba19e23f73ab8">&#9670;&#160;</a></span>createBackgroundSubtractorKNN() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorKNN </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>history</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates KNN Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">dist2Threshold</td><td>Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98edfae98db5a6acbdddd0a702e05eb6" name="a98edfae98db5a6acbdddd0a702e05eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98edfae98db5a6acbdddd0a702e05eb6">&#9670;&#160;</a></span>createBackgroundSubtractorKNN() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorKNN </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>history</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dist2Threshold</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates KNN Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">dist2Threshold</td><td>Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf10f61e2c4fb27e8a7747e225a274d7" name="acf10f61e2c4fb27e8a7747e225a274d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf10f61e2c4fb27e8a7747e225a274d7">&#9670;&#160;</a></span>createBackgroundSubtractorKNN() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d1/dee/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorKNN.html">BackgroundSubtractorKNN</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorKNN </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>history</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dist2Threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>detectShadows</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates KNN Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">dist2Threshold</td><td>Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89136e8b74c649b65a834e185ab83233" name="a89136e8b74c649b65a834e185ab83233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89136e8b74c649b65a834e185ab83233">&#9670;&#160;</a></span>createBackgroundSubtractorMOG2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorMOG2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates MOG2 Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">varThreshold</td><td>Threshold on the squared Mahalanobis distance between the pixel and the model to decide whether a pixel is well described by the background model. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64f7817610c2214b39982c00cbd800ac" name="a64f7817610c2214b39982c00cbd800ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f7817610c2214b39982c00cbd800ac">&#9670;&#160;</a></span>createBackgroundSubtractorMOG2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorMOG2 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>history</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates MOG2 Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">varThreshold</td><td>Threshold on the squared Mahalanobis distance between the pixel and the model to decide whether a pixel is well described by the background model. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade94202828ddb3602d289cb00159fb2b" name="ade94202828ddb3602d289cb00159fb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade94202828ddb3602d289cb00159fb2b">&#9670;&#160;</a></span>createBackgroundSubtractorMOG2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorMOG2 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>history</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>varThreshold</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates MOG2 Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">varThreshold</td><td>Threshold on the squared Mahalanobis distance between the pixel and the model to decide whether a pixel is well described by the background model. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a4e254caa94f0e83dd3a4ca74ad626a" name="a4a4e254caa94f0e83dd3a4ca74ad626a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4e254caa94f0e83dd3a4ca74ad626a">&#9670;&#160;</a></span>createBackgroundSubtractorMOG2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d3/d29/classOpenCVForUnity_1_1VideoModule_1_1BackgroundSubtractorMOG2.html">BackgroundSubtractorMOG2</a> OpenCVForUnity.VideoModule.Video.createBackgroundSubtractorMOG2 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>history</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>varThreshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>detectShadows</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates MOG2 Background Subtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td>Length of the history. </td></tr>
    <tr><td class="paramname">varThreshold</td><td>Threshold on the squared Mahalanobis distance between the pixel and the model to decide whether a pixel is well described by the background model. This parameter does not affect the background update. </td></tr>
    <tr><td class="paramname">detectShadows</td><td>If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed032a071801909b797ae068d5c0e936" name="aed032a071801909b797ae068d5c0e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed032a071801909b797ae068d5c0e936">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4f5569c7c87c83dda72cb1033aa76f6c" name="a4f5569c7c87c83dda72cb1033aa76f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5569c7c87c83dda72cb1033aa76f6c">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a31922eefe0b7ed16d6914a054548f326" name="a31922eefe0b7ed16d6914a054548f326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31922eefe0b7ed16d6914a054548f326">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af318c2a5f8c005f08bb79bf107c264db" name="af318c2a5f8c005f08bb79bf107c264db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af318c2a5f8c005f08bb79bf107c264db">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputMask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa9261ec617d3bc60a44d1f41d8a2e495" name="aa9261ec617d3bc60a44d1f41d8a2e495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9261ec617d3bc60a44d1f41d8a2e495">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputMask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gaussFiltSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the geometric transform (warp) between two images in terms of the ECC criterion <b>[EP08]</b> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templateImage</td><td>single-channel template image; CV_8U or CV_32F array. </td></tr>
    <tr><td class="paramname">inputImage</td><td>single-channel input image which should be warped with the final warpMatrix in order to provide an image similar to templateImage, same type as templateImage. </td></tr>
    <tr><td class="paramname">warpMatrix</td><td>floating-point \(2\times 3\) or \(3\times 3\) mapping matrix (warp). </td></tr>
    <tr><td class="paramname">motionType</td><td>parameter, specifying the type of motion:<ul>
<li><b>MOTION_TRANSLATION</b> sets a translational motion model; warpMatrix is \(2\times 3\) with the first \(2\times 2\) part being the unity matrix and the rest two parameters being estimated.</li>
<li><b>MOTION_EUCLIDEAN</b> sets a Euclidean (rigid) transformation as motion model; three parameters are estimated; warpMatrix is \(2\times 3\).</li>
<li><b>MOTION_AFFINE</b> sets an affine motion model (DEFAULT); six parameters are estimated; warpMatrix is \(2\times 3\).</li>
<li><b>MOTION_HOMOGRAPHY</b> sets a homography as a motion model; eight parameters are estimated;`warpMatrix` is \(3\times 3\). </li>
</ul>
</td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the ECC algorithm; criteria.epsilon defines the threshold of the increment in the correlation coefficient between two iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion). Default values are shown in the declaration above. </td></tr>
    <tr><td class="paramname">inputMask</td><td>An optional mask to indicate valid values of inputImage. </td></tr>
    <tr><td class="paramname">gaussFiltSize</td><td>An optional value indicating size of gaussian blur filter; (DEFAULT: 5) </td></tr>
  </table>
  </dd>
</dl>
<p>The function estimates the optimum transformation (warpMatrix) with respect to ECC criterion (<b>[EP08]</b>), that is</p>
<p class="formulaDsp">
\[\texttt{warpMatrix} = \arg\max_{W} \texttt{ECC}(\texttt{templateImage}(x,y),\texttt{inputImage}(x&#39;,y&#39;))\]
</p>
<p>where</p>
<p class="formulaDsp">
\[\begin{bmatrix} x&#39; \\ y&#39; \end{bmatrix} = W \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}\]
</p>
<p>(the equation holds with homogeneous coordinates for homography). It returns the final enhanced correlation coefficient, that is the correlation coefficient between the template image and the final warped input image. When a \(3\times 3\) matrix is given with motionType =0, 1 or 2, the third row is ignored.</p>
<p>Unlike findHomography and estimateRigidTransform, the function findTransformECC implements an area-based alignment that builds on intensity similarities. In essence, the function updates the initial transformation that roughly aligns the images. If this information is missing, the identity warp (unity matrix) is used as an initialization. Note that if images undergo strong displacements/rotations, an initial transformation that roughly aligns the images is necessary (e.g., a simple euclidean/similarity transform that allows for the images showing the same image content approximately). Use inverse warping in the second image to take an image close to the first one, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV sample image_alignment.cpp that demonstrates the use of the function. Note that the function throws an exception if algorithm does not converges.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a674a2abce8e540ef9d043f30683fcd92" title="Computes the Enhanced Correlation Coefficient value between two images EP08 .">computeECC</a>, estimateAffine2D, estimateAffinePartial2D, findHomography </dd></dl>

</div>
</div>
<a id="a365e5f833a49e47d1916338c590e9113" name="a365e5f833a49e47d1916338c590e9113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365e5f833a49e47d1916338c590e9113">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a16ff0986e4bca4eb996c11bc737144c2" name="a16ff0986e4bca4eb996c11bc737144c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ff0986e4bca4eb996c11bc737144c2">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputMask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a85dddc07d4bc3912dc585e345b3f7e9a" name="a85dddc07d4bc3912dc585e345b3f7e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dddc07d4bc3912dc585e345b3f7e9a">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputMask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gaussFiltSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the geometric transform (warp) between two images in terms of the ECC criterion <b>[EP08]</b> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templateImage</td><td>single-channel template image; CV_8U or CV_32F array. </td></tr>
    <tr><td class="paramname">inputImage</td><td>single-channel input image which should be warped with the final warpMatrix in order to provide an image similar to templateImage, same type as templateImage. </td></tr>
    <tr><td class="paramname">warpMatrix</td><td>floating-point \(2\times 3\) or \(3\times 3\) mapping matrix (warp). </td></tr>
    <tr><td class="paramname">motionType</td><td>parameter, specifying the type of motion:<ul>
<li><b>MOTION_TRANSLATION</b> sets a translational motion model; warpMatrix is \(2\times 3\) with the first \(2\times 2\) part being the unity matrix and the rest two parameters being estimated.</li>
<li><b>MOTION_EUCLIDEAN</b> sets a Euclidean (rigid) transformation as motion model; three parameters are estimated; warpMatrix is \(2\times 3\).</li>
<li><b>MOTION_AFFINE</b> sets an affine motion model (DEFAULT); six parameters are estimated; warpMatrix is \(2\times 3\).</li>
<li><b>MOTION_HOMOGRAPHY</b> sets a homography as a motion model; eight parameters are estimated;`warpMatrix` is \(3\times 3\). </li>
</ul>
</td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the ECC algorithm; criteria.epsilon defines the threshold of the increment in the correlation coefficient between two iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion). Default values are shown in the declaration above. </td></tr>
    <tr><td class="paramname">inputMask</td><td>An optional mask to indicate valid values of inputImage. </td></tr>
    <tr><td class="paramname">gaussFiltSize</td><td>An optional value indicating size of gaussian blur filter; (DEFAULT: 5) </td></tr>
  </table>
  </dd>
</dl>
<p>The function estimates the optimum transformation (warpMatrix) with respect to ECC criterion (<b>[EP08]</b>), that is</p>
<p class="formulaDsp">
\[\texttt{warpMatrix} = \arg\max_{W} \texttt{ECC}(\texttt{templateImage}(x,y),\texttt{inputImage}(x&#39;,y&#39;))\]
</p>
<p>where</p>
<p class="formulaDsp">
\[\begin{bmatrix} x&#39; \\ y&#39; \end{bmatrix} = W \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}\]
</p>
<p>(the equation holds with homogeneous coordinates for homography). It returns the final enhanced correlation coefficient, that is the correlation coefficient between the template image and the final warped input image. When a \(3\times 3\) matrix is given with motionType =0, 1 or 2, the third row is ignored.</p>
<p>Unlike findHomography and estimateRigidTransform, the function findTransformECC implements an area-based alignment that builds on intensity similarities. In essence, the function updates the initial transformation that roughly aligns the images. If this information is missing, the identity warp (unity matrix) is used as an initialization. Note that if images undergo strong displacements/rotations, an initial transformation that roughly aligns the images is necessary (e.g., a simple euclidean/similarity transform that allows for the images showing the same image content approximately). Use inverse warping in the second image to take an image close to the first one, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV sample image_alignment.cpp that demonstrates the use of the function. Note that the function throws an exception if algorithm does not converges.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a674a2abce8e540ef9d043f30683fcd92" title="Computes the Enhanced Correlation Coefficient value between two images EP08 .">computeECC</a>, estimateAffine2D, estimateAffinePartial2D, findHomography </dd></dl>

</div>
</div>
<a id="ab7ec33b6f2832fedad26072d9f174bbe" name="ab7ec33b6f2832fedad26072d9f174bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ec33b6f2832fedad26072d9f174bbe">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae3bae8fc3159ec8424ff2a46c5203445" name="ae3bae8fc3159ec8424ff2a46c5203445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3bae8fc3159ec8424ff2a46c5203445">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputMask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0d172864acc3481c3da801c7324a8834" name="a0d172864acc3481c3da801c7324a8834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d172864acc3481c3da801c7324a8834">&#9670;&#160;</a></span>findTransformECC() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenCVForUnity.VideoModule.Video.findTransformECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>templateImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>warpMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>motionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>inputMask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gaussFiltSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the geometric transform (warp) between two images in terms of the ECC criterion <b>[EP08]</b> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">templateImage</td><td>single-channel template image; CV_8U or CV_32F array. </td></tr>
    <tr><td class="paramname">inputImage</td><td>single-channel input image which should be warped with the final warpMatrix in order to provide an image similar to templateImage, same type as templateImage. </td></tr>
    <tr><td class="paramname">warpMatrix</td><td>floating-point \(2\times 3\) or \(3\times 3\) mapping matrix (warp). </td></tr>
    <tr><td class="paramname">motionType</td><td>parameter, specifying the type of motion:<ul>
<li><b>MOTION_TRANSLATION</b> sets a translational motion model; warpMatrix is \(2\times 3\) with the first \(2\times 2\) part being the unity matrix and the rest two parameters being estimated.</li>
<li><b>MOTION_EUCLIDEAN</b> sets a Euclidean (rigid) transformation as motion model; three parameters are estimated; warpMatrix is \(2\times 3\).</li>
<li><b>MOTION_AFFINE</b> sets an affine motion model (DEFAULT); six parameters are estimated; warpMatrix is \(2\times 3\).</li>
<li><b>MOTION_HOMOGRAPHY</b> sets a homography as a motion model; eight parameters are estimated;`warpMatrix` is \(3\times 3\). </li>
</ul>
</td></tr>
    <tr><td class="paramname">criteria</td><td>parameter, specifying the termination criteria of the ECC algorithm; criteria.epsilon defines the threshold of the increment in the correlation coefficient between two iterations (a negative criteria.epsilon makes criteria.maxcount the only termination criterion). Default values are shown in the declaration above. </td></tr>
    <tr><td class="paramname">inputMask</td><td>An optional mask to indicate valid values of inputImage. </td></tr>
    <tr><td class="paramname">gaussFiltSize</td><td>An optional value indicating size of gaussian blur filter; (DEFAULT: 5) </td></tr>
  </table>
  </dd>
</dl>
<p>The function estimates the optimum transformation (warpMatrix) with respect to ECC criterion (<b>[EP08]</b>), that is</p>
<p class="formulaDsp">
\[\texttt{warpMatrix} = \arg\max_{W} \texttt{ECC}(\texttt{templateImage}(x,y),\texttt{inputImage}(x&#39;,y&#39;))\]
</p>
<p>where</p>
<p class="formulaDsp">
\[\begin{bmatrix} x&#39; \\ y&#39; \end{bmatrix} = W \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}\]
</p>
<p>(the equation holds with homogeneous coordinates for homography). It returns the final enhanced correlation coefficient, that is the correlation coefficient between the template image and the final warped input image. When a \(3\times 3\) matrix is given with motionType =0, 1 or 2, the third row is ignored.</p>
<p>Unlike findHomography and estimateRigidTransform, the function findTransformECC implements an area-based alignment that builds on intensity similarities. In essence, the function updates the initial transformation that roughly aligns the images. If this information is missing, the identity warp (unity matrix) is used as an initialization. Note that if images undergo strong displacements/rotations, an initial transformation that roughly aligns the images is necessary (e.g., a simple euclidean/similarity transform that allows for the images showing the same image content approximately). Use inverse warping in the second image to take an image close to the first one, i.e. use the flag WARP_INVERSE_MAP with warpAffine or warpPerspective. See also the OpenCV sample image_alignment.cpp that demonstrates the use of the function. Note that the function throws an exception if algorithm does not converges.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a674a2abce8e540ef9d043f30683fcd92" title="Computes the Enhanced Correlation Coefficient value between two images EP08 .">computeECC</a>, estimateAffine2D, estimateAffinePartial2D, findHomography </dd></dl>

</div>
</div>
<a id="ac5533dd028a49ea8e443c748e219d26a" name="ac5533dd028a49ea8e443c748e219d26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5533dd028a49ea8e443c748e219d26a">&#9670;&#160;</a></span>meanShift() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.meanShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>probImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d13/classOpenCVForUnity_1_1CoreModule_1_1Rect.html">Rect</a></td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/classOpenCVForUnity_1_1CoreModule_1_1TermCriteria.html">TermCriteria</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an object on a back projection image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See calcBackProject for details. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the iterative search algorithm. returns : Number of iterations CAMSHIFT took to converge. The function implements the iterative object search algorithm. It takes the input back projection of an object and the initial position. The mass center in window of the back projection image is computed and the search window center shifts to the mass center. The procedure is repeated until the specified number of iterations criteria.maxCount is done or until the window center shifts by less than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search window size or orientation do not change during the search. You can simply pass the output of calcBackProject to this function. But better results can be obtained if you pre-filter the back projection and remove the noise. For example, you can do this by retrieving connected components with findContours , throwing away contours with small area ( contourArea ), and rendering the remaining contours with drawContours. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89972d347a0dac846e3480f709b28924" name="a89972d347a0dac846e3480f709b28924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89972d347a0dac846e3480f709b28924">&#9670;&#160;</a></span>meanShift() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.meanShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>probImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="../../df/d63/structOpenCVForUnity_1_1UnityIntegration_1_1Vec4i.html">Vec4i</a></td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="../../d0/db1/structOpenCVForUnity_1_1UnityIntegration_1_1Vec3d.html">Vec3d</a></td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an object on a back projection image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See calcBackProject for details. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the iterative search algorithm. returns : Number of iterations CAMSHIFT took to converge. The function implements the iterative object search algorithm. It takes the input back projection of an object and the initial position. The mass center in window of the back projection image is computed and the search window center shifts to the mass center. The procedure is repeated until the specified number of iterations criteria.maxCount is done or until the window center shifts by less than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search window size or orientation do not change during the search. You can simply pass the output of calcBackProject to this function. But better results can be obtained if you pre-filter the back projection and remove the noise. For example, you can do this by retrieving connected components with findContours , throwing away contours with small area ( contourArea ), and rendering the remaining contours with drawContours. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a051f68aa46593426a75355a4b310b06c" name="a051f68aa46593426a75355a4b310b06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051f68aa46593426a75355a4b310b06c">&#9670;&#160;</a></span>meanShift() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.VideoModule.Video.meanShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>probImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref(int <a class="el" href="#a9a170d1766ad9d2556a16cc2ff9befb5">x</a>, int <a class="el" href="#a2531b886525efd19cfc86c8c861b6284">y</a>, int <a class="el" href="#a9624b8d608cf8d05cd8d95a8ee12c35b">width</a>, int <a class="el" href="#a88adc4d9e1bb4854198734216c3ee2de">height</a>)</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in(double type, double maxCount, double epsilon)</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an object on a back projection image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See calcBackProject for details. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the iterative search algorithm. returns : Number of iterations CAMSHIFT took to converge. The function implements the iterative object search algorithm. It takes the input back projection of an object and the initial position. The mass center in window of the back projection image is computed and the search window center shifts to the mass center. The procedure is repeated until the specified number of iterations criteria.maxCount is done or until the window center shifts by less than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search window size or orientation do not change during the search. You can simply pass the output of calcBackProject to this function. But better results can be obtained if you pre-filter the back projection and remove the noise. For example, you can do this by retrieving connected components with findContours , throwing away contours with small area ( contourArea ), and rendering the remaining contours with drawContours. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692d44ba7b52672c2b7cacbbb3089942" name="a692d44ba7b52672c2b7cacbbb3089942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692d44ba7b52672c2b7cacbbb3089942">&#9670;&#160;</a></span>readOpticalFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> OpenCVForUnity.VideoModule.Video.readOpticalFlow </td>
          <td>(</td>
          <td class="paramtype">string</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a .flo file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to the file to be loaded </td></tr>
  </table>
  </dd>
</dl>
<p>The function readOpticalFlow loads a flow field from a file and returns it as a single matrix. Resulting Mat has a type CV_32FC2 - floating-point, 2-channel. First channel corresponds to the flow in the horizontal direction (u), second - vertical (v). </p>

</div>
</div>
<a id="a131494e1a4afc6d541687b0fcd35d6cb" name="a131494e1a4afc6d541687b0fcd35d6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131494e1a4afc6d541687b0fcd35d6cb">&#9670;&#160;</a></span>writeOpticalFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenCVForUnity.VideoModule.Video.writeOpticalFlow </td>
          <td>(</td>
          <td class="paramtype">string</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>flow</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a .flo to disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to the file to be written </td></tr>
    <tr><td class="paramname">flow</td><td>Flow field to be stored </td></tr>
  </table>
  </dd>
</dl>
<p>The function stores a flow field in a file, returns true on success, false otherwise. The flow field must be a 2-channel, floating-point matrix (CV_32FC2). First channel corresponds to the flow in the horizontal direction (u), second - vertical (v). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a88adc4d9e1bb4854198734216c3ee2de" name="a88adc4d9e1bb4854198734216c3ee2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88adc4d9e1bb4854198734216c3ee2de">&#9670;&#160;</a></span>height</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double double double double OpenCVForUnity.VideoModule.Video.height</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe67e1b2e8db13461e6d79e39f33b2e5" name="afe67e1b2e8db13461e6d79e39f33b2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe67e1b2e8db13461e6d79e39f33b2e5">&#9670;&#160;</a></span>MOTION_AFFINE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.MOTION_AFFINE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum &lt;unnamed&gt; </p>

</div>
</div>
<a id="a64aa60a163d98d4c7afb6ed32d7ece67" name="a64aa60a163d98d4c7afb6ed32d7ece67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64aa60a163d98d4c7afb6ed32d7ece67">&#9670;&#160;</a></span>MOTION_EUCLIDEAN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.MOTION_EUCLIDEAN = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum &lt;unnamed&gt; </p>

</div>
</div>
<a id="a864d3de23bc2c4a5d2bfc20c9bca0b4f" name="a864d3de23bc2c4a5d2bfc20c9bca0b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864d3de23bc2c4a5d2bfc20c9bca0b4f">&#9670;&#160;</a></span>MOTION_HOMOGRAPHY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.MOTION_HOMOGRAPHY = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum &lt;unnamed&gt; </p>

</div>
</div>
<a id="a172553c7ea86d511cb4581290dbdfb8a" name="a172553c7ea86d511cb4581290dbdfb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172553c7ea86d511cb4581290dbdfb8a">&#9670;&#160;</a></span>MOTION_TRANSLATION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.MOTION_TRANSLATION = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum &lt;unnamed&gt; </p>

</div>
</div>
<a id="aa3947653ec7356fef015dc70f124f22c" name="aa3947653ec7356fef015dc70f124f22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3947653ec7356fef015dc70f124f22c">&#9670;&#160;</a></span>OPTFLOW_FARNEBACK_GAUSSIAN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.OPTFLOW_FARNEBACK_GAUSSIAN = 256</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum &lt;unnamed&gt; </p>

</div>
</div>
<a id="a38d66a0846b209d0ce4e089d1da7baf0" name="a38d66a0846b209d0ce4e089d1da7baf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d66a0846b209d0ce4e089d1da7baf0">&#9670;&#160;</a></span>OPTFLOW_LK_GET_MIN_EIGENVALS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.OPTFLOW_LK_GET_MIN_EIGENVALS = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum &lt;unnamed&gt; </p>

</div>
</div>
<a id="aef373d149dd26fd89d709252791efb1a" name="aef373d149dd26fd89d709252791efb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef373d149dd26fd89d709252791efb1a">&#9670;&#160;</a></span>OPTFLOW_USE_INITIAL_FLOW</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.OPTFLOW_USE_INITIAL_FLOW = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum &lt;unnamed&gt; </p>

</div>
</div>
<a id="abea4082bbbf4879d978d5fa838d4195a" name="abea4082bbbf4879d978d5fa838d4195a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4082bbbf4879d978d5fa838d4195a">&#9670;&#160;</a></span>TrackerSamplerCSC_MODE_DETECT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.TrackerSamplerCSC_MODE_DETECT = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE) </p>

</div>
</div>
<a id="a7a937ccd26d061e7d546ab6b47793cdd" name="a7a937ccd26d061e7d546ab6b47793cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a937ccd26d061e7d546ab6b47793cdd">&#9670;&#160;</a></span>TrackerSamplerCSC_MODE_INIT_NEG</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.TrackerSamplerCSC_MODE_INIT_NEG = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE) </p>

</div>
</div>
<a id="a4dbb75a4c95b60b36f72b47699db242c" name="a4dbb75a4c95b60b36f72b47699db242c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbb75a4c95b60b36f72b47699db242c">&#9670;&#160;</a></span>TrackerSamplerCSC_MODE_INIT_POS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.TrackerSamplerCSC_MODE_INIT_POS = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE) </p>

</div>
</div>
<a id="ac4705123bac94d5a88e02f9c92de60eb" name="ac4705123bac94d5a88e02f9c92de60eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4705123bac94d5a88e02f9c92de60eb">&#9670;&#160;</a></span>TrackerSamplerCSC_MODE_TRACK_NEG</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.TrackerSamplerCSC_MODE_TRACK_NEG = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE) </p>

</div>
</div>
<a id="a85e1acdb165507fd8768786f1f9fe115" name="a85e1acdb165507fd8768786f1f9fe115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e1acdb165507fd8768786f1f9fe115">&#9670;&#160;</a></span>TrackerSamplerCSC_MODE_TRACK_POS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int OpenCVForUnity.VideoModule.Video.TrackerSamplerCSC_MODE_TRACK_POS = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++: enum MODE (cv.detail.TrackerSamplerCSC.MODE) </p>

</div>
</div>
<a id="a9624b8d608cf8d05cd8d95a8ee12c35b" name="a9624b8d608cf8d05cd8d95a8ee12c35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9624b8d608cf8d05cd8d95a8ee12c35b">&#9670;&#160;</a></span>width</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double double double OpenCVForUnity.VideoModule.Video.width</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a170d1766ad9d2556a16cc2ff9befb5" name="a9a170d1766ad9d2556a16cc2ff9befb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a170d1766ad9d2556a16cc2ff9befb5">&#9670;&#160;</a></span>x</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OpenCVForUnity.VideoModule.Video.x</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an object center, size, and orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See calcBackProject. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the underlying meanShift. returns (in old interfaces) Number of iterations CAMSHIFT took to converge The function implements the CAMSHIFT object tracking algorithm <b>[Bradski98]</b> . First, it finds an object center using meanShift and then adjusts the window size and finds the optimal rotation. The function returns the rotated rectangle structure that includes the object position, size, and orientation. The next position of the search window can be obtained with <a class="el" href="../../dc/dd9/classOpenCVForUnity_1_1CoreModule_1_1RotatedRect.html#a04f328279b2ae8bac94e0bddb0c94a8d">RotatedRect.boundingRect()</a> </td></tr>
  </table>
  </dd>
</dl>
<p>See the OpenCV sample camshiftdemo.c that tracks colored objects.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>(Python) A sample explaining the camshift tracking algorithm can be found at opencv_source_code/samples/python/camshift.py </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2531b886525efd19cfc86c8c861b6284" name="a2531b886525efd19cfc86c8c861b6284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2531b886525efd19cfc86c8c861b6284">&#9670;&#160;</a></span>y</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double double OpenCVForUnity.VideoModule.Video.y</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/video/<a class="el" href="../../d7/dda/Video_8cs.html">Video.cs</a></li>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/video/<a class="el" href="../../dd/d43/Video__Struct_8cs.html">Video_Struct.cs</a></li>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/video/<a class="el" href="../../d8/da6/Video__ValueTuple_8cs.html">Video_ValueTuple.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
