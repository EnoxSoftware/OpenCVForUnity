<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenCV for Unity: OpenCVForUnity.UnityIntegration.OpenCVMatUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<script type="text/javascript" src="../../darkmode_toggle.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OpenCV for Unity<span id="projectnumber">&#160;3.0.1</span>
   </div>
   <div id="projectbrief">Enox Software / Please refer to OpenCV official document ( http://docs.opencv.org/4.12.0/index.html ) for the details of the argument of the method.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/da5/namespaceOpenCVForUnity.html">OpenCVForUnity</a></li><li class="navelem"><a class="el" href="../../d4/ddd/namespaceOpenCVForUnity_1_1UnityIntegration.html">UnityIntegration</a></li><li class="navelem"><a class="el" href="../../db/daa/classOpenCVForUnity_1_1UnityIntegration_1_1OpenCVMatUtils.html">OpenCVMatUtils</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d6/d10/classOpenCVForUnity_1_1UnityIntegration_1_1OpenCVMatUtils-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OpenCVForUnity.UnityIntegration.OpenCVMatUtils Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>OpenCV Mat utilities.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aefc2e0199e4ccc24e3620c5fda8fd7a3" id="r_aefc2e0199e4ccc24e3620c5fda8fd7a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a> { <br />
&#160;&#160;<a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3aba158bef870b6f8785634376161d0142">PerPixel</a>
, <br />
&#160;&#160;<a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3a55dc0f639728ab8ecd2398ba5b934b08">Contiguous</a>
<br />
 }</td></tr>
<tr class="memdesc:aefc2e0199e4ccc24e3620c5fda8fd7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration to specify the data copy method.  <a href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">More...</a><br /></td></tr>
<tr class="separator:aefc2e0199e4ccc24e3620c5fda8fd7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a48710cdfcfa7583baae088328e539db6" id="r_a48710cdfcfa7583baae088328e539db6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48710cdfcfa7583baae088328e539db6">CopyFromMat</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, IntPtr intPtr)</td></tr>
<tr class="memdesc:a48710cdfcfa7583baae088328e539db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to an IntPtr.  <br /></td></tr>
<tr class="separator:a48710cdfcfa7583baae088328e539db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf35a4a4190abc58dd6d11e62898f12" id="r_addf35a4a4190abc58dd6d11e62898f12"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addf35a4a4190abc58dd6d11e62898f12">CopyFromMat</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, IntPtr intPtr, int length)</td></tr>
<tr class="memdesc:addf35a4a4190abc58dd6d11e62898f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to an IntPtr.  <br /></td></tr>
<tr class="separator:addf35a4a4190abc58dd6d11e62898f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387d3b8b521c221da80ea389b0fe2826" id="r_a387d3b8b521c221da80ea389b0fe2826"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a387d3b8b521c221da80ea389b0fe2826">CopyFromMat&lt; T &gt;</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, IntPtr intPtr, int length)</td></tr>
<tr class="memdesc:a387d3b8b521c221da80ea389b0fe2826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to an IntPtr.  <br /></td></tr>
<tr class="separator:a387d3b8b521c221da80ea389b0fe2826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa603b1b057b463daa78e921ac8395cc6" id="r_aa603b1b057b463daa78e921ac8395cc6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa603b1b057b463daa78e921ac8395cc6">CopyFromMat&lt; T &gt;</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, NativeArray&lt; T &gt; array)</td></tr>
<tr class="memdesc:aa603b1b057b463daa78e921ac8395cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to a NativeArray.  <br /></td></tr>
<tr class="separator:aa603b1b057b463daa78e921ac8395cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259cb8e685ecba76f4086ea01140d526" id="r_a259cb8e685ecba76f4086ea01140d526"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a259cb8e685ecba76f4086ea01140d526">CopyFromMat&lt; T &gt;</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, NativeArray&lt; T &gt; array, int length)</td></tr>
<tr class="memdesc:a259cb8e685ecba76f4086ea01140d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to a NativeArray.  <br /></td></tr>
<tr class="separator:a259cb8e685ecba76f4086ea01140d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f52ffc0d45a80d64ff20b5e2a75e741" id="r_a5f52ffc0d45a80d64ff20b5e2a75e741"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f52ffc0d45a80d64ff20b5e2a75e741">CopyFromMat&lt; T &gt;</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Span&lt; T &gt; array)</td></tr>
<tr class="memdesc:a5f52ffc0d45a80d64ff20b5e2a75e741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to a Span.  <br /></td></tr>
<tr class="separator:a5f52ffc0d45a80d64ff20b5e2a75e741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1065e553a4ca29818f86ddcd68327bd" id="r_ae1065e553a4ca29818f86ddcd68327bd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1065e553a4ca29818f86ddcd68327bd">CopyFromMat&lt; T &gt;</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Span&lt; T &gt; array, int length)</td></tr>
<tr class="memdesc:ae1065e553a4ca29818f86ddcd68327bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to a Span.  <br /></td></tr>
<tr class="separator:ae1065e553a4ca29818f86ddcd68327bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716534e77e63e409b4a37f1a061d0c8d" id="r_a716534e77e63e409b4a37f1a061d0c8d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a716534e77e63e409b4a37f1a061d0c8d">CopyFromMat&lt; T &gt;</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, T[] array)</td></tr>
<tr class="memdesc:a716534e77e63e409b4a37f1a061d0c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to a managed array.  <br /></td></tr>
<tr class="separator:a716534e77e63e409b4a37f1a061d0c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1628974b1b1dc7108f6214f5aba668" id="r_a2b1628974b1b1dc7108f6214f5aba668"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b1628974b1b1dc7108f6214f5aba668">CopyFromMat&lt; T &gt;</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, T[] array, int length)</td></tr>
<tr class="memdesc:a2b1628974b1b1dc7108f6214f5aba668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an OpenCV Mat to a managed array.  <br /></td></tr>
<tr class="separator:a2b1628974b1b1dc7108f6214f5aba668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66a7ef84edf817701370ca3984e18d3" id="r_ae66a7ef84edf817701370ca3984e18d3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">CopyToMat</a> (IntPtr intPtr, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat)</td></tr>
<tr class="memdesc:ae66a7ef84edf817701370ca3984e18d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an IntPtr to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:ae66a7ef84edf817701370ca3984e18d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981002a5a0a4e11efbdf17179769aa34" id="r_a981002a5a0a4e11efbdf17179769aa34"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981002a5a0a4e11efbdf17179769aa34">CopyToMat</a> (IntPtr intPtr, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, int length)</td></tr>
<tr class="memdesc:a981002a5a0a4e11efbdf17179769aa34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an IntPtr to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a981002a5a0a4e11efbdf17179769aa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c077b1fda6277044245de397f0c2ec7" id="r_a2c077b1fda6277044245de397f0c2ec7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c077b1fda6277044245de397f0c2ec7">CopyToMat&lt; T &gt;</a> (IntPtr intPtr, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, int length)</td></tr>
<tr class="memdesc:a2c077b1fda6277044245de397f0c2ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from an IntPtr to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a2c077b1fda6277044245de397f0c2ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2d9f8bc254748d3abe6b38e2d128dc" id="r_aba2d9f8bc254748d3abe6b38e2d128dc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2d9f8bc254748d3abe6b38e2d128dc">CopyToMat&lt; T &gt;</a> (NativeArray&lt; T &gt; array, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat)</td></tr>
<tr class="memdesc:aba2d9f8bc254748d3abe6b38e2d128dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from a NativeArray to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:aba2d9f8bc254748d3abe6b38e2d128dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4281042835abb42aab2dafeea6e17d69" id="r_a4281042835abb42aab2dafeea6e17d69"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4281042835abb42aab2dafeea6e17d69">CopyToMat&lt; T &gt;</a> (NativeArray&lt; T &gt; array, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, int length)</td></tr>
<tr class="memdesc:a4281042835abb42aab2dafeea6e17d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from a NativeArray to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a4281042835abb42aab2dafeea6e17d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4182f588d2022ba906d0fbecb7a9cc3d" id="r_a4182f588d2022ba906d0fbecb7a9cc3d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4182f588d2022ba906d0fbecb7a9cc3d">CopyToMat&lt; T &gt;</a> (ReadOnlySpan&lt; T &gt; array, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat)</td></tr>
<tr class="memdesc:a4182f588d2022ba906d0fbecb7a9cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from a Span to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a4182f588d2022ba906d0fbecb7a9cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63785d44205e4ac57812418acac0ae79" id="r_a63785d44205e4ac57812418acac0ae79"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63785d44205e4ac57812418acac0ae79">CopyToMat&lt; T &gt;</a> (ReadOnlySpan&lt; T &gt; array, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, int length)</td></tr>
<tr class="memdesc:a63785d44205e4ac57812418acac0ae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from a Span to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a63785d44205e4ac57812418acac0ae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45e952ddf60560bd564b17ce9131eca" id="r_ac45e952ddf60560bd564b17ce9131eca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac45e952ddf60560bd564b17ce9131eca">CopyToMat&lt; T &gt;</a> (T[] array, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat)</td></tr>
<tr class="memdesc:ac45e952ddf60560bd564b17ce9131eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from a managed array to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:ac45e952ddf60560bd564b17ce9131eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc346be92a80015ec4dbc89d8f9ea874" id="r_acc346be92a80015ec4dbc89d8f9ea874"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc346be92a80015ec4dbc89d8f9ea874">CopyToMat&lt; T &gt;</a> (T[] array, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, int length)</td></tr>
<tr class="memdesc:acc346be92a80015ec4dbc89d8f9ea874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from a managed array to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:acc346be92a80015ec4dbc89d8f9ea874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe82bd698498d5dcd0a31866d70a43f0" id="r_abe82bd698498d5dcd0a31866d70a43f0"><td class="memItemLeft" align="right" valign="top">static ComputeShader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe82bd698498d5dcd0a31866d70a43f0">CreateMatToRenderTextureComputeShader</a> (GraphicsBuffer graphicsBuffer, RenderTexture renderTexture, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:abe82bd698498d5dcd0a31866d70a43f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ComputeShader for converting from Mat to RenderTexture based on the current platform and graphics API. This ComputeShader is intended to be used with the kernel index obtained from the GetKernelIndexForMatToRenderTextureComputeShader method when dispatching.  <br /></td></tr>
<tr class="separator:abe82bd698498d5dcd0a31866d70a43f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00793809e2b1fa5eb5be130dfbc80e6" id="r_aa00793809e2b1fa5eb5be130dfbc80e6"><td class="memItemLeft" align="right" valign="top">static ComputeShader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa00793809e2b1fa5eb5be130dfbc80e6">CreateRenderTextureToMatComputeShader</a> (RenderTexture renderTexture, GraphicsBuffer graphicsBuffer, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:aa00793809e2b1fa5eb5be130dfbc80e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ComputeShader for converting from RenderTexture to Mat based on the current platform and graphics API. This ComputeShader is intended to be used with the kernel index obtained from the GetKernelIndexForRenderTextureToMatComputeShader method when dispatching.  <br /></td></tr>
<tr class="separator:aa00793809e2b1fa5eb5be130dfbc80e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa779fd4edad91cffb4a6ce4260276813" id="r_aa779fd4edad91cffb4a6ce4260276813"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa779fd4edad91cffb4a6ce4260276813">GetKernelIndexForMatToRenderTextureComputeShader</a> (GraphicsBuffer graphicsBuffer, RenderTexture renderTexture)</td></tr>
<tr class="memdesc:aa779fd4edad91cffb4a6ce4260276813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the kernel index to use for converting from Mat to RenderTexture based on the current platform and graphics API. This kernel index is intended to be used when dispatching the ComputeShader obtained from the CreateMatToRenderTextureComputeShader method.  <br /></td></tr>
<tr class="separator:aa779fd4edad91cffb4a6ce4260276813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5979c9923c37df6bdea890f36046cc79" id="r_a5979c9923c37df6bdea890f36046cc79"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5979c9923c37df6bdea890f36046cc79">GetKernelIndexForRenderTextureToMatComputeShader</a> (RenderTexture renderTexture, GraphicsBuffer graphicsBuffer)</td></tr>
<tr class="memdesc:a5979c9923c37df6bdea890f36046cc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the kernel index to use for converting from RenderTexture to Mat based on the current platform and graphics API. This kernel index is intended to be used when dispatching the ComputeShader obtained from the CreateRenderTextureToMatComputeShader method.  <br /></td></tr>
<tr class="separator:a5979c9923c37df6bdea890f36046cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e0390d15b08d4847d81e2ce8454737" id="r_ac1e0390d15b08d4847d81e2ce8454737"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1e0390d15b08d4847d81e2ce8454737">GraphicsBufferToMat</a> (GraphicsBuffer graphicsBuffer, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, <a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a> copyMode)</td></tr>
<tr class="memdesc:ac1e0390d15b08d4847d81e2ce8454737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a Unity GraphicsBuffer to a OpenCV Mat.  <br /></td></tr>
<tr class="separator:ac1e0390d15b08d4847d81e2ce8454737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eef9dc97416fe755aba47227a979d3" id="r_a18eef9dc97416fe755aba47227a979d3"><td class="memItemLeft" align="right" valign="top">static async Awaitable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18eef9dc97416fe755aba47227a979d3">GraphicsBufferToMatAsync</a> (GraphicsBuffer graphicsBuffer, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, <a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a> copyMode, CancellationToken cancellationToken=default)</td></tr>
<tr class="memdesc:a18eef9dc97416fe755aba47227a979d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a Unity GraphicsBuffer to an OpenCV Mat asynchronously.  <br /></td></tr>
<tr class="separator:a18eef9dc97416fe755aba47227a979d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b773b392f3c1d94a9b362670a159aa" id="r_ad3b773b392f3c1d94a9b362670a159aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3b773b392f3c1d94a9b362670a159aa">MatToGraphicsBuffer</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, GraphicsBuffer graphicsBuffer, <a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a> copyMode)</td></tr>
<tr class="memdesc:ad3b773b392f3c1d94a9b362670a159aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a OpenCv Mat to a Unity GraphicsBuffer.  <br /></td></tr>
<tr class="separator:ad3b773b392f3c1d94a9b362670a159aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1a00a2b3b960bf4412a8024007fe1c" id="r_afe1a00a2b3b960bf4412a8024007fe1c"><td class="memItemLeft" align="right" valign="top">static async Awaitable&lt; AsyncGPUReadbackRequest &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe1a00a2b3b960bf4412a8024007fe1c">MatToGraphicsBufferAsync</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, GraphicsBuffer graphicsBuffer, <a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a> copyMode, CancellationToken cancellationToken=default)</td></tr>
<tr class="memdesc:afe1a00a2b3b960bf4412a8024007fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a OpenCv Mat to a Unity GraphicsBuffer asynchronously.  <br /></td></tr>
<tr class="separator:afe1a00a2b3b960bf4412a8024007fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09d08f11c04079bc54fcf3896a45362" id="r_aa09d08f11c04079bc54fcf3896a45362"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa09d08f11c04079bc54fcf3896a45362">MatToRenderTexture</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, RenderTexture renderTexture, GraphicsBuffer graphicsBuffer, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:aa09d08f11c04079bc54fcf3896a45362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an OpenCV Mat to a Unity RenderTexture.  <br /></td></tr>
<tr class="separator:aa09d08f11c04079bc54fcf3896a45362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa6ce959e625f31a9ab8e70b22e9741" id="r_a4fa6ce959e625f31a9ab8e70b22e9741"><td class="memItemLeft" align="right" valign="top">static async Awaitable&lt; AsyncGPUReadbackRequest &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fa6ce959e625f31a9ab8e70b22e9741">MatToRenderTextureAsync</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, RenderTexture renderTexture, GraphicsBuffer graphicsBuffer, bool flip=true, int flipCode=0, CancellationToken cancellationToken=default)</td></tr>
<tr class="memdesc:a4fa6ce959e625f31a9ab8e70b22e9741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an OpenCV Mat to a Unity RenderTexture asynchronously.  <br /></td></tr>
<tr class="separator:a4fa6ce959e625f31a9ab8e70b22e9741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472598bfc9d411f7200386e515609263" id="r_a472598bfc9d411f7200386e515609263"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a472598bfc9d411f7200386e515609263">MatToTexture2D</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Texture2D texture2D, bool flip=true, int flipCode=0, bool updateMipmaps=false, bool makeNoLongerReadable=false)</td></tr>
<tr class="memdesc:a472598bfc9d411f7200386e515609263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an OpenCV Mat to a Unity Texture2D.  <br /></td></tr>
<tr class="separator:a472598bfc9d411f7200386e515609263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87f624be9208c8b2b9b8b54e82b1935" id="r_aa87f624be9208c8b2b9b8b54e82b1935"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87f624be9208c8b2b9b8b54e82b1935">MatToTexture2D</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Texture2D texture2D, Color32[] pixels32Buffer, byte[] rawTextureDataBuffer=null, bool flip=true, int flipCode=0, bool updateMipmaps=false, bool makeNoLongerReadable=false)</td></tr>
<tr class="memdesc:aa87f624be9208c8b2b9b8b54e82b1935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an OpenCV Mat to a Unity Texture2D.  <br /></td></tr>
<tr class="separator:aa87f624be9208c8b2b9b8b54e82b1935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f80f4db8449c30239187434305f6a2" id="r_ad7f80f4db8449c30239187434305f6a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7f80f4db8449c30239187434305f6a2">MatToTexture2D</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Texture2D texture2D, int mipLevel, bool flip=true, int flipCode=0, bool updateMipmaps=false, bool makeNoLongerReadable=false)</td></tr>
<tr class="memdesc:ad7f80f4db8449c30239187434305f6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level.  <br /></td></tr>
<tr class="separator:ad7f80f4db8449c30239187434305f6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a098f47f928d44daff0d6d270c3e2c" id="r_a34a098f47f928d44daff0d6d270c3e2c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34a098f47f928d44daff0d6d270c3e2c">MatToTexture2D</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Texture2D texture2D, int mipLevel, Color32[] pixels32Buffer, bool flip=true, int flipCode=0, bool updateMipmaps=false, bool makeNoLongerReadable=false)</td></tr>
<tr class="memdesc:a34a098f47f928d44daff0d6d270c3e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level.  <br /></td></tr>
<tr class="separator:a34a098f47f928d44daff0d6d270c3e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e929156ae8fc613aa281361ee89da8e" id="r_a2e929156ae8fc613aa281361ee89da8e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e929156ae8fc613aa281361ee89da8e">MatToTexture2DRaw</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Texture2D texture2D, bool flip=true, int flipCode=0, bool updateMipmaps=false, bool makeNoLongerReadable=false)</td></tr>
<tr class="memdesc:a2e929156ae8fc613aa281361ee89da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies raw data from an OpenCV Mat to a Unity Texture2D.  <br /></td></tr>
<tr class="separator:a2e929156ae8fc613aa281361ee89da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935760e54e9204bd686ec90d3ce55183" id="r_a935760e54e9204bd686ec90d3ce55183"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a935760e54e9204bd686ec90d3ce55183">MatToTexture2DRaw</a> (<a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Texture2D texture2D, int mipLevel, bool flip=true, int flipCode=0, bool updateMipmaps=false, bool makeNoLongerReadable=false)</td></tr>
<tr class="memdesc:a935760e54e9204bd686ec90d3ce55183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies raw data from an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level.  <br /></td></tr>
<tr class="separator:a935760e54e9204bd686ec90d3ce55183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8adaa98e2ce8007e0fed5ae495194a8" id="r_ae8adaa98e2ce8007e0fed5ae495194a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8adaa98e2ce8007e0fed5ae495194a8">RenderTextureToMat</a> (RenderTexture renderTexture, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, GraphicsBuffer graphicsBuffer, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:ae8adaa98e2ce8007e0fed5ae495194a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unity RenderTexture to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:ae8adaa98e2ce8007e0fed5ae495194a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad012583b9b350ffa315c625a4c661f5b" id="r_ad012583b9b350ffa315c625a4c661f5b"><td class="memItemLeft" align="right" valign="top">static async Awaitable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad012583b9b350ffa315c625a4c661f5b">RenderTextureToMatAsync</a> (RenderTexture renderTexture, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, GraphicsBuffer graphicsBuffer, bool flip=true, int flipCode=0, CancellationToken cancellationToken=default)</td></tr>
<tr class="memdesc:ad012583b9b350ffa315c625a4c661f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unity RenderTexture to an OpenCV Mat asynchronously.  <br /></td></tr>
<tr class="separator:ad012583b9b350ffa315c625a4c661f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb2f0c63bfb30ee38400b4f505ff00d" id="r_a6eb2f0c63bfb30ee38400b4f505ff00d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb2f0c63bfb30ee38400b4f505ff00d">Texture2DToMat</a> (Texture2D texture2D, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:a6eb2f0c63bfb30ee38400b4f505ff00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unity Texture2D to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a6eb2f0c63bfb30ee38400b4f505ff00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a614253f721cef291fbe361be97fd8" id="r_ad8a614253f721cef291fbe361be97fd8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a614253f721cef291fbe361be97fd8">Texture2DToMat</a> (Texture2D texture2D, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, int mipLevel, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:ad8a614253f721cef291fbe361be97fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unity Texture2D to an OpenCV Mat, targeting the specified mipmap level.  <br /></td></tr>
<tr class="separator:ad8a614253f721cef291fbe361be97fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66469433d52b25d29c733f9b1290a601" id="r_a66469433d52b25d29c733f9b1290a601"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66469433d52b25d29c733f9b1290a601">Texture2DToMatRaw</a> (Texture2D texture2D, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:a66469433d52b25d29c733f9b1290a601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies raw data from a Unity Texture2D to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a66469433d52b25d29c733f9b1290a601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7377ae45dd455aad105c693837fc84a7" id="r_a7377ae45dd455aad105c693837fc84a7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7377ae45dd455aad105c693837fc84a7">Texture2DToMatRaw</a> (Texture2D texture2D, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, int mipLevel, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:a7377ae45dd455aad105c693837fc84a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies raw data from a Unity Texture2D to an OpenCV Mat, targeting the specified mipmap level.  <br /></td></tr>
<tr class="separator:a7377ae45dd455aad105c693837fc84a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed99175c2a0da8a2ad178e29aa07f60f" id="r_aed99175c2a0da8a2ad178e29aa07f60f"><td class="memItemLeft" align="right" valign="top">static async Awaitable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed99175c2a0da8a2ad178e29aa07f60f">TextureToMatAsync</a> (Texture texture, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, bool flip=true, int flipCode=0, int mipIndex=0, int x=0, int width=-1, int y=0, int height=-1, int z=0, int depth=1, GraphicsFormat? dstFormat=null, CancellationToken cancellationToken=default)</td></tr>
<tr class="memdesc:aed99175c2a0da8a2ad178e29aa07f60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Texture to an OpenCV Mat asynchronously.  <br /></td></tr>
<tr class="separator:aed99175c2a0da8a2ad178e29aa07f60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08388b46ef2dc435ce1af58399e6d67" id="r_ad08388b46ef2dc435ce1af58399e6d67"><td class="memItemLeft" align="right" valign="top">static async Awaitable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad08388b46ef2dc435ce1af58399e6d67">TextureToMatAsync</a> (Texture texture, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, CancellationToken cancellationToken=default)</td></tr>
<tr class="memdesc:ad08388b46ef2dc435ce1af58399e6d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Texture to an OpenCV Mat asynchronously.  <br /></td></tr>
<tr class="separator:ad08388b46ef2dc435ce1af58399e6d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fed56b72794391e3885dd4d40a7f34d" id="r_a1fed56b72794391e3885dd4d40a7f34d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fed56b72794391e3885dd4d40a7f34d">TextureToTexture2D</a> (Texture texture, Texture2D texture2D)</td></tr>
<tr class="memdesc:a1fed56b72794391e3885dd4d40a7f34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPENCV_DONT_USE_WEBCAMTEXTURE_API.  <br /></td></tr>
<tr class="separator:a1fed56b72794391e3885dd4d40a7f34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec4098aed348d209660111baa629607" id="r_a3ec4098aed348d209660111baa629607"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec4098aed348d209660111baa629607">WebCamTextureToMat</a> (WebCamTexture webCamTexture, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:a3ec4098aed348d209660111baa629607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unity WebCamTexture to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a3ec4098aed348d209660111baa629607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d91cb9bb110e0b12683c85822d83444" id="r_a8d91cb9bb110e0b12683c85822d83444"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d91cb9bb110e0b12683c85822d83444">WebCamTextureToMat</a> (WebCamTexture webCamTexture, <a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a> mat, Color32[] pixels32Buffer, bool flip=true, int flipCode=0)</td></tr>
<tr class="memdesc:a8d91cb9bb110e0b12683c85822d83444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Unity WebCamTexture to an OpenCV Mat.  <br /></td></tr>
<tr class="separator:a8d91cb9bb110e0b12683c85822d83444"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>OpenCV Mat utilities. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aefc2e0199e4ccc24e3620c5fda8fd7a3" name="aefc2e0199e4ccc24e3620c5fda8fd7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">&#9670;&#160;</a></span>CopyMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration to specify the data copy method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aefc2e0199e4ccc24e3620c5fda8fd7a3aba158bef870b6f8785634376161d0142" name="aefc2e0199e4ccc24e3620c5fda8fd7a3aba158bef870b6f8785634376161d0142"></a>PerPixel&#160;</td><td class="fielddoc"><p>Copies data on a per-pixel basis. If the input is 4 bytes per pixel and the output is 8 bytes per pixel, 4 bytes from the input are copied, and the remaining 4 bytes are filled with zeros. If the input is 8 bytes per pixel and the output is 4 bytes per pixel, only the first 4 bytes from the input are copied. </p>
</td></tr>
<tr><td class="fieldname"><a id="aefc2e0199e4ccc24e3620c5fda8fd7a3a55dc0f639728ab8ecd2398ba5b934b08" name="aefc2e0199e4ccc24e3620c5fda8fd7a3a55dc0f639728ab8ecd2398ba5b934b08"></a>Contiguous&#160;</td><td class="fielddoc"><p>Copies data as a contiguous block of memory. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a48710cdfcfa7583baae088328e539db6" name="a48710cdfcfa7583baae088328e539db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48710cdfcfa7583baae088328e539db6">&#9670;&#160;</a></span>CopyFromMat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>intPtr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to an IntPtr. </p>
<p>This method transfers the data stored in an OpenCV Mat object into an IntPtr. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>The entire range of data managed by the Mat will be copied to the IntPtr. If you want to specify the exact range of data to copy, please use the method that accepts a <em>length</em>  argument.</p>
<p><b>Note:</b> This method operates on unmanaged memory, and incorrect usage can lead to unpredictable behavior, crashes, or data corruption. Ensure that the source pointer points to a valid memory region and that the specified length does not exceed the allocated memory size for that region. Additionally, as this method involves unmanaged memory, be cautious about potential security risks. Accessing memory beyond the intended range can lead to buffer overflows and may compromise application stability and security. It is highly recommended to perform validation checks on the pointer and the specified length.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">intPtr</td><td>The destination IntPtr where the data will be copied. This pointer must reference a valid memory region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the IntPtr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>intPtr == IntPtr.Zero</code>. Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addf35a4a4190abc58dd6d11e62898f12" name="addf35a4a4190abc58dd6d11e62898f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf35a4a4190abc58dd6d11e62898f12">&#9670;&#160;</a></span>CopyFromMat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>intPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to an IntPtr. </p>
<p>This method transfers the data stored in an OpenCV Mat object into an IntPtr. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size of the memory region pointed to by the IntPtr is smaller than the data size managed by the Mat, data will be copied up to the size of the IntPtr. If the data size of the memory region pointed to by the IntPtr is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method operates on unmanaged memory, and incorrect usage can lead to unpredictable behavior, crashes, or data corruption. Ensure that the source pointer points to a valid memory region and that the specified length does not exceed the allocated memory size for that region. Additionally, as this method involves unmanaged memory, be cautious about potential security risks. Accessing memory beyond the intended range can lead to buffer overflows and may compromise application stability and security. It is highly recommended to perform validation checks on the pointer and the specified length.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">intPtr</td><td>The destination IntPtr where the data will be copied. This pointer must reference a valid memory region. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements, in terms of byte size, to copy from the source Mat to the destination IntPtr. The <em>length</em>  represents the size in bytes, regardless of the actual type of data in the Mat or the destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the IntPtr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>intPtr == IntPtr.Zero</code>. Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a387d3b8b521c221da80ea389b0fe2826" name="a387d3b8b521c221da80ea389b0fe2826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387d3b8b521c221da80ea389b0fe2826">&#9670;&#160;</a></span>CopyFromMat&lt; T &gt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#a48710cdfcfa7583baae088328e539db6">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>intPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to an IntPtr. </p>
<p>This method transfers the data stored in an OpenCV Mat object into an IntPtr. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size of the memory region pointed to by the IntPtr is smaller than the data size managed by the Mat, data will be copied up to the size of the IntPtr. If the data size of the memory region pointed to by the IntPtr is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method operates on unmanaged memory, and incorrect usage can lead to unpredictable behavior, crashes, or data corruption. Ensure that the source pointer points to a valid memory region and that the specified length does not exceed the allocated memory size for that region. Additionally, as this method involves unmanaged memory, be cautious about potential security risks. Accessing memory beyond the intended range can lead to buffer overflows and may compromise application stability and security. It is highly recommended to perform validation checks on the pointer and the specified length.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements represented by the IntPtr. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">intPtr</td><td>The destination IntPtr where the data will be copied. This pointer must reference a valid memory region. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source Mat to the destination IntPtr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the IntPtr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>intPtr == IntPtr.Zero</code>. Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa603b1b057b463daa78e921ac8395cc6" name="aa603b1b057b463daa78e921ac8395cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa603b1b057b463daa78e921ac8395cc6">&#9670;&#160;</a></span>CopyFromMat&lt; T &gt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#a48710cdfcfa7583baae088328e539db6">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NativeArray&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to a NativeArray. </p>
<p>This method transfers the data stored in an OpenCV Mat object into a NativeArray. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the array is smaller than the data size managed by the Mat, data will be copied up to the size of the array. If the data size managed by the array is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the NativeArray. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">array</td><td>The destination NativeArray where the data will be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the NativeArray. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>array</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a259cb8e685ecba76f4086ea01140d526" name="a259cb8e685ecba76f4086ea01140d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb8e685ecba76f4086ea01140d526">&#9670;&#160;</a></span>CopyFromMat&lt; T &gt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#a48710cdfcfa7583baae088328e539db6">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NativeArray&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to a NativeArray. </p>
<p>This method transfers the data stored in an OpenCV Mat object into a NativeArray. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the array is smaller than the data size managed by the Mat, data will be copied up to the size of the array. If the data size managed by the array is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the NativeArray. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">array</td><td>The destination NativeArray where the data will be copied. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source Mat to the destination managed array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the NativeArray. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>array</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5f52ffc0d45a80d64ff20b5e2a75e741" name="a5f52ffc0d45a80d64ff20b5e2a75e741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f52ffc0d45a80d64ff20b5e2a75e741">&#9670;&#160;</a></span>CopyFromMat&lt; T &gt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#a48710cdfcfa7583baae088328e539db6">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to a Span. </p>
<p>This method transfers the data stored in an OpenCV Mat object into a Span. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the array is smaller than the data size managed by the Mat, data will be copied up to the size of the array. If the data size managed by the array is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">array</td><td>The destination Span where the data will be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the Span. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>array</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae1065e553a4ca29818f86ddcd68327bd" name="ae1065e553a4ca29818f86ddcd68327bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1065e553a4ca29818f86ddcd68327bd">&#9670;&#160;</a></span>CopyFromMat&lt; T &gt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#a48710cdfcfa7583baae088328e539db6">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Span&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to a Span. </p>
<p>This method transfers the data stored in an OpenCV Mat object into a Span. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the array is smaller than the data size managed by the Mat, data will be copied up to the size of the array. If the data size managed by the array is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">array</td><td>The destination Span where the data will be copied. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source Mat to the destination Span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the Span. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>array</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a716534e77e63e409b4a37f1a061d0c8d" name="a716534e77e63e409b4a37f1a061d0c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716534e77e63e409b4a37f1a061d0c8d">&#9670;&#160;</a></span>CopyFromMat&lt; T &gt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#a48710cdfcfa7583baae088328e539db6">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to a managed array. </p>
<p>This method transfers the data stored in an OpenCV Mat object into a managed array. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the array is smaller than the data size managed by the Mat, data will be copied up to the size of the array. If the data size managed by the array is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the managed array. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">array</td><td>The destination managed array where the data will be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the managed array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>array</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a2b1628974b1b1dc7108f6214f5aba668" name="a2b1628974b1b1dc7108f6214f5aba668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1628974b1b1dc7108f6214f5aba668">&#9670;&#160;</a></span>CopyFromMat&lt; T &gt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#a48710cdfcfa7583baae088328e539db6">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyFromMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an OpenCV Mat to a managed array. </p>
<p>This method transfers the data stored in an OpenCV Mat object into a managed array. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the array is smaller than the data size managed by the Mat, data will be copied up to the size of the array. If the data size managed by the array is larger, data will be copied up to the size managed by the Mat.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the Mat and the array. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#acf4ab7b8b3837945ec745b9cd716c4f4" title="Reads a byte array from the matrix at the specified row and column.">Mat.get</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the managed array. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat from which data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">array</td><td>The destination managed array where the data will be copied. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source Mat to the destination managed array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Mat to the managed array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>array</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae66a7ef84edf817701370ca3984e18d3" name="ae66a7ef84edf817701370ca3984e18d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66a7ef84edf817701370ca3984e18d3">&#9670;&#160;</a></span>CopyToMat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat </td>
          <td>(</td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>intPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an IntPtr to an OpenCV Mat. </p>
<p>This method transfers the data stored in an IntPtr to an OpenCV Mat. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>Data of the same size in bytes as the data managed by the Mat is copied from the IntPtr to the Mat. If you want to specify the exact range of data to copy, please use the method that accepts a <em>length</em>  argument.</p>
<p><b>Note:</b> This method operates on unmanaged memory, and incorrect usage can lead to unpredictable behavior, crashes, or data corruption. Ensure that the source pointer points to a valid memory region and that the specified length does not exceed the allocated memory size for that region. Additionally, as this method involves unmanaged memory, be cautious about potential security risks. Accessing memory beyond the intended range can lead to buffer overflows and may compromise application stability and security. It is highly recommended to perform validation checks on the pointer and the specified length.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intPtr</td><td>The source IntPtr from which data will be copied. This pointer must reference a valid memory region. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the IntPtr to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>intPtr == IntPtr.Zero</code>. Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a981002a5a0a4e11efbdf17179769aa34" name="a981002a5a0a4e11efbdf17179769aa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981002a5a0a4e11efbdf17179769aa34">&#9670;&#160;</a></span>CopyToMat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat </td>
          <td>(</td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>intPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an IntPtr to an OpenCV Mat. </p>
<p>This method transfers the data stored in an IntPtr to an OpenCV Mat. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size of the memory region pointed to by the IntPtr, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size of the memory region pointed to by the IntPtr.</p>
<p><b>Note:</b> This method operates on unmanaged memory, and incorrect usage can lead to unpredictable behavior, crashes, or data corruption. Ensure that the source pointer points to a valid memory region and that the specified length does not exceed the allocated memory size for that region. Additionally, as this method involves unmanaged memory, be cautious about potential security risks. Accessing memory beyond the intended range can lead to buffer overflows and may compromise application stability and security. It is highly recommended to perform validation checks on the pointer and the specified length.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intPtr</td><td>The source IntPtr from which data will be copied. This pointer must reference a valid memory region. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements, in terms of byte size, to copy from the source IntPtr to the destination Mat. The <em>length</em>  represents the size in bytes, regardless of the actual type of data in the IntPtr or the destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the IntPtr to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>intPtr == IntPtr.Zero</code>. Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c077b1fda6277044245de397f0c2ec7" name="a2c077b1fda6277044245de397f0c2ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c077b1fda6277044245de397f0c2ec7">&#9670;&#160;</a></span>CopyToMat&lt; T &gt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr</td>          <td class="paramname"><span class="paramname"><em>intPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from an IntPtr to an OpenCV Mat. </p>
<p>This method transfers the data stored in an IntPtr to an OpenCV Mat. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data from Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size of the memory region pointed to by the IntPtr, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size of the memory region pointed to by the IntPtr.</p>
<p><b>Note:</b> This method operates on unmanaged memory, and incorrect usage can lead to unpredictable behavior, crashes, or data corruption. Ensure that the source pointer points to a valid memory region and that the specified length does not exceed the allocated memory size for that region. Additionally, as this method involves unmanaged memory, be cautious about potential security risks. Accessing memory beyond the intended range can lead to buffer overflows and may compromise application stability and security. It is highly recommended to perform validation checks on the pointer and the specified length.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements represented by the IntPtr. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intPtr</td><td>The source IntPtr from which data will be copied. This pointer must reference a valid memory region. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source IntPtr to the destination Mat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the IntPtr to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>intPtr == IntPtr.Zero</code>. Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aba2d9f8bc254748d3abe6b38e2d128dc" name="aba2d9f8bc254748d3abe6b38e2d128dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2d9f8bc254748d3abe6b38e2d128dc">&#9670;&#160;</a></span>CopyToMat&lt; T &gt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">NativeArray&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from a NativeArray to an OpenCV Mat. </p>
<p>This method transfers the data stored in a NativeArray into an OpenCV Mat object. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data where Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size managed by the array, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size managed by the array.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the NativeArray. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The source NativeArray from which data will be copied. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the NativeArray to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>array</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a4281042835abb42aab2dafeea6e17d69" name="a4281042835abb42aab2dafeea6e17d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4281042835abb42aab2dafeea6e17d69">&#9670;&#160;</a></span>CopyToMat&lt; T &gt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">NativeArray&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from a NativeArray to an OpenCV Mat. </p>
<p>This method transfers the data stored in a NativeArray into an OpenCV Mat object. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data where Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size managed by the array, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size managed by the array.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the NativeArray. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The source NativeArray from which data will be copied. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source NativeArray to the destination Mat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the NativeArray to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>array</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a4182f588d2022ba906d0fbecb7a9cc3d" name="a4182f588d2022ba906d0fbecb7a9cc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4182f588d2022ba906d0fbecb7a9cc3d">&#9670;&#160;</a></span>CopyToMat&lt; T &gt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">ReadOnlySpan&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from a Span to an OpenCV Mat. </p>
<p>This method transfers the data stored in a Span into an OpenCV Mat object. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data where Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size managed by the array, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size managed by the array.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The source Span from which data will be copied. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Span to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>array</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a63785d44205e4ac57812418acac0ae79" name="a63785d44205e4ac57812418acac0ae79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63785d44205e4ac57812418acac0ae79">&#9670;&#160;</a></span>CopyToMat&lt; T &gt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">ReadOnlySpan&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from a Span to an OpenCV Mat. </p>
<p>This method transfers the data stored in a Span into an OpenCV Mat object. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data where Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size managed by the array, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size managed by the array.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the Span. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The source Span from which data will be copied. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source Span to the destination Mat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the Span to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>array</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac45e952ddf60560bd564b17ce9131eca" name="ac45e952ddf60560bd564b17ce9131eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45e952ddf60560bd564b17ce9131eca">&#9670;&#160;</a></span>CopyToMat&lt; T &gt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from a managed array to an OpenCV Mat. </p>
<p>This method transfers the data stored in a managed array into an OpenCV Mat object. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data where Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size managed by the array, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size managed by the array.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the managed array. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The source managed array from which data will be copied. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the managed array to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>array</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="acc346be92a80015ec4dbc89d8f9ea874" name="acc346be92a80015ec4dbc89d8f9ea874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc346be92a80015ec4dbc89d8f9ea874">&#9670;&#160;</a></span>CopyToMat&lt; T &gt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="#ae66a7ef84edf817701370ca3984e18d3">OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CopyToMat</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">T[]</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data from a managed array to an OpenCV Mat. </p>
<p>This method transfers the data stored in a managed array into an OpenCV Mat object. It supports both continuous and non-continuous Mat objects:</p><ul>
<li>If <code>mat.isContinuous()</code> is <code>false</code> and <code>mat.dims()</code> exceeds 2, the method will throw an exception, as non-continuous Mats with more than 2 dimensions are unsupported.</li>
<li>If <code>mat.isContinuous()</code> is <code>true</code>, the method can copy data where Mats with any number of dimensions.</li>
</ul>
<p>If the data size managed by the Mat is smaller than the data size managed by the array, data will be copied up to the size of the mat. If the data size managed by the Mat is larger, data will be copied up to the size managed by the array.</p>
<p><b>Note:</b> This method is specialized for copying a continuous range of data regardless of differences in types between the array and the Mat. Although its functionality is more limited compared to the <code><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html#a8a33d0eae5471f567303c0905ef1e75c" title="Writes a double array to the matrix at the given row and column, casting them to match the matrix&#39;s d...">Mat.put</a></code> method, it offers improved performance for such operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the managed array. This must be an unmanaged type (i.e., a type without references to managed objects) to allow for direct memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The source managed array from which data will be copied. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat where the data will be copied. The Mat must not be disposed of or null. </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements of type <em>T</em>  to copy from the source managed array to the destination Mat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied from the managed array to the Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>array</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown when <code>!mat.isContinuous() &amp;&amp; mat.dims() &gt; 2</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abe82bd698498d5dcd0a31866d70a43f0" name="abe82bd698498d5dcd0a31866d70a43f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe82bd698498d5dcd0a31866d70a43f0">&#9670;&#160;</a></span>CreateMatToRenderTextureComputeShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ComputeShader OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CreateMatToRenderTextureComputeShader </td>
          <td>(</td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a ComputeShader for converting from Mat to RenderTexture based on the current platform and graphics API. This ComputeShader is intended to be used with the kernel index obtained from the GetKernelIndexForMatToRenderTextureComputeShader method when dispatching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsBuffer</td><td>The source GraphicsBuffer.</td></tr>
    <tr><td class="paramname">renderTexture</td><td>The destination RenderTexture.</td></tr>
    <tr><td class="paramname">flip</td><td>Whether to flip the image vertically.</td></tr>
    <tr><td class="paramname">flipCode</td><td>The flipCode for the <a class="el" href="../../da/d74/classOpenCVForUnity_1_1CoreModule_1_1Core.html#a06719211e27bdb5c67c454ea28b16f8b" title="Flips a 2D array around vertical, horizontal, or both axes.">Core.flip()</a> method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ComputeShader.</dd></dl>

</div>
</div>
<a id="aa00793809e2b1fa5eb5be130dfbc80e6" name="aa00793809e2b1fa5eb5be130dfbc80e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00793809e2b1fa5eb5be130dfbc80e6">&#9670;&#160;</a></span>CreateRenderTextureToMatComputeShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ComputeShader OpenCVForUnity.UnityIntegration.OpenCVMatUtils.CreateRenderTextureToMatComputeShader </td>
          <td>(</td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a ComputeShader for converting from RenderTexture to Mat based on the current platform and graphics API. This ComputeShader is intended to be used with the kernel index obtained from the GetKernelIndexForRenderTextureToMatComputeShader method when dispatching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>The source RenderTexture.</td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>The destination GraphicsBuffer.</td></tr>
    <tr><td class="paramname">flip</td><td>Whether to flip the image vertically.</td></tr>
    <tr><td class="paramname">flipCode</td><td>The flipCode for the <a class="el" href="../../da/d74/classOpenCVForUnity_1_1CoreModule_1_1Core.html#a06719211e27bdb5c67c454ea28b16f8b" title="Flips a 2D array around vertical, horizontal, or both axes.">Core.flip()</a> method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ComputeShader.</dd></dl>

</div>
</div>
<a id="aa779fd4edad91cffb4a6ce4260276813" name="aa779fd4edad91cffb4a6ce4260276813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa779fd4edad91cffb4a6ce4260276813">&#9670;&#160;</a></span>GetKernelIndexForMatToRenderTextureComputeShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.GetKernelIndexForMatToRenderTextureComputeShader </td>
          <td>(</td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the kernel index to use for converting from Mat to RenderTexture based on the current platform and graphics API. This kernel index is intended to be used when dispatching the ComputeShader obtained from the CreateMatToRenderTextureComputeShader method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsBuffer</td><td>The source GraphicsBuffer.</td></tr>
    <tr><td class="paramname">renderTexture</td><td>The destination RenderTexture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The kernel index to use for the conversion.</dd></dl>

</div>
</div>
<a id="a5979c9923c37df6bdea890f36046cc79" name="a5979c9923c37df6bdea890f36046cc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5979c9923c37df6bdea890f36046cc79">&#9670;&#160;</a></span>GetKernelIndexForRenderTextureToMatComputeShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.GetKernelIndexForRenderTextureToMatComputeShader </td>
          <td>(</td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the kernel index to use for converting from RenderTexture to Mat based on the current platform and graphics API. This kernel index is intended to be used when dispatching the ComputeShader obtained from the CreateRenderTextureToMatComputeShader method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>The source RenderTexture.</td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>The destination GraphicsBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The kernel index to use for the conversion.</dd></dl>

</div>
</div>
<a id="ac1e0390d15b08d4847d81e2ce8454737" name="ac1e0390d15b08d4847d81e2ce8454737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e0390d15b08d4847d81e2ce8454737">&#9670;&#160;</a></span>GraphicsBufferToMat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.GraphicsBufferToMat </td>
          <td>(</td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a></td>          <td class="paramname"><span class="paramname"><em>copyMode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a Unity GraphicsBuffer to a OpenCV Mat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsBuffer</td><td>The source Unity GraphicsBuffer.</td></tr>
    <tr><td class="paramname">mat</td><td>The destination OpenCV Mat.</td></tr>
    <tr><td class="paramname">copyMode</td><td>The CopyMode enumeration specifying the method of copying data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if mat or graphicsBuffer is null.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if data size or stride does not match.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18eef9dc97416fe755aba47227a979d3" name="a18eef9dc97416fe755aba47227a979d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eef9dc97416fe755aba47227a979d3">&#9670;&#160;</a></span>GraphicsBufferToMatAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static async Awaitable OpenCVForUnity.UnityIntegration.OpenCVMatUtils.GraphicsBufferToMatAsync </td>
          <td>(</td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a></td>          <td class="paramname"><span class="paramname"><em>copyMode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CancellationToken</td>          <td class="paramname"><span class="paramname"><em>cancellationToken</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a Unity GraphicsBuffer to an OpenCV Mat asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsBuffer</td><td>The source Unity GraphicsBuffer.</td></tr>
    <tr><td class="paramname">mat</td><td>The destination OpenCV Mat.</td></tr>
    <tr><td class="paramname">copyMode</td><td>The CopyMode enumeration specifying the method of copying data.</td></tr>
    <tr><td class="paramname">cancellationToken</td><td>A token to monitor for cancellation requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if <em>mat</em>  or <em>graphicsBuffer</em>  is null.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if data size or stride does not match.</td></tr>
    <tr><td class="paramname">NotSupportedException</td><td>Thrown if compute shaders are not supported on the current platform.</td></tr>
    <tr><td class="paramname">OperationCanceledException</td><td>Thrown if the operation is canceled via <em>cancellationToken</em> .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3b773b392f3c1d94a9b362670a159aa" name="ad3b773b392f3c1d94a9b362670a159aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b773b392f3c1d94a9b362670a159aa">&#9670;&#160;</a></span>MatToGraphicsBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToGraphicsBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a></td>          <td class="paramname"><span class="paramname"><em>copyMode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a OpenCv Mat to a Unity GraphicsBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source OpenCV Mat.</td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>The destination Unity GraphicsBuffer.</td></tr>
    <tr><td class="paramname">copyMode</td><td>The CopyMode enumeration specifying the method of copying data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if mat or graphicsBuffer is null.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if data size or stride does not match.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe1a00a2b3b960bf4412a8024007fe1c" name="afe1a00a2b3b960bf4412a8024007fe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1a00a2b3b960bf4412a8024007fe1c">&#9670;&#160;</a></span>MatToGraphicsBufferAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static async Awaitable&lt; AsyncGPUReadbackRequest &gt; OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToGraphicsBufferAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aefc2e0199e4ccc24e3620c5fda8fd7a3">CopyMode</a></td>          <td class="paramname"><span class="paramname"><em>copyMode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CancellationToken</td>          <td class="paramname"><span class="paramname"><em>cancellationToken</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a OpenCv Mat to a Unity GraphicsBuffer asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source OpenCV Mat.</td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>The destination Unity GraphicsBuffer.</td></tr>
    <tr><td class="paramname">copyMode</td><td>The CopyMode enumeration specifying the method of copying data.</td></tr>
    <tr><td class="paramname">cancellationToken</td><td>Cancellation token to cancel the asynchronous operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if mat or graphicsBuffer is null.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if data size or stride does not match.</td></tr>
    <tr><td class="paramname">OperationCanceledException</td><td>Thrown when the operation is canceled via the <em>cancellationToken</em> .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa09d08f11c04079bc54fcf3896a45362" name="aa09d08f11c04079bc54fcf3896a45362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09d08f11c04079bc54fcf3896a45362">&#9670;&#160;</a></span>MatToRenderTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToRenderTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an OpenCV Mat to a Unity RenderTexture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source OpenCV Mat. The depth must be 'CV_8U'. The Mat object must not have more than 4 channels.</td></tr>
    <tr><td class="paramname">renderTexture</td><td>The destination Unity RenderTexture. Must have <code>enableRandomWrite</code> set to true. </td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>A temporary GraphicsBuffer. If null, a new one will be created. The stride of the graphics buffer must be exactly 4 bytes.</td></tr>
    <tr><td class="paramname">flip</td><td>Whether to flip the image vertically.</td></tr>
    <tr><td class="paramname">flipCode</td><td>The flipCode for the <a class="el" href="../../da/d74/classOpenCVForUnity_1_1CoreModule_1_1Core.html#a06719211e27bdb5c67c454ea28b16f8b" title="Flips a 2D array around vertical, horizontal, or both axes.">Core.flip()</a> method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if <em>renderTexture</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if <em>renderTexture</em>  has <code>enableRandomWrite</code> set to false, or if the size or format of the RenderTexture is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fa6ce959e625f31a9ab8e70b22e9741" name="a4fa6ce959e625f31a9ab8e70b22e9741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa6ce959e625f31a9ab8e70b22e9741">&#9670;&#160;</a></span>MatToRenderTextureAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static async Awaitable&lt; AsyncGPUReadbackRequest &gt; OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToRenderTextureAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CancellationToken</td>          <td class="paramname"><span class="paramname"><em>cancellationToken</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an OpenCV Mat to a Unity RenderTexture asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source OpenCV Mat. The depth must be 'CV_8U'. The Mat object must not have more than 4 channels.</td></tr>
    <tr><td class="paramname">renderTexture</td><td>The destination Unity RenderTexture. Must have <code>enableRandomWrite</code> set to true. </td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>A temporary GraphicsBuffer. If null, a new one will be created. The stride of the graphics buffer must be exactly 4 bytes.</td></tr>
    <tr><td class="paramname">flip</td><td>Whether to flip the image vertically.</td></tr>
    <tr><td class="paramname">flipCode</td><td>The flipCode for the <a class="el" href="../../da/d74/classOpenCVForUnity_1_1CoreModule_1_1Core.html#a06719211e27bdb5c67c454ea28b16f8b" title="Flips a 2D array around vertical, horizontal, or both axes.">Core.flip()</a> method.</td></tr>
    <tr><td class="paramname">cancellationToken</td><td>A token to monitor for cancellation requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if <em>renderTexture</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if <em>renderTexture</em>  has <code>enableRandomWrite</code> set to false, or if the size or format of the RenderTexture is invalid. </td></tr>
    <tr><td class="paramname">OperationCanceledException</td><td>Thrown if the operation is canceled via <em>cancellationToken</em> .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a472598bfc9d411f7200386e515609263" name="a472598bfc9d411f7200386e515609263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472598bfc9d411f7200386e515609263">&#9670;&#160;</a></span>MatToTexture2D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToTexture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateMipmaps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>makeNoLongerReadable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an OpenCV Mat to a Unity Texture2D. </p>
<p>This method converts an OpenCV Mat to a Unity Texture2D. Conversion is possible even when the number of bytes per pixel differs, such as from Mat(8UC1) to Texture2D(RGBA32). In the case of multi-channel color to 1-channel, it is converted to grayscale. Performance is optimal when the per-pixel data size and color order match, such as with Mat(8UC4) and Texture2D(RGBA32). If the texture format is not RGBA32, BGRA32, RGB24, Alpha8, or R8, the <a href="https://docs.unity3d.com/ScriptReference/Texture2D.SetPixels32.html">Texture2D.SetPixels32</a> and <a href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels32.html">Texture2D.GetPixels32</a> methods are used. In such cases, it is recommended to use the <em>pixels32Buffer</em>  argument to avoid repeated memory allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). For other CvTypes or color orders, use <a class="el" href="#a2e929156ae8fc613aa281361ee89da8e">MatToTexture2DRaw</a>. </td></tr>
    <tr><td class="paramname">texture2D</td><td>The destination Texture2D must have the same size as the source Mat. The destination Texture2D supports the following formats. (<a href="https://docs.unity3d.com/ScriptReference/Texture2D.SetPixels32.html">Texture2D.SetPixels32</a>) </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the Mat is flipped before conversion. The default is <code>true</code>, as the Mat must be flipped to align with the coordinate system of the destination Texture2D image. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Mat: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
    <tr><td class="paramname">updateMipmaps</td><td>If <code>true</code>, mipmaps are recalculated after conversion. The default is <code>false</code>. </td></tr>
    <tr><td class="paramname">makeNoLongerReadable</td><td>If <code>true</code>, system memory copy of a texture is released. The default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>texture2D</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa87f624be9208c8b2b9b8b54e82b1935" name="aa87f624be9208c8b2b9b8b54e82b1935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87f624be9208c8b2b9b8b54e82b1935">&#9670;&#160;</a></span>MatToTexture2D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToTexture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color32[]</td>          <td class="paramname"><span class="paramname"><em>pixels32Buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]</td>          <td class="paramname"><span class="paramname"><em>rawTextureDataBuffer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateMipmaps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>makeNoLongerReadable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an OpenCV Mat to a Unity Texture2D. </p>
<p>This method converts an OpenCV Mat to a Unity Texture2D. Conversion is possible even when the number of bytes per pixel differs, such as from Mat(8UC1) to Texture2D(RGBA32). In the case of multi-channel color to 1-channel, it is converted to grayscale. Performance is optimal when the per-pixel data size and color order match, such as with Mat(8UC4) and Texture2D(RGBA32). If the texture format is not RGBA32, BGRA32, RGB24, Alpha8, or R8, the <a href="https://docs.unity3d.com/ScriptReference/Texture2D.SetPixels32.html">Texture2D.SetPixels32</a> and <a href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels32.html">Texture2D.GetPixels32</a> methods are used. In such cases, it is recommended to use the <em>pixels32Buffer</em>  argument to avoid repeated memory allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). For other CvTypes or color orders, use <a class="el" href="#a2e929156ae8fc613aa281361ee89da8e">MatToTexture2DRaw</a>. </td></tr>
    <tr><td class="paramname">texture2D</td><td>The destination Texture2D must have the same size as the source Mat. The destination Texture2D supports the following formats. (<a href="https://docs.unity3d.com/ScriptReference/Texture2D.SetPixels32.html">Texture2D.SetPixels32</a>) </td></tr>
    <tr><td class="paramname">pixels32Buffer</td><td>An optional array for receiving pixel data as Color32. Using this array helps avoid memory allocation each frame. Ensure the array is initialized to a length matching the textures width * height. (<a href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels32.html">Texture2D.GetPixels32</a>) </td></tr>
    <tr><td class="paramname">rawTextureDataBuffer</td><td>An optional array for receiving raw texture data. This only works when the "OPENCV_DONT_USE_UNSAFE_CODE" symbol is defined and <em>texture2D</em>  has no mipmaps (mipmapCount == 1). Passing a byte array can help avoid memory allocation each frame. Ensure the array length matches the texture's raw data size. (<a href="https://docs.unity3d.com/ScriptReference/Texture2D.GetRawTextureData.html">Texture2D.GetRawTextureData</a>) The default value is <code>null</code>. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the Mat is flipped before conversion. The default is <code>true</code>, as the Mat must be flipped to align with the coordinate system of the destination Texture2D image. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Mat: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
    <tr><td class="paramname">updateMipmaps</td><td>If <code>true</code>, mipmaps are recalculated after conversion. The default is <code>false</code>. </td></tr>
    <tr><td class="paramname">makeNoLongerReadable</td><td>If <code>true</code>, system memory copy of a texture is released. The default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>texture2D</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7f80f4db8449c30239187434305f6a2" name="ad7f80f4db8449c30239187434305f6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f80f4db8449c30239187434305f6a2">&#9670;&#160;</a></span>MatToTexture2D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToTexture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mipLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateMipmaps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>makeNoLongerReadable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level. </p>
<p>This method converts an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level. Conversion is possible even when the number of bytes per pixel differs, such as from Mat(8UC1) to Texture2D(RGBA32). In the case of multi-channel color to 1-channel, it is converted to grayscale. It is recommended to use the <em>pixels32Buffer</em>  argument to avoid repeated memory allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). For other CvTypes or color orders, use <a class="el" href="#a2e929156ae8fc613aa281361ee89da8e">MatToTexture2DRaw</a>. The source Mat must be the same size as the mipmap of the destination Texture2D. </td></tr>
    <tr><td class="paramname">texture2D</td><td>The destination Texture2D most be supports mipmaps, as the conversion will target the<em>mipLevel</em> . The destination Texture2D supports the following formats. (<a href="https://docs.unity3d.com/ScriptReference/Texture2D.SetPixels32.html">Texture2D.SetPixels32</a>) </td></tr>
    <tr><td class="paramname">mipLevel</td><td>The mipmap level to which the Mat will be converted. The level must be within the range supported by the destination Texture2D. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the Mat is flipped before conversion. The default is <code>true</code>, as the Mat must be flipped to align with the coordinate system of the destination Texture2D image. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Mat: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
    <tr><td class="paramname">updateMipmaps</td><td>If <code>true</code>, mipmaps are recalculated after conversion. The default is <code>false</code>. </td></tr>
    <tr><td class="paramname">makeNoLongerReadable</td><td>If <code>true</code>, system memory copy of a texture is released. The default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>texture2D</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34a098f47f928d44daff0d6d270c3e2c" name="a34a098f47f928d44daff0d6d270c3e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a098f47f928d44daff0d6d270c3e2c">&#9670;&#160;</a></span>MatToTexture2D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToTexture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mipLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color32[]</td>          <td class="paramname"><span class="paramname"><em>pixels32Buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateMipmaps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>makeNoLongerReadable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level. </p>
<p>This method converts an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level. Conversion is possible even when the number of bytes per pixel differs, such as from Mat(8UC1) to Texture2D(RGBA32). In the case of multi-channel color to 1-channel, it is converted to grayscale. It is recommended to use the <em>pixels32Buffer</em>  argument to avoid repeated memory allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). For other CvTypes or color orders, use <a class="el" href="#a2e929156ae8fc613aa281361ee89da8e">MatToTexture2DRaw</a>. The source Mat must be the same size as the mipmap of the destination Texture2D. </td></tr>
    <tr><td class="paramname">texture2D</td><td>The destination Texture2D most be supports mipmaps, as the conversion will target the<em>mipLevel</em> . The destination Texture2D supports the following formats. (<a href="https://docs.unity3d.com/ScriptReference/Texture2D.SetPixels32.html">Texture2D.SetPixels32</a>) </td></tr>
    <tr><td class="paramname">mipLevel</td><td>The mipmap level to which the Mat will be converted. The level must be within the range supported by the destination Texture2D. </td></tr>
    <tr><td class="paramname">pixels32Buffer</td><td>An optional array for receiving pixel data as Color32. Using this array helps avoid memory allocation each frame. Ensure the array is initialized to a length matching the textures mipmap width * height. (<a href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels32.html">Texture2D.GetPixels32</a>) </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the Mat is flipped before conversion. The default is <code>true</code>, as the Mat must be flipped to align with the coordinate system of the destination Texture2D image. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Mat: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
    <tr><td class="paramname">updateMipmaps</td><td>If <code>true</code>, mipmaps are recalculated after conversion. The default is <code>false</code>. </td></tr>
    <tr><td class="paramname">makeNoLongerReadable</td><td>If <code>true</code>, system memory copy of a texture is released. The default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>texture2D</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e929156ae8fc613aa281361ee89da8e" name="a2e929156ae8fc613aa281361ee89da8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e929156ae8fc613aa281361ee89da8e">&#9670;&#160;</a></span>MatToTexture2DRaw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToTexture2DRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateMipmaps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>makeNoLongerReadable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies raw data from an OpenCV Mat to a Unity Texture2D. </p>
<p>This method copies raw data from an OpenCV Mat to a Unity Texture2D. There are no specific requirements for the size or type of the Mat and Texture2D; data is copied up to the maximum size that fits within the data size of the destination Texture2D, including mipmaps. A common use case for this method is writing a Mat with BGRA color order to a Texture2D in the BGRA32 format. If the "OPENCV_DONT_USE_UNSAFE_CODE" symbol is defined, the following operating conditions are added: mat.isContinuous() == true, and the data size of Texture2D is the same as or larger than the data size of Mat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat must be 2-dimensional. </td></tr>
    <tr><td class="paramname">texture2D</td><td>The destination Texture2D. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the Mat is flipped before copies. The default is <code>true</code>, as the Mat must be flipped to align with the coordinate system of the destination Texture2D image. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Mat: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
    <tr><td class="paramname">updateMipmaps</td><td>If <code>true</code>, mipmaps are recalculated after copies. The default is <code>false</code>. </td></tr>
    <tr><td class="paramname">makeNoLongerReadable</td><td>If <code>true</code>, system memory copy of a texture is released. The default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes actually written to the destination Texture2D. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>texture2D</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a935760e54e9204bd686ec90d3ce55183" name="a935760e54e9204bd686ec90d3ce55183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935760e54e9204bd686ec90d3ce55183">&#9670;&#160;</a></span>MatToTexture2DRaw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.MatToTexture2DRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mipLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateMipmaps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>makeNoLongerReadable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies raw data from an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level. </p>
<p>This method copies raw data from an OpenCV Mat to a Unity Texture2D, targeting the specified mipmap level. There are no specific requirements for the size or type of the Mat and Texture2D; data is copied up to the maximum size that fits within the data size of the mipmap of the destination Texture2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The source Mat must be 2-dimensional. </td></tr>
    <tr><td class="paramname">texture2D</td><td>The destination Texture2D. </td></tr>
    <tr><td class="paramname">mipLevel</td><td>The mipmap level to which the Mat will be converted. The level must be within the range supported by the destination Texture2D. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the Mat is flipped before copies. The default is <code>true</code>, as the Mat must be flipped to align with the coordinate system of the destination Texture2D image. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Mat: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
    <tr><td class="paramname">updateMipmaps</td><td>If <code>true</code>, mipmaps are recalculated after copies. The default is <code>false</code>. </td></tr>
    <tr><td class="paramname">makeNoLongerReadable</td><td>If <code>true</code>, system memory copy of a texture is released. The default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes actually written to the destination Texture2D. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>mat</em>  or <em>texture2D</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8adaa98e2ce8007e0fed5ae495194a8" name="ae8adaa98e2ce8007e0fed5ae495194a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8adaa98e2ce8007e0fed5ae495194a8">&#9670;&#160;</a></span>RenderTextureToMat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.RenderTextureToMat </td>
          <td>(</td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unity RenderTexture to an OpenCV Mat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>The source Unity RenderTexture. Must have <code>enableRandomWrite</code> set to true.</td></tr>
    <tr><td class="paramname">mat</td><td>The destination OpenCV Mat. The depth must be 'CV_8U'. The Mat object must not have more than 4 channels.</td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>A temporary GraphicsBuffer. If null, a new one will be created. The stride of the graphics buffer must be exactly 4 bytes.</td></tr>
    <tr><td class="paramname">flip</td><td>Whether to flip the image vertically.</td></tr>
    <tr><td class="paramname">flipCode</td><td>The flipCode for the <a class="el" href="../../da/d74/classOpenCVForUnity_1_1CoreModule_1_1Core.html#a06719211e27bdb5c67c454ea28b16f8b" title="Flips a 2D array around vertical, horizontal, or both axes.">Core.flip()</a> method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if <em>renderTexture</em>  or <em>mat</em>  is null.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if <em>renderTexture</em>  has <code>enableRandomWrite</code> set to false, or if the size or format of the RenderTexture is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad012583b9b350ffa315c625a4c661f5b" name="ad012583b9b350ffa315c625a4c661f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad012583b9b350ffa315c625a4c661f5b">&#9670;&#160;</a></span>RenderTextureToMatAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static async Awaitable OpenCVForUnity.UnityIntegration.OpenCVMatUtils.RenderTextureToMatAsync </td>
          <td>(</td>
          <td class="paramtype">RenderTexture</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsBuffer</td>          <td class="paramname"><span class="paramname"><em>graphicsBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CancellationToken</td>          <td class="paramname"><span class="paramname"><em>cancellationToken</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unity RenderTexture to an OpenCV Mat asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>The source Unity RenderTexture. Must have <code>enableRandomWrite</code> set to true.</td></tr>
    <tr><td class="paramname">mat</td><td>The destination OpenCV Mat. The depth must be 'CV_8U'. The Mat object must not have more than 4 channels.</td></tr>
    <tr><td class="paramname">graphicsBuffer</td><td>A temporary GraphicsBuffer. If null, a new one will be created. The stride of the graphics buffer must be exactly 4 bytes.</td></tr>
    <tr><td class="paramname">flip</td><td>Whether to flip the image vertically.</td></tr>
    <tr><td class="paramname">flipCode</td><td>The flipCode for the <a class="el" href="../../da/d74/classOpenCVForUnity_1_1CoreModule_1_1Core.html#a06719211e27bdb5c67c454ea28b16f8b" title="Flips a 2D array around vertical, horizontal, or both axes.">Core.flip()</a> method.</td></tr>
    <tr><td class="paramname">cancellationToken</td><td>A token to monitor for cancellation requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if <em>renderTexture</em>  or <em>mat</em>  is null.</td></tr>
    <tr><td class="paramname">ArgumentException</td><td>Thrown if <em>renderTexture</em>  has <code>enableRandomWrite</code> set to false, or if the size or format of the RenderTexture is invalid. </td></tr>
    <tr><td class="paramname">OperationCanceledException</td><td>Thrown if the operation is canceled via <em>cancellationToken</em> .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eb2f0c63bfb30ee38400b4f505ff00d" name="a6eb2f0c63bfb30ee38400b4f505ff00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb2f0c63bfb30ee38400b4f505ff00d">&#9670;&#160;</a></span>Texture2DToMat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.Texture2DToMat </td>
          <td>(</td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unity Texture2D to an OpenCV Mat. </p>
<p>This method converts a Unity Texture2D to an OpenCV Mat. Conversion is possible even when the number of bytes per pixel differs, such as from Texture2D(RGBA32) to Mat(8UC1). In the case of multi-channel color to 1-channel, it is converted to grayscale. Performance is optimal when the per-pixel data size and color order match, such as with Texture2D(RGBA32) and Mat(8UC4). If the texture format is not RGBA32, BGRA32, RGB24, Alpha8, or R8, the <a href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels32.html">Texture2D.GetPixels32</a> methods are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture2D</td><td>The source Texture2D must have the same size as the destination Mat. The source Texture2D supports the following formats. (<a href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels32.html">Texture2D.GetPixels32</a>) </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). For other CvTypes or color orders, use <a class="el" href="#a66469433d52b25d29c733f9b1290a601">Texture2DToMatRaw</a>. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the pixel data retrieved from the Texture2D is flipped before conversion. The default is <code>true</code>, as the pixel data must be flipped to align with the coordinate system of the destination Mat. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Textrue2D image: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>texture2D</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8a614253f721cef291fbe361be97fd8" name="ad8a614253f721cef291fbe361be97fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a614253f721cef291fbe361be97fd8">&#9670;&#160;</a></span>Texture2DToMat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.Texture2DToMat </td>
          <td>(</td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mipLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unity Texture2D to an OpenCV Mat, targeting the specified mipmap level. </p>
<p>This method converts a Unity Texture2D to an OpenCV Mat, targeting the specified mipmap level. Conversion is possible even when the number of bytes per pixel differs, such as from Texture2D(RGBA32) to Mat(8UC1). In the case of multi-channel color to 1-channel, it is converted to grayscale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture2D</td><td>The source Texture2D supports the following formats. (<a href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels32.html">Texture2D.GetPixels32</a>) The source Texture2D most be supports mipmaps, as the conversion will target the<em>mipLevel</em> . </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). For other CvTypes or color orders, use <a class="el" href="#a66469433d52b25d29c733f9b1290a601">Texture2DToMatRaw</a>. The destination Mat must be the same size as the mipmap of the destination Texture2D. </td></tr>
    <tr><td class="paramname">mipLevel</td><td>The mipmap level to which the Mat will be converted. The level must be within the range supported by the source Texture2D. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the pixel data retrieved from the Texture2D is flipped before conversion. The default is <code>true</code>, as the pixel data must be flipped to align with the coordinate system of the destination Mat. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Textrue2D image: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>texture2D</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66469433d52b25d29c733f9b1290a601" name="a66469433d52b25d29c733f9b1290a601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66469433d52b25d29c733f9b1290a601">&#9670;&#160;</a></span>Texture2DToMatRaw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.Texture2DToMatRaw </td>
          <td>(</td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies raw data from a Unity Texture2D to an OpenCV Mat. </p>
<p>This method copies raw data from a Unity Texture2D to an OpenCV Mat. There are no specific requirements for the size or type of the Texture2D and Mat; data is copied up to the maximum size that fits within the data size of the destination Mat. A common use case for this method is writing a Texture2D in the BGRA32 format to a Mat with BGRA color order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture2D</td><td>The source Texture2D. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat must be 2-dimensional. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the pixel data retrieved from the Texture2D is flipped before copies. The default is <code>true</code>, as the pixel data must be flipped to align with the coordinate system of the destination Mat. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Textrue2D image: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes actually written to the destination Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>texture2D</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7377ae45dd455aad105c693837fc84a7" name="a7377ae45dd455aad105c693837fc84a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7377ae45dd455aad105c693837fc84a7">&#9670;&#160;</a></span>Texture2DToMatRaw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenCVForUnity.UnityIntegration.OpenCVMatUtils.Texture2DToMatRaw </td>
          <td>(</td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mipLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies raw data from a Unity Texture2D to an OpenCV Mat, targeting the specified mipmap level. </p>
<p>This method copies raw data from a Unity Texture2D to an OpenCV Mat, targeting the specified mipmap level. There are no specific requirements for the size or type of the Texture2D and Mat; data is copied up to the maximum size that fits within the data size of the mipmap of the destination Mat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture2D</td><td>The source Texture2D. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat must be 2-dimensional. </td></tr>
    <tr><td class="paramname">mipLevel</td><td>The mipmap level to which the Mat will be converted. The level must be within the range supported by the source Texture2D. </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the pixel data retrieved from the Texture2D is flipped before copies. The default is <code>true</code>, as the pixel data must be flipped to align with the coordinate system of the destination Mat. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Textrue2D image: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes actually written to the destination Mat. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>texture2D</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed99175c2a0da8a2ad178e29aa07f60f" name="aed99175c2a0da8a2ad178e29aa07f60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed99175c2a0da8a2ad178e29aa07f60f">&#9670;&#160;</a></span>TextureToMatAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static async Awaitable OpenCVForUnity.UnityIntegration.OpenCVMatUtils.TextureToMatAsync </td>
          <td>(</td>
          <td class="paramtype">Texture</td>          <td class="paramname"><span class="paramname"><em>texture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mipIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>z</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsFormat?</td>          <td class="paramname"><span class="paramname"><em>dstFormat</em></span><span class="paramdefsep"> = </span><span class="paramdefval">null</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CancellationToken</td>          <td class="paramname"><span class="paramname"><em>cancellationToken</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Texture to an OpenCV Mat asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The source Texture to be converted.</td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat that will store the converted texture data.</td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the pixel data retrieved from the Texture2D is flipped before copies. The default is <code>true</code>, as the pixel data must be flipped to align with the coordinate system of the destination Mat. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the Textrue2D image: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
    <tr><td class="paramname">mipIndex</td><td>Index of the mipmap to be fetched.</td></tr>
    <tr><td class="paramname">x</td><td>Starting X coordinate in pixels of the Texture data to be fetched.</td></tr>
    <tr><td class="paramname">width</td><td>Width in pixels of the Texture data to be fetched.</td></tr>
    <tr><td class="paramname">y</td><td>Starting Y coordinate in pixels of the Texture data to be fetched.</td></tr>
    <tr><td class="paramname">height</td><td>Height in pixels of the Texture data to be fetched.</td></tr>
    <tr><td class="paramname">z</td><td>Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth in pixels for Texture3D being fetched. Number of layers for TextureCube, TextureArray and TextureCubeArray.</td></tr>
    <tr><td class="paramname">dstFormat</td><td>Target GraphicsFormat of the data. If the target format is different from the format stored on the GPU, the conversion is automatic.</td></tr>
    <tr><td class="paramname">cancellationToken</td><td>Cancellation token to cancel the asynchronous operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if <em>texture</em>  or <em>mat</em>  is null.</td></tr>
    <tr><td class="paramname">NotSupportedException</td><td>Thrown when the graphics format of the texture is not supported for reading using AsyncGPUReadback.</td></tr>
    <tr><td class="paramname">OperationCanceledException</td><td>Thrown when the operation is canceled via the <em>cancellationToken</em> .</td></tr>
    <tr><td class="paramname">InvalidOperationException</td><td>Thrown when AsyncGPUReadback completes with an error.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08388b46ef2dc435ce1af58399e6d67" name="ad08388b46ef2dc435ce1af58399e6d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08388b46ef2dc435ce1af58399e6d67">&#9670;&#160;</a></span>TextureToMatAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static async Awaitable OpenCVForUnity.UnityIntegration.OpenCVMatUtils.TextureToMatAsync </td>
          <td>(</td>
          <td class="paramtype">Texture</td>          <td class="paramname"><span class="paramname"><em>texture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CancellationToken</td>          <td class="paramname"><span class="paramname"><em>cancellationToken</em></span><span class="paramdefsep"> = </span><span class="paramdefval">default</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Texture to an OpenCV Mat asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The source Texture to be converted.</td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat that will store the converted texture data.</td></tr>
    <tr><td class="paramname">cancellationToken</td><td>Cancellation token to cancel the asynchronous operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown if <em>texture</em>  or <em>mat</em>  is null.</td></tr>
    <tr><td class="paramname">NotSupportedException</td><td>Thrown when the graphics format of the texture is not supported for reading using AsyncGPUReadback.</td></tr>
    <tr><td class="paramname">OperationCanceledException</td><td>Thrown when the operation is canceled via the <em>cancellationToken</em> .</td></tr>
    <tr><td class="paramname">InvalidOperationException</td><td>Thrown when AsyncGPUReadback completes with an error.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fed56b72794391e3885dd4d40a7f34d" name="a1fed56b72794391e3885dd4d40a7f34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fed56b72794391e3885dd4d40a7f34d">&#9670;&#160;</a></span>TextureToTexture2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.TextureToTexture2D </td>
          <td>(</td>
          <td class="paramtype">Texture</td>          <td class="paramname"><span class="paramname"><em>texture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture2D</td>          <td class="paramname"><span class="paramname"><em>texture2D</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OPENCV_DONT_USE_WEBCAMTEXTURE_API. </p>
<p>Converts a Texture to a Texture2D.</p>
<p>This method converts a Texture to a Texture2D. The Texture and the Texture2D must be the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The source Texture. </td></tr>
    <tr><td class="paramname">texture2D</td><td>The destination Texture2D. It must have a TextureFormat of RGBA32, ARGB32, RGB24, RGBAFloat, or RGBAHalf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>texture</em>  or <em>texture2D</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ec4098aed348d209660111baa629607" name="a3ec4098aed348d209660111baa629607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec4098aed348d209660111baa629607">&#9670;&#160;</a></span>WebCamTextureToMat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.WebCamTextureToMat </td>
          <td>(</td>
          <td class="paramtype">WebCamTexture</td>          <td class="paramname"><span class="paramname"><em>webCamTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unity WebCamTexture to an OpenCV Mat. </p>
<p>This method converts a Unity WebCamTexture image to an OpenCV Mat. Conversion is possible even when the number of bytes per pixel differs, such as from WebCamTexture(RGBA32) to Mat(8UC1). In the case of multi-channel color to 1-channel, it is converted to grayscale. Performance is optimal when the per-pixel data size and color order match, such as with Texture2D(RGBA32) and Mat(8UC4). It is recommended to use the <em>pixels32Buffer</em>  argument to avoid repeated memory allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webCamTexture</td><td>The source WebCamTexture must have the same size as the destination Mat. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the pixel data retrieved from the WebCamTexture is flipped before conversion. The default is <code>true</code>, as the pixel data must be flipped to align with the coordinate system of the destination Mat. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the WebCamTexture image: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>webCamTexture</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d91cb9bb110e0b12683c85822d83444" name="a8d91cb9bb110e0b12683c85822d83444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d91cb9bb110e0b12683c85822d83444">&#9670;&#160;</a></span>WebCamTextureToMat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenCVForUnity.UnityIntegration.OpenCVMatUtils.WebCamTextureToMat </td>
          <td>(</td>
          <td class="paramtype">WebCamTexture</td>          <td class="paramname"><span class="paramname"><em>webCamTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dc6/classOpenCVForUnity_1_1CoreModule_1_1Mat.html">Mat</a></td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color32[]</td>          <td class="paramname"><span class="paramname"><em>pixels32Buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flipCode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a Unity WebCamTexture to an OpenCV Mat. </p>
<p>This method converts a Unity WebCamTexture image to an OpenCV Mat. Conversion is possible even when the number of bytes per pixel differs, such as from WebCamTexture(RGBA32) to Mat(8UC1). In the case of multi-channel color to 1-channel, it is converted to grayscale. Performance is optimal when the per-pixel data size and color order match, such as with Texture2D(RGBA32) and Mat(8UC4). It is recommended to use the <em>pixels32Buffer</em>  argument to avoid repeated memory allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webCamTexture</td><td>The source WebCamTexture must have the same size as the destination Mat. </td></tr>
    <tr><td class="paramname">mat</td><td>The destination Mat must be 2-dimensional, with a CvType of 'CV_8UC4' (RGBA), 'CV_8UC3' (RGB), or 'CV_8UC1' (GRAYSCALE). </td></tr>
    <tr><td class="paramname">pixels32Buffer</td><td>An optional array for receiving pixel data as Color32. Using this array helps avoid memory allocation each frame. Ensure the array is initialized to a length matching the textures width * height. (<a href="http://docs.unity3d.com/ScriptReference/WebCamTexture.GetPixels32.html">WebCamTexture.GetPixels32</a>) </td></tr>
    <tr><td class="paramname">flip</td><td>If <code>true</code>, the pixel data retrieved from the WebCamTexture is flipped before conversion. The default is <code>true</code>, as the pixel data must be flipped to align with the coordinate system of the destination Mat. </td></tr>
    <tr><td class="paramname">flipCode</td><td>Specifies how to flip the WebCamTexture image: Vertical flipping of the image (flipCode == 0) to flip around the x-axis, horizontal flipping of the image (flipCode &gt; 0, e.g., 1) to flip around the y-axis, and simultaneous horizontal and vertical flipping (flipCode &lt; 0, e.g., -1) to flip around both axes. The default is <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentNullException</td><td>Thrown when <em>webCamTexture</em>  or <em>mat</em>  is null. </td></tr>
    <tr><td class="paramname">ArgumentException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/unity/<a class="el" href="../../dc/d4e/OpenCVMatUtils_8cs.html">OpenCVMatUtils.cs</a></li>
<li>OpenCVForUnity/Assets/OpenCVForUnity/org/opencv/unity/<a class="el" href="../../d3/d10/OpenCVMatUtils__ComputeShader_8cs.html">OpenCVMatUtils_ComputeShader.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
